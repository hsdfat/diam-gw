// Code generated by diameter-codegen. DO NOT EDIT.

package base

import (
	"bytes"
	"net"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcapgo"
	"github.com/hsdfat8/diam-gw/models_base"
)

// writeDiameterToPcap writes a Diameter message to a pcap file with proper network layers
func writeDiameterToPcap(filename string, diameterData []byte, srcIP, dstIP net.IP, port int) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	// Create packet layers
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(port),
		DstPort: layers.TCPPort(3868), // Diameter default port
		Seq:     1000,
		Ack:     0,
		SYN:     false,
		ACK:     true,
		PSH:     true,
		Window:  65535,
	}

	// Set TCP options for better compatibility
	tcp.Options = []layers.TCPOption{
		{
			OptionType:   layers.TCPOptionKindMSS,
			OptionLength: 4,
			OptionData:   []byte{0x05, 0xb4}, // MSS = 1460
		},
		{
			OptionType: layers.TCPOptionKindNop,
		},
		{
			OptionType:   layers.TCPOptionKindWindowScale,
			OptionLength: 3,
			OptionData:   []byte{0x07}, // Window scale = 7
		},
	}

	// Calculate TCP checksum
	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize the packet
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	// Create payload (Diameter data)
	payload := gopacket.Payload(diameterData)

	// Serialize all layers
	err = gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet to pcap file
	ci := gopacket.CaptureInfo{
		Timestamp:     time.Now(),
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	err = w.WritePacket(ci, packetBuf.Bytes())
	if err != nil {
		return err
	}

	return nil
}

// writePacketToPcap writes a single packet to an existing pcap writer
func writePacketToPcap(w *pcapgo.Writer, diameterData []byte, srcIP, dstIP net.IP, srcPort, dstPort int, seq, ack uint32, timestamp time.Time) error {
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(dstPort),
		Seq:     seq,
		Ack:     ack,
		SYN:     ack == 0 && seq == 1000, // Only for SYN packet
		ACK:     ack > 0,                 // ACK if we have acknowledgment number
		PSH:     true,                    // Push flag for data packets
		Window:  65535,
	}

	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	payload := gopacket.Payload(diameterData)

	err := gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet
	ci := gopacket.CaptureInfo{
		Timestamp:     timestamp,
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	return w.WritePacket(ci, packetBuf.Bytes())
}

// writeDiameterPairToPcap writes a request-response pair to a single pcap file
func writeDiameterPairToPcap(filename string, requestData, responseData []byte, clientIP, serverIP net.IP) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	baseTime := time.Now()
	clientPort := 54321
	serverPort := 3868

	// Write request packet (client -> server)
	err = writePacketToPcap(w, requestData, clientIP, serverIP, clientPort, serverPort, 1000, 1, baseTime)
	if err != nil {
		return err
	}

	// Write response packet (server -> client) with small delay
	responseTime := baseTime.Add(10 * time.Millisecond)
	err = writePacketToPcap(w, responseData, serverIP, clientIP, serverPort, clientPort, 1, 1000+uint32(len(requestData)), responseTime)
	if err != nil {
		return err
	}

	return nil
}

// TestCapabilitiesExchangeRequest_Creation tests basic creation and initialization
func TestCapabilitiesExchangeRequest_Creation(t *testing.T) {
	msg := NewCapabilitiesExchangeRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 257 {
		t.Errorf("Expected command code 257, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != false {
		t.Errorf("Expected Proxiable flag false, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestCapabilitiesExchangeRequest_Validation tests field validation
func TestCapabilitiesExchangeRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &CapabilitiesExchangeRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewCapabilitiesExchangeRequest()
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.HostIpAddress = []models_base.Address{
			models_base.Address(net.ParseIP("192.168.1.100")),
		}
		msg.VendorId = models_base.Unsigned32(10415) // 3GPP
		msg.ProductName = models_base.UTF8String("TestProduct/1.0")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

func TestValidateMissingFields_CER(t *testing.T) {
	// Test validation with each required field missing
	tests := []struct {
		name         string
		missingField string
		setupFunc    func(*CapabilitiesExchangeRequest)
	}{
		{
			name:         "missing_HostIpAddress",
			missingField: "Host-IP-Address",
			setupFunc: func(msg *CapabilitiesExchangeRequest) {
				// Set all fields except the one being tested
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			msg := NewCapabilitiesExchangeRequest()
			tt.setupFunc(msg)

			err := msg.Validate()
			if err == nil {
				t.Errorf("Expected validation error for missing %s, but got nil", tt.missingField)
			}
		})
	}
}

// TestCapabilitiesExchangeRequest_PCAP tests PCAP file generation for Request message
func TestCapabilitiesExchangeRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_cer.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewCapabilitiesExchangeRequest()
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestCapabilitiesExchangeRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestCapabilitiesExchangeRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewCapabilitiesExchangeRequest()
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	original.VendorId = models_base.Unsigned32(10415) // 3GPP
	original.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &CapabilitiesExchangeRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if len(decoded.HostIpAddress) != len(original.HostIpAddress) {
		t.Errorf("HostIpAddress length mismatch: got %d, want %d", len(decoded.HostIpAddress), len(original.HostIpAddress))
	}
	if decoded.VendorId != original.VendorId {
		t.Errorf("VendorId mismatch: got %d, want %d", decoded.VendorId, original.VendorId)
	}
	if decoded.ProductName != original.ProductName {
		t.Errorf("ProductName mismatch: got %v, want %v", decoded.ProductName, original.ProductName)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewCapabilitiesExchangeRequest(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewCapabilitiesExchangeRequest()
	}
}

func BenchmarkCapabilitiesExchangeRequest_Marshal(b *testing.B) {
	msg := NewCapabilitiesExchangeRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCapabilitiesExchangeRequest_Unmarshal(b *testing.B) {
	msg := NewCapabilitiesExchangeRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &CapabilitiesExchangeRequest{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCapabilitiesExchangeRequest_Roundtrip(b *testing.B) {
	msg := NewCapabilitiesExchangeRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &CapabilitiesExchangeRequest{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestCapabilitiesExchangeAnswer_Creation tests basic creation and initialization
func TestCapabilitiesExchangeAnswer_Creation(t *testing.T) {
	msg := NewCapabilitiesExchangeAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 257 {
		t.Errorf("Expected command code 257, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != false {
		t.Errorf("Expected Proxiable flag false, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestCapabilitiesExchangeAnswer_Validation tests field validation
func TestCapabilitiesExchangeAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &CapabilitiesExchangeAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewCapabilitiesExchangeAnswer()
		msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
		msg.HostIpAddress = []models_base.Address{
			models_base.Address(net.ParseIP("192.168.1.100")),
		}
		msg.VendorId = models_base.Unsigned32(10415) // 3GPP
		msg.ProductName = models_base.UTF8String("TestProduct/1.0")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

func TestValidateMissingFields_CEA(t *testing.T) {
	// Test validation with each required field missing
	tests := []struct {
		name         string
		missingField string
		setupFunc    func(*CapabilitiesExchangeAnswer)
	}{
		{
			name:         "missing_HostIpAddress",
			missingField: "Host-IP-Address",
			setupFunc: func(msg *CapabilitiesExchangeAnswer) {
				// Set all fields except the one being tested
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			msg := NewCapabilitiesExchangeAnswer()
			tt.setupFunc(msg)

			err := msg.Validate()
			if err == nil {
				t.Errorf("Expected validation error for missing %s, but got nil", tt.missingField)
			}
		})
	}
}

// TestCapabilitiesExchangeAnswer_PCAP tests PCAP file generation for Answer message
func TestCapabilitiesExchangeAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_cea.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewCapabilitiesExchangeAnswer()
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestCapabilitiesExchangeAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestCapabilitiesExchangeAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewCapabilitiesExchangeAnswer()
	original.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")
	original.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	original.VendorId = models_base.Unsigned32(10415) // 3GPP
	original.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &CapabilitiesExchangeAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.ResultCode != original.ResultCode {
		t.Errorf("ResultCode mismatch: got %d, want %d", decoded.ResultCode, original.ResultCode)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if len(decoded.HostIpAddress) != len(original.HostIpAddress) {
		t.Errorf("HostIpAddress length mismatch: got %d, want %d", len(decoded.HostIpAddress), len(original.HostIpAddress))
	}
	if decoded.VendorId != original.VendorId {
		t.Errorf("VendorId mismatch: got %d, want %d", decoded.VendorId, original.VendorId)
	}
	if decoded.ProductName != original.ProductName {
		t.Errorf("ProductName mismatch: got %v, want %v", decoded.ProductName, original.ProductName)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewCapabilitiesExchangeAnswer(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewCapabilitiesExchangeAnswer()
	}
}

func BenchmarkCapabilitiesExchangeAnswer_Marshal(b *testing.B) {
	msg := NewCapabilitiesExchangeAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCapabilitiesExchangeAnswer_Unmarshal(b *testing.B) {
	msg := NewCapabilitiesExchangeAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &CapabilitiesExchangeAnswer{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkCapabilitiesExchangeAnswer_Roundtrip(b *testing.B) {
	msg := NewCapabilitiesExchangeAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &CapabilitiesExchangeAnswer{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestDeviceWatchdogRequest_Creation tests basic creation and initialization
func TestDeviceWatchdogRequest_Creation(t *testing.T) {
	msg := NewDeviceWatchdogRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 280 {
		t.Errorf("Expected command code 280, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != false {
		t.Errorf("Expected Proxiable flag false, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestDeviceWatchdogRequest_Validation tests field validation
func TestDeviceWatchdogRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &DeviceWatchdogRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewDeviceWatchdogRequest()
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestDeviceWatchdogRequest_PCAP tests PCAP file generation for Request message
func TestDeviceWatchdogRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dwr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewDeviceWatchdogRequest()
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestDeviceWatchdogRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestDeviceWatchdogRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewDeviceWatchdogRequest()
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &DeviceWatchdogRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewDeviceWatchdogRequest(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewDeviceWatchdogRequest()
	}
}

func BenchmarkDeviceWatchdogRequest_Marshal(b *testing.B) {
	msg := NewDeviceWatchdogRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDeviceWatchdogRequest_Unmarshal(b *testing.B) {
	msg := NewDeviceWatchdogRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &DeviceWatchdogRequest{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDeviceWatchdogRequest_Roundtrip(b *testing.B) {
	msg := NewDeviceWatchdogRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &DeviceWatchdogRequest{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestDeviceWatchdogAnswer_Creation tests basic creation and initialization
func TestDeviceWatchdogAnswer_Creation(t *testing.T) {
	msg := NewDeviceWatchdogAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 280 {
		t.Errorf("Expected command code 280, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != false {
		t.Errorf("Expected Proxiable flag false, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestDeviceWatchdogAnswer_Validation tests field validation
func TestDeviceWatchdogAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &DeviceWatchdogAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewDeviceWatchdogAnswer()
		msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestDeviceWatchdogAnswer_PCAP tests PCAP file generation for Answer message
func TestDeviceWatchdogAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dwa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewDeviceWatchdogAnswer()
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestDeviceWatchdogAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestDeviceWatchdogAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewDeviceWatchdogAnswer()
	original.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &DeviceWatchdogAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.ResultCode != original.ResultCode {
		t.Errorf("ResultCode mismatch: got %d, want %d", decoded.ResultCode, original.ResultCode)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewDeviceWatchdogAnswer(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewDeviceWatchdogAnswer()
	}
}

func BenchmarkDeviceWatchdogAnswer_Marshal(b *testing.B) {
	msg := NewDeviceWatchdogAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDeviceWatchdogAnswer_Unmarshal(b *testing.B) {
	msg := NewDeviceWatchdogAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &DeviceWatchdogAnswer{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDeviceWatchdogAnswer_Roundtrip(b *testing.B) {
	msg := NewDeviceWatchdogAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &DeviceWatchdogAnswer{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestDisconnectPeerRequest_Creation tests basic creation and initialization
func TestDisconnectPeerRequest_Creation(t *testing.T) {
	msg := NewDisconnectPeerRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 282 {
		t.Errorf("Expected command code 282, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != false {
		t.Errorf("Expected Proxiable flag false, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestDisconnectPeerRequest_Validation tests field validation
func TestDisconnectPeerRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &DisconnectPeerRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewDisconnectPeerRequest()
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.DisconnectCause = models_base.Enumerated(1)

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestDisconnectPeerRequest_PCAP tests PCAP file generation for Request message
func TestDisconnectPeerRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dpr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewDisconnectPeerRequest()
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DisconnectCause = models_base.Enumerated(1)

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestDisconnectPeerRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestDisconnectPeerRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewDisconnectPeerRequest()
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.DisconnectCause = models_base.Enumerated(1)

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &DisconnectPeerRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.DisconnectCause != original.DisconnectCause {
		t.Errorf("DisconnectCause mismatch: got %d, want %d", decoded.DisconnectCause, original.DisconnectCause)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewDisconnectPeerRequest(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewDisconnectPeerRequest()
	}
}

func BenchmarkDisconnectPeerRequest_Marshal(b *testing.B) {
	msg := NewDisconnectPeerRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DisconnectCause = models_base.Enumerated(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDisconnectPeerRequest_Unmarshal(b *testing.B) {
	msg := NewDisconnectPeerRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DisconnectCause = models_base.Enumerated(1)

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &DisconnectPeerRequest{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDisconnectPeerRequest_Roundtrip(b *testing.B) {
	msg := NewDisconnectPeerRequest()

	// Set required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DisconnectCause = models_base.Enumerated(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &DisconnectPeerRequest{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestDisconnectPeerAnswer_Creation tests basic creation and initialization
func TestDisconnectPeerAnswer_Creation(t *testing.T) {
	msg := NewDisconnectPeerAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 282 {
		t.Errorf("Expected command code 282, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != false {
		t.Errorf("Expected Proxiable flag false, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestDisconnectPeerAnswer_Validation tests field validation
func TestDisconnectPeerAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &DisconnectPeerAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewDisconnectPeerAnswer()
		msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestDisconnectPeerAnswer_PCAP tests PCAP file generation for Answer message
func TestDisconnectPeerAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dpa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewDisconnectPeerAnswer()
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestDisconnectPeerAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestDisconnectPeerAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewDisconnectPeerAnswer()
	original.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &DisconnectPeerAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.ResultCode != original.ResultCode {
		t.Errorf("ResultCode mismatch: got %d, want %d", decoded.ResultCode, original.ResultCode)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewDisconnectPeerAnswer(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewDisconnectPeerAnswer()
	}
}

func BenchmarkDisconnectPeerAnswer_Marshal(b *testing.B) {
	msg := NewDisconnectPeerAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDisconnectPeerAnswer_Unmarshal(b *testing.B) {
	msg := NewDisconnectPeerAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &DisconnectPeerAnswer{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkDisconnectPeerAnswer_Roundtrip(b *testing.B) {
	msg := NewDisconnectPeerAnswer()

	// Set required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &DisconnectPeerAnswer{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestReAuthRequest_Creation tests basic creation and initialization
func TestReAuthRequest_Creation(t *testing.T) {
	msg := NewReAuthRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 258 {
		t.Errorf("Expected command code 258, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestReAuthRequest_Validation tests field validation
func TestReAuthRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &ReAuthRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewReAuthRequest()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
		msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
		msg.AuthApplicationId = models_base.Unsigned32(1)
		msg.ReAuthRequestType = models_base.Enumerated(1)

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestReAuthRequest_PCAP tests PCAP file generation for Request message
func TestReAuthRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_rar.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewReAuthRequest()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.ReAuthRequestType = models_base.Enumerated(1)

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestReAuthRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestReAuthRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewReAuthRequest()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	original.DestinationHost = models_base.DiameterIdentity("server.example.com")
	original.AuthApplicationId = models_base.Unsigned32(1)
	original.ReAuthRequestType = models_base.Enumerated(1)

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &ReAuthRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.DestinationRealm != original.DestinationRealm {
		t.Errorf("DestinationRealm mismatch: got %v, want %v", decoded.DestinationRealm, original.DestinationRealm)
	}
	if decoded.DestinationHost != original.DestinationHost {
		t.Errorf("DestinationHost mismatch: got %v, want %v", decoded.DestinationHost, original.DestinationHost)
	}
	if decoded.AuthApplicationId != original.AuthApplicationId {
		t.Errorf("AuthApplicationId mismatch: got %d, want %d", decoded.AuthApplicationId, original.AuthApplicationId)
	}
	if decoded.ReAuthRequestType != original.ReAuthRequestType {
		t.Errorf("ReAuthRequestType mismatch: got %d, want %d", decoded.ReAuthRequestType, original.ReAuthRequestType)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewReAuthRequest(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewReAuthRequest()
	}
}

func BenchmarkReAuthRequest_Marshal(b *testing.B) {
	msg := NewReAuthRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.ReAuthRequestType = models_base.Enumerated(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkReAuthRequest_Unmarshal(b *testing.B) {
	msg := NewReAuthRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.ReAuthRequestType = models_base.Enumerated(1)

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &ReAuthRequest{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkReAuthRequest_Roundtrip(b *testing.B) {
	msg := NewReAuthRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.ReAuthRequestType = models_base.Enumerated(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &ReAuthRequest{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestReAuthAnswer_Creation tests basic creation and initialization
func TestReAuthAnswer_Creation(t *testing.T) {
	msg := NewReAuthAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 258 {
		t.Errorf("Expected command code 258, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestReAuthAnswer_Validation tests field validation
func TestReAuthAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &ReAuthAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewReAuthAnswer()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestReAuthAnswer_PCAP tests PCAP file generation for Answer message
func TestReAuthAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_raa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewReAuthAnswer()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestReAuthAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestReAuthAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewReAuthAnswer()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &ReAuthAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.ResultCode != original.ResultCode {
		t.Errorf("ResultCode mismatch: got %d, want %d", decoded.ResultCode, original.ResultCode)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewReAuthAnswer(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewReAuthAnswer()
	}
}

func BenchmarkReAuthAnswer_Marshal(b *testing.B) {
	msg := NewReAuthAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkReAuthAnswer_Unmarshal(b *testing.B) {
	msg := NewReAuthAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &ReAuthAnswer{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkReAuthAnswer_Roundtrip(b *testing.B) {
	msg := NewReAuthAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &ReAuthAnswer{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestSessionTerminationRequest_Creation tests basic creation and initialization
func TestSessionTerminationRequest_Creation(t *testing.T) {
	msg := NewSessionTerminationRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 275 {
		t.Errorf("Expected command code 275, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestSessionTerminationRequest_Validation tests field validation
func TestSessionTerminationRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &SessionTerminationRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewSessionTerminationRequest()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
		msg.AuthApplicationId = models_base.Unsigned32(1)
		msg.TerminationCause = models_base.Enumerated(1)

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestSessionTerminationRequest_PCAP tests PCAP file generation for Request message
func TestSessionTerminationRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_str.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewSessionTerminationRequest()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.TerminationCause = models_base.Enumerated(1)

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestSessionTerminationRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestSessionTerminationRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewSessionTerminationRequest()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	original.AuthApplicationId = models_base.Unsigned32(1)
	original.TerminationCause = models_base.Enumerated(1)

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &SessionTerminationRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.DestinationRealm != original.DestinationRealm {
		t.Errorf("DestinationRealm mismatch: got %v, want %v", decoded.DestinationRealm, original.DestinationRealm)
	}
	if decoded.AuthApplicationId != original.AuthApplicationId {
		t.Errorf("AuthApplicationId mismatch: got %d, want %d", decoded.AuthApplicationId, original.AuthApplicationId)
	}
	if decoded.TerminationCause != original.TerminationCause {
		t.Errorf("TerminationCause mismatch: got %d, want %d", decoded.TerminationCause, original.TerminationCause)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewSessionTerminationRequest(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewSessionTerminationRequest()
	}
}

func BenchmarkSessionTerminationRequest_Marshal(b *testing.B) {
	msg := NewSessionTerminationRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.TerminationCause = models_base.Enumerated(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkSessionTerminationRequest_Unmarshal(b *testing.B) {
	msg := NewSessionTerminationRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.TerminationCause = models_base.Enumerated(1)

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &SessionTerminationRequest{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkSessionTerminationRequest_Roundtrip(b *testing.B) {
	msg := NewSessionTerminationRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.TerminationCause = models_base.Enumerated(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &SessionTerminationRequest{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestSessionTerminationAnswer_Creation tests basic creation and initialization
func TestSessionTerminationAnswer_Creation(t *testing.T) {
	msg := NewSessionTerminationAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 275 {
		t.Errorf("Expected command code 275, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestSessionTerminationAnswer_Validation tests field validation
func TestSessionTerminationAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &SessionTerminationAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewSessionTerminationAnswer()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestSessionTerminationAnswer_PCAP tests PCAP file generation for Answer message
func TestSessionTerminationAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_sta.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewSessionTerminationAnswer()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestSessionTerminationAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestSessionTerminationAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewSessionTerminationAnswer()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &SessionTerminationAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.ResultCode != original.ResultCode {
		t.Errorf("ResultCode mismatch: got %d, want %d", decoded.ResultCode, original.ResultCode)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewSessionTerminationAnswer(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewSessionTerminationAnswer()
	}
}

func BenchmarkSessionTerminationAnswer_Marshal(b *testing.B) {
	msg := NewSessionTerminationAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkSessionTerminationAnswer_Unmarshal(b *testing.B) {
	msg := NewSessionTerminationAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &SessionTerminationAnswer{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkSessionTerminationAnswer_Roundtrip(b *testing.B) {
	msg := NewSessionTerminationAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &SessionTerminationAnswer{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestAbortSessionRequest_Creation tests basic creation and initialization
func TestAbortSessionRequest_Creation(t *testing.T) {
	msg := NewAbortSessionRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 274 {
		t.Errorf("Expected command code 274, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestAbortSessionRequest_Validation tests field validation
func TestAbortSessionRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &AbortSessionRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewAbortSessionRequest()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
		msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
		msg.AuthApplicationId = models_base.Unsigned32(1)

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestAbortSessionRequest_PCAP tests PCAP file generation for Request message
func TestAbortSessionRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_asr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewAbortSessionRequest()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestAbortSessionRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestAbortSessionRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewAbortSessionRequest()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	original.DestinationHost = models_base.DiameterIdentity("server.example.com")
	original.AuthApplicationId = models_base.Unsigned32(1)

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &AbortSessionRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.DestinationRealm != original.DestinationRealm {
		t.Errorf("DestinationRealm mismatch: got %v, want %v", decoded.DestinationRealm, original.DestinationRealm)
	}
	if decoded.DestinationHost != original.DestinationHost {
		t.Errorf("DestinationHost mismatch: got %v, want %v", decoded.DestinationHost, original.DestinationHost)
	}
	if decoded.AuthApplicationId != original.AuthApplicationId {
		t.Errorf("AuthApplicationId mismatch: got %d, want %d", decoded.AuthApplicationId, original.AuthApplicationId)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewAbortSessionRequest(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewAbortSessionRequest()
	}
}

func BenchmarkAbortSessionRequest_Marshal(b *testing.B) {
	msg := NewAbortSessionRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAbortSessionRequest_Unmarshal(b *testing.B) {
	msg := NewAbortSessionRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &AbortSessionRequest{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAbortSessionRequest_Roundtrip(b *testing.B) {
	msg := NewAbortSessionRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &AbortSessionRequest{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestAbortSessionAnswer_Creation tests basic creation and initialization
func TestAbortSessionAnswer_Creation(t *testing.T) {
	msg := NewAbortSessionAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 274 {
		t.Errorf("Expected command code 274, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 0 {
		t.Errorf("Expected application ID 0, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestAbortSessionAnswer_Validation tests field validation
func TestAbortSessionAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &AbortSessionAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewAbortSessionAnswer()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestAbortSessionAnswer_PCAP tests PCAP file generation for Answer message
func TestAbortSessionAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_asa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewAbortSessionAnswer()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestAbortSessionAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestAbortSessionAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewAbortSessionAnswer()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &AbortSessionAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.ResultCode != original.ResultCode {
		t.Errorf("ResultCode mismatch: got %d, want %d", decoded.ResultCode, original.ResultCode)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewAbortSessionAnswer(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewAbortSessionAnswer()
	}
}

func BenchmarkAbortSessionAnswer_Marshal(b *testing.B) {
	msg := NewAbortSessionAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAbortSessionAnswer_Unmarshal(b *testing.B) {
	msg := NewAbortSessionAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &AbortSessionAnswer{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAbortSessionAnswer_Roundtrip(b *testing.B) {
	msg := NewAbortSessionAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &AbortSessionAnswer{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestAccountingRequest_Creation tests basic creation and initialization
func TestAccountingRequest_Creation(t *testing.T) {
	msg := NewAccountingRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 271 {
		t.Errorf("Expected command code 271, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 3 {
		t.Errorf("Expected application ID 3, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestAccountingRequest_Validation tests field validation
func TestAccountingRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &AccountingRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewAccountingRequest()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
		msg.AccountingRecordType = models_base.Enumerated(1)
		msg.AccountingRecordNumber = models_base.Unsigned32(1)

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestAccountingRequest_PCAP tests PCAP file generation for Request message
func TestAccountingRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ar.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewAccountingRequest()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestAccountingRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestAccountingRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewAccountingRequest()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	original.AccountingRecordType = models_base.Enumerated(1)
	original.AccountingRecordNumber = models_base.Unsigned32(1)

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &AccountingRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.DestinationRealm != original.DestinationRealm {
		t.Errorf("DestinationRealm mismatch: got %v, want %v", decoded.DestinationRealm, original.DestinationRealm)
	}
	if decoded.AccountingRecordType != original.AccountingRecordType {
		t.Errorf("AccountingRecordType mismatch: got %d, want %d", decoded.AccountingRecordType, original.AccountingRecordType)
	}
	if decoded.AccountingRecordNumber != original.AccountingRecordNumber {
		t.Errorf("AccountingRecordNumber mismatch: got %d, want %d", decoded.AccountingRecordNumber, original.AccountingRecordNumber)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewAccountingRequest(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewAccountingRequest()
	}
}

func BenchmarkAccountingRequest_Marshal(b *testing.B) {
	msg := NewAccountingRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAccountingRequest_Unmarshal(b *testing.B) {
	msg := NewAccountingRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &AccountingRequest{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAccountingRequest_Roundtrip(b *testing.B) {
	msg := NewAccountingRequest()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &AccountingRequest{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestAccountingAnswer_Creation tests basic creation and initialization
func TestAccountingAnswer_Creation(t *testing.T) {
	msg := NewAccountingAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 271 {
		t.Errorf("Expected command code 271, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 3 {
		t.Errorf("Expected application ID 3, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestAccountingAnswer_Validation tests field validation
func TestAccountingAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &AccountingAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewAccountingAnswer()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
		msg.AccountingRecordType = models_base.Enumerated(1)
		msg.AccountingRecordNumber = models_base.Unsigned32(1)

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestAccountingAnswer_PCAP tests PCAP file generation for Answer message
func TestAccountingAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_aa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewAccountingAnswer()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestAccountingAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestAccountingAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewAccountingAnswer()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")
	original.AccountingRecordType = models_base.Enumerated(1)
	original.AccountingRecordNumber = models_base.Unsigned32(1)

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &AccountingAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.ResultCode != original.ResultCode {
		t.Errorf("ResultCode mismatch: got %d, want %d", decoded.ResultCode, original.ResultCode)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.AccountingRecordType != original.AccountingRecordType {
		t.Errorf("AccountingRecordType mismatch: got %d, want %d", decoded.AccountingRecordType, original.AccountingRecordType)
	}
	if decoded.AccountingRecordNumber != original.AccountingRecordNumber {
		t.Errorf("AccountingRecordNumber mismatch: got %d, want %d", decoded.AccountingRecordNumber, original.AccountingRecordNumber)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

func BenchmarkNewAccountingAnswer(b *testing.B) {
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_ = NewAccountingAnswer()
	}
}

func BenchmarkAccountingAnswer_Marshal(b *testing.B) {
	msg := NewAccountingAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAccountingAnswer_Unmarshal(b *testing.B) {
	msg := NewAccountingAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	data, err := msg.Marshal()
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		result := &AccountingAnswer{}
		err := result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkAccountingAnswer_Roundtrip(b *testing.B) {
	msg := NewAccountingAnswer()

	// Set required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		data, err := msg.Marshal()
		if err != nil {
			b.Fatal(err)
		}
		result := &AccountingAnswer{}
		err = result.Unmarshal(data)
		if err != nil {
			b.Fatal(err)
		}
	}
}

// TestDP_Pair_PCAP tests PCAP file generation for DP request-response pair
func TestDP_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dp_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewDisconnectPeerRequest()
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DisconnectCause = models_base.Enumerated(1)

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewDisconnectPeerAnswer()
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestRA_Pair_PCAP tests PCAP file generation for RA request-response pair
func TestRA_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ra_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewReAuthRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.DestinationHost = models_base.DiameterIdentity("server.example.com")
	request.AuthApplicationId = models_base.Unsigned32(1)
	request.ReAuthRequestType = models_base.Enumerated(1)

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewReAuthAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestST_Pair_PCAP tests PCAP file generation for ST request-response pair
func TestST_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_st_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewSessionTerminationRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.AuthApplicationId = models_base.Unsigned32(1)
	request.TerminationCause = models_base.Enumerated(1)

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewSessionTerminationAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestAS_Pair_PCAP tests PCAP file generation for AS request-response pair
func TestAS_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_as_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewAbortSessionRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.DestinationHost = models_base.DiameterIdentity("server.example.com")
	request.AuthApplicationId = models_base.Unsigned32(1)

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewAbortSessionAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestA_Pair_PCAP tests PCAP file generation for A request-response pair
func TestA_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_a_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewAccountingRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.AccountingRecordType = models_base.Enumerated(1)
	request.AccountingRecordNumber = models_base.Unsigned32(1)

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewAccountingAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.AccountingRecordType = models_base.Enumerated(1)
	answer.AccountingRecordNumber = models_base.Unsigned32(1)

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestCE_Pair_PCAP tests PCAP file generation for CE request-response pair
func TestCE_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ce_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewCapabilitiesExchangeRequest()
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	request.VendorId = models_base.Unsigned32(10415) // 3GPP
	request.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewCapabilitiesExchangeAnswer()
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	answer.VendorId = models_base.Unsigned32(10415) // 3GPP
	answer.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestDW_Pair_PCAP tests PCAP file generation for DW request-response pair
func TestDW_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dw_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewDeviceWatchdogRequest()
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewDeviceWatchdogAnswer()
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}
