// Code generated by diameter-codegen. DO NOT EDIT.

package base

import (
	"net"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcapgo"
	"github.com/hsdfat8/diam-gw/models_base"
)

// writeDiameterToPcap writes a Diameter message to a pcap file with proper network layers
func writeDiameterToPcap(filename string, diameterData []byte, srcIP, dstIP net.IP, port int) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	// Create packet layers
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(port),
		DstPort: layers.TCPPort(3868), // Diameter default port
		Seq:     1000,
		Ack:     0,
		SYN:     false,
		ACK:     true,
		PSH:     true,
		Window:  65535,
	}

	// Set TCP options for better compatibility
	tcp.Options = []layers.TCPOption{
		{
			OptionType:   layers.TCPOptionKindMSS,
			OptionLength: 4,
			OptionData:   []byte{0x05, 0xb4}, // MSS = 1460
		},
		{
			OptionType: layers.TCPOptionKindNop,
		},
		{
			OptionType:   layers.TCPOptionKindWindowScale,
			OptionLength: 3,
			OptionData:   []byte{0x07}, // Window scale = 7
		},
	}

	// Calculate TCP checksum
	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize the packet
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	// Create payload (Diameter data)
	payload := gopacket.Payload(diameterData)

	// Serialize all layers
	err = gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet to pcap file
	ci := gopacket.CaptureInfo{
		Timestamp:     time.Now(),
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	err = w.WritePacket(ci, packetBuf.Bytes())
	if err != nil {
		return err
	}

	return nil
}

// writePacketToPcap writes a single packet to an existing pcap writer
func writePacketToPcap(w *pcapgo.Writer, diameterData []byte, srcIP, dstIP net.IP, srcPort, dstPort int, seq, ack uint32, timestamp time.Time) error {
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(dstPort),
		Seq:     seq,
		Ack:     ack,
		SYN:     ack == 0 && seq == 1000, // Only for SYN packet
		ACK:     ack > 0,                 // ACK if we have acknowledgment number
		PSH:     true,                    // Push flag for data packets
		Window:  65535,
	}

	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	payload := gopacket.Payload(diameterData)

	err := gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet
	ci := gopacket.CaptureInfo{
		Timestamp:     timestamp,
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	return w.WritePacket(ci, packetBuf.Bytes())
}

// writeDiameterPairToPcap writes a request-response pair to a single pcap file
func writeDiameterPairToPcap(filename string, requestData, responseData []byte, clientIP, serverIP net.IP) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	baseTime := time.Now()
	clientPort := 54321
	serverPort := 3868

	// Write request packet (client -> server)
	err = writePacketToPcap(w, requestData, clientIP, serverIP, clientPort, serverPort, 1000, 1, baseTime)
	if err != nil {
		return err
	}

	// Write response packet (server -> client) with small delay
	responseTime := baseTime.Add(10 * time.Millisecond)
	err = writePacketToPcap(w, responseData, serverIP, clientIP, serverPort, clientPort, 1, 1000+uint32(len(requestData)), responseTime)
	if err != nil {
		return err
	}

	return nil
}

// createCapabilitiesExchangeRequestForTest creates a CapabilitiesExchangeRequest message with ALL fields populated for testing
func createCapabilitiesExchangeRequestForTest() *CapabilitiesExchangeRequest {
	msg := NewCapabilitiesExchangeRequest()

	// Required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Optional fields (for complete PCAP examples)
	msg.OriginStateId = ptrUnsigned32(1)
	msg.SupportedVendorId = []models_base.Unsigned32{models_base.Unsigned32(10415)} // 3GPP
	msg.AuthApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	msg.InbandSecurityId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	msg.AcctApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	msg.VendorSpecificApplicationId = []*VendorSpecificApplicationId{
		&VendorSpecificApplicationId{
			VendorId:          ptrUnsigned32(10415),
			AuthApplicationId: ptrUnsigned32(16777252),
			AcctApplicationId: ptrUnsigned32(1),
		},
	}
	msg.FirmwareRevision = ptrUnsigned32(1)
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createCapabilitiesExchangeAnswerForTest creates a CapabilitiesExchangeAnswer message with ALL fields populated for testing
func createCapabilitiesExchangeAnswerForTest() *CapabilitiesExchangeAnswer {
	msg := NewCapabilitiesExchangeAnswer()

	// Required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	msg.VendorId = models_base.Unsigned32(10415) // 3GPP
	msg.ProductName = models_base.UTF8String("TestProduct/1.0")

	// Optional fields (for complete PCAP examples)
	msg.OriginStateId = ptrUnsigned32(1)
	msg.ErrorMessage = ptrUTF8String("test")
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	msg.SupportedVendorId = []models_base.Unsigned32{models_base.Unsigned32(10415)} // 3GPP
	msg.AuthApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	msg.InbandSecurityId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	msg.AcctApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	msg.VendorSpecificApplicationId = []*VendorSpecificApplicationId{
		&VendorSpecificApplicationId{
			VendorId:          ptrUnsigned32(10415),
			AuthApplicationId: ptrUnsigned32(16777252),
			AcctApplicationId: ptrUnsigned32(1),
		},
	}
	msg.FirmwareRevision = ptrUnsigned32(1)
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createDeviceWatchdogRequestForTest creates a DeviceWatchdogRequest message with ALL fields populated for testing
func createDeviceWatchdogRequestForTest() *DeviceWatchdogRequest {
	msg := NewDeviceWatchdogRequest()

	// Required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")

	// Optional fields (for complete PCAP examples)
	msg.OriginStateId = ptrUnsigned32(1)
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createDeviceWatchdogAnswerForTest creates a DeviceWatchdogAnswer message with ALL fields populated for testing
func createDeviceWatchdogAnswerForTest() *DeviceWatchdogAnswer {
	msg := NewDeviceWatchdogAnswer()

	// Required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Optional fields (for complete PCAP examples)
	msg.ErrorMessage = ptrUTF8String("test")
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	msg.OriginStateId = ptrUnsigned32(1)
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createDisconnectPeerRequestForTest creates a DisconnectPeerRequest message with ALL fields populated for testing
func createDisconnectPeerRequestForTest() *DisconnectPeerRequest {
	msg := NewDisconnectPeerRequest()

	// Required fields
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DisconnectCause = models_base.Enumerated(1)

	// Optional fields (for complete PCAP examples)
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createDisconnectPeerAnswerForTest creates a DisconnectPeerAnswer message with ALL fields populated for testing
func createDisconnectPeerAnswerForTest() *DisconnectPeerAnswer {
	msg := NewDisconnectPeerAnswer()

	// Required fields
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Optional fields (for complete PCAP examples)
	msg.ErrorMessage = ptrUTF8String("test")
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createReAuthRequestForTest creates a ReAuthRequest message with ALL fields populated for testing
func createReAuthRequestForTest() *ReAuthRequest {
	msg := NewReAuthRequest()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.ReAuthRequestType = models_base.Enumerated(1)

	// Optional fields (for complete PCAP examples)
	msg.UserName = ptrUTF8String("test")
	msg.OriginStateId = ptrUnsigned32(1)
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createReAuthAnswerForTest creates a ReAuthAnswer message with ALL fields populated for testing
func createReAuthAnswerForTest() *ReAuthAnswer {
	msg := NewReAuthAnswer()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Optional fields (for complete PCAP examples)
	msg.UserName = ptrUTF8String("test")
	msg.OriginStateId = ptrUnsigned32(1)
	msg.ErrorMessage = ptrUTF8String("test")
	msg.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	// msg.RedirectHost needs to be set manually (type: DiameterURI)
	msg.RedirectHostUsage = ptrEnumerated(1)
	msg.RedirectMaxCacheTime = ptrUnsigned32(1)
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createSessionTerminationRequestForTest creates a SessionTerminationRequest message with ALL fields populated for testing
func createSessionTerminationRequestForTest() *SessionTerminationRequest {
	msg := NewSessionTerminationRequest()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)
	msg.TerminationCause = models_base.Enumerated(1)

	// Optional fields (for complete PCAP examples)
	msg.UserName = ptrUTF8String("test")
	msg.DestinationHost = ptrDiameterIdentity("server.example.com")
	msg.Class = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}
	msg.OriginStateId = ptrUnsigned32(1)
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createSessionTerminationAnswerForTest creates a SessionTerminationAnswer message with ALL fields populated for testing
func createSessionTerminationAnswerForTest() *SessionTerminationAnswer {
	msg := NewSessionTerminationAnswer()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Optional fields (for complete PCAP examples)
	msg.UserName = ptrUTF8String("test")
	msg.Class = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}
	msg.ErrorMessage = ptrUTF8String("test")
	msg.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	msg.OriginStateId = ptrUnsigned32(1)
	// msg.RedirectHost needs to be set manually (type: DiameterURI)
	msg.RedirectHostUsage = ptrEnumerated(1)
	msg.RedirectMaxCacheTime = ptrUnsigned32(1)
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createAbortSessionRequestForTest creates a AbortSessionRequest message with ALL fields populated for testing
func createAbortSessionRequestForTest() *AbortSessionRequest {
	msg := NewAbortSessionRequest()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.DestinationHost = models_base.DiameterIdentity("server.example.com")
	msg.AuthApplicationId = models_base.Unsigned32(1)

	// Optional fields (for complete PCAP examples)
	msg.UserName = ptrUTF8String("test")
	msg.OriginStateId = ptrUnsigned32(1)
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createAbortSessionAnswerForTest creates a AbortSessionAnswer message with ALL fields populated for testing
func createAbortSessionAnswerForTest() *AbortSessionAnswer {
	msg := NewAbortSessionAnswer()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Optional fields (for complete PCAP examples)
	msg.UserName = ptrUTF8String("test")
	msg.OriginStateId = ptrUnsigned32(1)
	msg.ErrorMessage = ptrUTF8String("test")
	msg.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	// msg.RedirectHost needs to be set manually (type: DiameterURI)
	msg.RedirectHostUsage = ptrEnumerated(1)
	msg.RedirectMaxCacheTime = ptrUnsigned32(1)
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createAccountingRequestForTest creates a AccountingRequest message with ALL fields populated for testing
func createAccountingRequestForTest() *AccountingRequest {
	msg := NewAccountingRequest()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	// Optional fields (for complete PCAP examples)
	msg.AcctApplicationId = ptrUnsigned32(1)
	msg.VendorSpecificApplicationId = &VendorSpecificApplicationId{
		VendorId:          ptrUnsigned32(10415),
		AuthApplicationId: ptrUnsigned32(16777252),
		AcctApplicationId: ptrUnsigned32(1),
	}
	msg.UserName = ptrUTF8String("test")
	msg.DestinationHost = ptrDiameterIdentity("server.example.com")
	msg.AccountingSubSessionId = ptrUnsigned64(1)
	msg.AcctSessionId = ptrOctetString([]byte{0x01, 0x02, 0x03})
	msg.AcctMultiSessionId = ptrUTF8String("client.example.com;1234567890;1")
	msg.AcctInterimInterval = ptrUnsigned32(1)
	msg.AccountingRealtimeRequired = ptrEnumerated(1)
	msg.OriginStateId = ptrUnsigned32(1)
	msg.EventTimestamp = ptrTime(models_base.Time(time.Now()))
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// createAccountingAnswerForTest creates a AccountingAnswer message with ALL fields populated for testing
func createAccountingAnswerForTest() *AccountingAnswer {
	msg := NewAccountingAnswer()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")
	msg.AccountingRecordType = models_base.Enumerated(1)
	msg.AccountingRecordNumber = models_base.Unsigned32(1)

	// Optional fields (for complete PCAP examples)
	msg.AcctApplicationId = ptrUnsigned32(1)
	msg.VendorSpecificApplicationId = &VendorSpecificApplicationId{
		VendorId:          ptrUnsigned32(10415),
		AuthApplicationId: ptrUnsigned32(16777252),
		AcctApplicationId: ptrUnsigned32(1),
	}
	msg.UserName = ptrUTF8String("test")
	msg.AcctInterimInterval = ptrUnsigned32(1)
	msg.AccountingRealtimeRequired = ptrEnumerated(1)
	msg.OriginStateId = ptrUnsigned32(1)
	msg.EventTimestamp = ptrTime(models_base.Time(time.Now()))
	msg.ErrorMessage = ptrUTF8String("test")
	msg.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	return msg
}

// TestCapabilitiesExchangeRequest_PCAP tests PCAP file generation for Request message
func TestCapabilitiesExchangeRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_cer.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createCapabilitiesExchangeRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestCapabilitiesExchangeAnswer_PCAP tests PCAP file generation for Answer message
func TestCapabilitiesExchangeAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_cea.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createCapabilitiesExchangeAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestDeviceWatchdogRequest_PCAP tests PCAP file generation for Request message
func TestDeviceWatchdogRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dwr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createDeviceWatchdogRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestDeviceWatchdogAnswer_PCAP tests PCAP file generation for Answer message
func TestDeviceWatchdogAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dwa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createDeviceWatchdogAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestDisconnectPeerRequest_PCAP tests PCAP file generation for Request message
func TestDisconnectPeerRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dpr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createDisconnectPeerRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestDisconnectPeerAnswer_PCAP tests PCAP file generation for Answer message
func TestDisconnectPeerAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dpa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createDisconnectPeerAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestReAuthRequest_PCAP tests PCAP file generation for Request message
func TestReAuthRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_rar.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createReAuthRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestReAuthAnswer_PCAP tests PCAP file generation for Answer message
func TestReAuthAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_raa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createReAuthAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestSessionTerminationRequest_PCAP tests PCAP file generation for Request message
func TestSessionTerminationRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_str.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createSessionTerminationRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestSessionTerminationAnswer_PCAP tests PCAP file generation for Answer message
func TestSessionTerminationAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_sta.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createSessionTerminationAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestAbortSessionRequest_PCAP tests PCAP file generation for Request message
func TestAbortSessionRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_asr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createAbortSessionRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestAbortSessionAnswer_PCAP tests PCAP file generation for Answer message
func TestAbortSessionAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_asa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createAbortSessionAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestAccountingRequest_PCAP tests PCAP file generation for Request message
func TestAccountingRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ar.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createAccountingRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestAccountingAnswer_PCAP tests PCAP file generation for Answer message
func TestAccountingAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_aa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createAccountingAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestA_Pair_PCAP tests PCAP file generation for A request-response pair
func TestA_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_a_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createAccountingRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createAccountingAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestCE_Pair_PCAP tests PCAP file generation for CE request-response pair
func TestCE_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ce_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createCapabilitiesExchangeRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createCapabilitiesExchangeAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestDW_Pair_PCAP tests PCAP file generation for DW request-response pair
func TestDW_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dw_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createDeviceWatchdogRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createDeviceWatchdogAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestDP_Pair_PCAP tests PCAP file generation for DP request-response pair
func TestDP_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dp_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createDisconnectPeerRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createDisconnectPeerAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestRA_Pair_PCAP tests PCAP file generation for RA request-response pair
func TestRA_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ra_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createReAuthRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createReAuthAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestST_Pair_PCAP tests PCAP file generation for ST request-response pair
func TestST_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_st_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createSessionTerminationRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createSessionTerminationAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestAS_Pair_PCAP tests PCAP file generation for AS request-response pair
func TestAS_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_as_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createAbortSessionRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createAbortSessionAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}
