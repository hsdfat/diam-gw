// Code generated by diameter-codegen. DO NOT EDIT.

package base

import (
	"net"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcapgo"
	"github.com/hsdfat8/diam-gw/models_base"
)

// writeDiameterToPcap writes a Diameter message to a pcap file with proper network layers
func writeDiameterToPcap(filename string, diameterData []byte, srcIP, dstIP net.IP, port int) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	// Create packet layers
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(port),
		DstPort: layers.TCPPort(3868), // Diameter default port
		Seq:     1000,
		Ack:     0,
		SYN:     false,
		ACK:     true,
		PSH:     true,
		Window:  65535,
	}

	// Set TCP options for better compatibility
	tcp.Options = []layers.TCPOption{
		{
			OptionType:   layers.TCPOptionKindMSS,
			OptionLength: 4,
			OptionData:   []byte{0x05, 0xb4}, // MSS = 1460
		},
		{
			OptionType: layers.TCPOptionKindNop,
		},
		{
			OptionType:   layers.TCPOptionKindWindowScale,
			OptionLength: 3,
			OptionData:   []byte{0x07}, // Window scale = 7
		},
	}

	// Calculate TCP checksum
	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize the packet
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	// Create payload (Diameter data)
	payload := gopacket.Payload(diameterData)

	// Serialize all layers
	err = gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet to pcap file
	ci := gopacket.CaptureInfo{
		Timestamp:     time.Now(),
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	err = w.WritePacket(ci, packetBuf.Bytes())
	if err != nil {
		return err
	}

	return nil
}

// writePacketToPcap writes a single packet to an existing pcap writer
func writePacketToPcap(w *pcapgo.Writer, diameterData []byte, srcIP, dstIP net.IP, srcPort, dstPort int, seq, ack uint32, timestamp time.Time) error {
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(dstPort),
		Seq:     seq,
		Ack:     ack,
		SYN:     ack == 0 && seq == 1000, // Only for SYN packet
		ACK:     ack > 0,                 // ACK if we have acknowledgment number
		PSH:     true,                    // Push flag for data packets
		Window:  65535,
	}

	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	payload := gopacket.Payload(diameterData)

	err := gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet
	ci := gopacket.CaptureInfo{
		Timestamp:     timestamp,
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	return w.WritePacket(ci, packetBuf.Bytes())
}

// writeDiameterPairToPcap writes a request-response pair to a single pcap file
func writeDiameterPairToPcap(filename string, requestData, responseData []byte, clientIP, serverIP net.IP) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	baseTime := time.Now()
	clientPort := 54321
	serverPort := 3868

	// Write request packet (client -> server)
	err = writePacketToPcap(w, requestData, clientIP, serverIP, clientPort, serverPort, 1000, 1, baseTime)
	if err != nil {
		return err
	}

	// Write response packet (server -> client) with small delay
	responseTime := baseTime.Add(10 * time.Millisecond)
	err = writePacketToPcap(w, responseData, serverIP, clientIP, serverPort, clientPort, 1, 1000+uint32(len(requestData)), responseTime)
	if err != nil {
		return err
	}

	return nil
}

// TestDP_Pair_PCAP tests PCAP file generation for DP request-response pair
func TestDP_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dpr_dpa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewDisconnectPeerRequest()
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DisconnectCause = models_base.Enumerated(1)
	request.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewDisconnectPeerAnswer()
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.ErrorMessage = ptrUTF8String("452040000000010")
	answer.FailedAvp = &FailedAVP{
		AVP: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	answer.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestRA_Pair_PCAP tests PCAP file generation for RA request-response pair
func TestRA_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_rar_raa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewReAuthRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.DestinationHost = models_base.DiameterIdentity("server.example.com")
	request.AuthApplicationId = models_base.Unsigned32(1)
	request.ReAuthRequestType = models_base.Enumerated(1)
	request.UserName = ptrUTF8String("452040000000010")
	request.OriginStateId = ptrUnsigned32(1)
	request.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	request.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	request.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewReAuthAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.UserName = ptrUTF8String("452040000000010")
	answer.OriginStateId = ptrUnsigned32(1)
	answer.ErrorMessage = ptrUTF8String("452040000000010")
	answer.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	answer.FailedAvp = &FailedAVP{
		AVP: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	// answer.RedirectHost needs to be set manually (type: DiameterURI)
	answer.RedirectHostUsage = ptrEnumerated(1)
	answer.RedirectMaxCacheTime = ptrUnsigned32(1)
	answer.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	answer.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestST_Pair_PCAP tests PCAP file generation for ST request-response pair
func TestST_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_str_sta.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewSessionTerminationRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.AuthApplicationId = models_base.Unsigned32(1)
	request.TerminationCause = models_base.Enumerated(1)
	request.UserName = ptrUTF8String("452040000000010")
	request.DestinationHost = ptrDiameterIdentity("server.example.com")
	request.Class = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}
	request.OriginStateId = ptrUnsigned32(1)
	request.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	request.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	request.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewSessionTerminationAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.UserName = ptrUTF8String("452040000000010")
	answer.Class = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}
	answer.ErrorMessage = ptrUTF8String("452040000000010")
	answer.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	answer.FailedAvp = &FailedAVP{
		AVP: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	answer.OriginStateId = ptrUnsigned32(1)
	// answer.RedirectHost needs to be set manually (type: DiameterURI)
	answer.RedirectHostUsage = ptrEnumerated(1)
	answer.RedirectMaxCacheTime = ptrUnsigned32(1)
	answer.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	answer.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestAS_Pair_PCAP tests PCAP file generation for AS request-response pair
func TestAS_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_asr_asa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewAbortSessionRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.DestinationHost = models_base.DiameterIdentity("server.example.com")
	request.AuthApplicationId = models_base.Unsigned32(1)
	request.UserName = ptrUTF8String("452040000000010")
	request.OriginStateId = ptrUnsigned32(1)
	request.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	request.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	request.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewAbortSessionAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.UserName = ptrUTF8String("452040000000010")
	answer.OriginStateId = ptrUnsigned32(1)
	answer.ErrorMessage = ptrUTF8String("452040000000010")
	answer.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	answer.FailedAvp = &FailedAVP{
		AVP: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	// answer.RedirectHost needs to be set manually (type: DiameterURI)
	answer.RedirectHostUsage = ptrEnumerated(1)
	answer.RedirectMaxCacheTime = ptrUnsigned32(1)
	answer.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	answer.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestA_Pair_PCAP tests PCAP file generation for A request-response pair
func TestA_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ar_aa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewAccountingRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.AccountingRecordType = models_base.Enumerated(1)
	request.AccountingRecordNumber = models_base.Unsigned32(1)
	request.AcctApplicationId = ptrUnsigned32(1)
	request.VendorSpecificApplicationId = &VendorSpecificApplicationId{
		VendorId:          ptrUnsigned32(10415),
		AuthApplicationId: ptrUnsigned32(16777252),
		AcctApplicationId: ptrUnsigned32(1),
	}
	request.UserName = ptrUTF8String("452040000000010")
	request.DestinationHost = ptrDiameterIdentity("server.example.com")
	request.AccountingSubSessionId = ptrUnsigned64(1)
	request.AcctSessionId = ptrOctetString([]byte{0x01, 0x02, 0x03})
	request.AcctMultiSessionId = ptrUTF8String("client.example.com;1234567890;1")
	request.AcctInterimInterval = ptrUnsigned32(1)
	request.AccountingRealtimeRequired = ptrEnumerated(1)
	request.OriginStateId = ptrUnsigned32(1)
	request.EventTimestamp = ptrTime(models_base.Time(time.Now()))
	request.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	request.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}
	request.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewAccountingAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.AccountingRecordType = models_base.Enumerated(1)
	answer.AccountingRecordNumber = models_base.Unsigned32(1)
	answer.AcctApplicationId = ptrUnsigned32(1)
	answer.VendorSpecificApplicationId = &VendorSpecificApplicationId{
		VendorId:          ptrUnsigned32(10415),
		AuthApplicationId: ptrUnsigned32(16777252),
		AcctApplicationId: ptrUnsigned32(1),
	}
	answer.UserName = ptrUTF8String("452040000000010")
	answer.AcctInterimInterval = ptrUnsigned32(1)
	answer.AccountingRealtimeRequired = ptrEnumerated(1)
	answer.OriginStateId = ptrUnsigned32(1)
	answer.EventTimestamp = ptrTime(models_base.Time(time.Now()))
	answer.ErrorMessage = ptrUTF8String("452040000000010")
	answer.ErrorReportingHost = ptrDiameterIdentity("server.example.com")
	answer.FailedAvp = &FailedAVP{
		AVP: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	answer.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	answer.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestCE_Pair_PCAP tests PCAP file generation for CE request-response pair
func TestCE_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_cer_cea.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewCapabilitiesExchangeRequest()
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	request.VendorId = models_base.Unsigned32(10415) // 3GPP
	request.ProductName = models_base.UTF8String("TestProduct/1.0")
	request.OriginStateId = ptrUnsigned32(1)
	request.SupportedVendorId = []models_base.Unsigned32{models_base.Unsigned32(10415)} // 3GPP
	request.AuthApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	request.InbandSecurityId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	request.AcctApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	request.VendorSpecificApplicationId = []*VendorSpecificApplicationId{
		&VendorSpecificApplicationId{
			VendorId:          ptrUnsigned32(10415),
			AuthApplicationId: ptrUnsigned32(16777252),
			AcctApplicationId: ptrUnsigned32(1),
		},
	}
	request.FirmwareRevision = ptrUnsigned32(1)
	request.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewCapabilitiesExchangeAnswer()
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.HostIpAddress = []models_base.Address{
		models_base.Address(net.ParseIP("192.168.1.100")),
	}
	answer.VendorId = models_base.Unsigned32(10415) // 3GPP
	answer.ProductName = models_base.UTF8String("TestProduct/1.0")
	answer.OriginStateId = ptrUnsigned32(1)
	answer.ErrorMessage = ptrUTF8String("452040000000010")
	answer.FailedAvp = &FailedAVP{
		AVP: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	answer.SupportedVendorId = []models_base.Unsigned32{models_base.Unsigned32(10415)} // 3GPP
	answer.AuthApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	answer.InbandSecurityId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	answer.AcctApplicationId = []models_base.Unsigned32{models_base.Unsigned32(1)}
	answer.VendorSpecificApplicationId = []*VendorSpecificApplicationId{
		&VendorSpecificApplicationId{
			VendorId:          ptrUnsigned32(10415),
			AuthApplicationId: ptrUnsigned32(16777252),
			AcctApplicationId: ptrUnsigned32(1),
		},
	}
	answer.FirmwareRevision = ptrUnsigned32(1)
	answer.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}

// TestDW_Pair_PCAP tests PCAP file generation for DW request-response pair
func TestDW_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_dwr_dwa.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewDeviceWatchdogRequest()
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.OriginStateId = ptrUnsigned32(1)
	request.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewDeviceWatchdogAnswer()
	answer.ResultCode = models_base.Unsigned32(2001) // DIAMETER_SUCCESS
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")
	answer.ErrorMessage = ptrUTF8String("452040000000010")
	answer.FailedAvp = &FailedAVP{
		AVP: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	answer.OriginStateId = ptrUnsigned32(1)
	answer.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}
