// Code generated by diameter-codegen. DO NOT EDIT.

package base

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/hsdfat8/diam-gw/models_base"
)

// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

// Grouped AVP structures

// ExperimentalResult represents the Experimental-Result grouped AVP (AVP Code 297)
type ExperimentalResult struct {
	VendorId               models_base.Unsigned32 // Required
	ExperimentalResultCode models_base.Unsigned32 // Required
}

// Marshal serializes ExperimentalResult to bytes
func (g *ExperimentalResult) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VendorId (required)
	buf.Write(marshalAVP(266, g.VendorId, true, false))

	// Marshal ExperimentalResultCode (required)
	buf.Write(marshalAVP(298, g.ExperimentalResultCode, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into ExperimentalResult
func (g *ExperimentalResult) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.VendorId = val.(models_base.Unsigned32)
			}
		case 298: // Experimental-Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ExperimentalResultCode = val.(models_base.Unsigned32)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// ProxyInfo represents the Proxy-Info grouped AVP (AVP Code 284)
type ProxyInfo struct {
	ProxyHost  models_base.DiameterIdentity // Required
	ProxyState models_base.OctetString      // Required
}

// Marshal serializes ProxyInfo to bytes
func (g *ProxyInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ProxyHost (required)
	buf.Write(marshalAVP(280, g.ProxyHost, true, false))

	// Marshal ProxyState (required)
	buf.Write(marshalAVP(33, g.ProxyState, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into ProxyInfo
func (g *ProxyInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 280: // Proxy-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.ProxyHost = val.(models_base.DiameterIdentity)
			}
		case 33: // Proxy-State
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.ProxyState = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// SubscriptionData represents the Subscription-Data grouped AVP (AVP Code 1400)
type SubscriptionData struct {
	SubscriberStatus                     *models_base.Enumerated   // Optional
	Msisdn                               *models_base.OctetString  // Optional
	AMsisdn                              *models_base.OctetString  // Optional
	StnSr                                *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	IcsIndicator                         *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	NetworkAccessMode                    *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	OperatorDeterminedBarring            *models_base.Unsigned32   // Optional
	HplmnOdb                             *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	RegionalSubscriptionZoneCode         []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	AccessRestrictionData                *models_base.Unsigned32   // Optional
	ApnOiReplacement                     *models_base.UTF8String   // Optional
	LcsInfo                              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	TeleserviceList                      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	CallBarringInfo                      []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ChargingCharacteristics              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	Ambr                                 *AMBR                     // Optional
	ApnConfigurationProfile              *APNConfigurationProfile  // Optional
	RatFrequencySelectionPriorityId      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	TraceData                            *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	GprsSubscriptionData                 *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	CsgSubscriptionData                  []*CSGSubscriptionData    // Optional
	RoamingRestricted                    *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SubscribedPeriodicRauTauTimer        *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	MpsPriority                          *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	VplmnLipaAllowed                     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	RelayNodeIndicator                   *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	MdtUserConsent                       *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SubscribedVsrvcc                     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ProseSubscriptionData                *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SubscriptionDataFlags                *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	AdjacentAccessRestrictionData        []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	DlBufferingSuggestedPacketCount      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ImsiGroupId                          []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	UeUsageType                          *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	AeseCommunicationPattern             []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	MonitoringEventConfiguration         []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	EmergencyInfo                        *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	V2xSubscriptionData                  *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	EdrxCycleLength                      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ExternalIdentifier                   *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ActiveTime                           *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ServiceGapTime                       *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	BroadcastLocationAssistanceDataTypes *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	AerialUeSubscriptionInformation      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	CoreNetworkRestrictions              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes SubscriptionData to bytes
func (g *SubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal SubscriberStatus (optional)
	if g.SubscriberStatus != nil {
		buf.Write(marshalAVPWithVendor(1424, *g.SubscriberStatus, true, false, 10415))
	}

	// Marshal Msisdn (optional)
	if g.Msisdn != nil {
		buf.Write(marshalAVPWithVendor(701, *g.Msisdn, true, false, 10415))
	}

	// Marshal AMsisdn (optional)
	if g.AMsisdn != nil {
		buf.Write(marshalAVPWithVendor(1643, *g.AMsisdn, true, false, 10415))
	}

	// Marshal StnSr (optional)
	if g.StnSr != nil {
		buf.Write(marshalAVP(0, *g.StnSr, false, false))
	}

	// Marshal IcsIndicator (optional)
	if g.IcsIndicator != nil {
		buf.Write(marshalAVP(0, *g.IcsIndicator, false, false))
	}

	// Marshal NetworkAccessMode (optional)
	if g.NetworkAccessMode != nil {
		buf.Write(marshalAVP(0, *g.NetworkAccessMode, false, false))
	}

	// Marshal OperatorDeterminedBarring (optional)
	if g.OperatorDeterminedBarring != nil {
		buf.Write(marshalAVPWithVendor(1425, *g.OperatorDeterminedBarring, true, false, 10415))
	}

	// Marshal HplmnOdb (optional)
	if g.HplmnOdb != nil {
		buf.Write(marshalAVP(0, *g.HplmnOdb, false, false))
	}

	// Marshal RegionalSubscriptionZoneCode (repeated)
	for _, v := range g.RegionalSubscriptionZoneCode {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal AccessRestrictionData (optional)
	if g.AccessRestrictionData != nil {
		buf.Write(marshalAVPWithVendor(1426, *g.AccessRestrictionData, true, false, 10415))
	}

	// Marshal ApnOiReplacement (optional)
	if g.ApnOiReplacement != nil {
		buf.Write(marshalAVPWithVendor(1427, *g.ApnOiReplacement, true, false, 10415))
	}

	// Marshal LcsInfo (optional)
	if g.LcsInfo != nil {
		buf.Write(marshalAVP(0, *g.LcsInfo, false, false))
	}

	// Marshal TeleserviceList (optional)
	if g.TeleserviceList != nil {
		buf.Write(marshalAVP(0, *g.TeleserviceList, false, false))
	}

	// Marshal CallBarringInfo (repeated)
	for _, v := range g.CallBarringInfo {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal ChargingCharacteristics (optional)
	if g.ChargingCharacteristics != nil {
		buf.Write(marshalAVP(0, *g.ChargingCharacteristics, false, false))
	}

	// Marshal Ambr (grouped)
	if g.Ambr != nil {
		if groupedData, err := g.Ambr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1435, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal ApnConfigurationProfile (grouped)
	if g.ApnConfigurationProfile != nil {
		if groupedData, err := g.ApnConfigurationProfile.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1429, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal RatFrequencySelectionPriorityId (optional)
	if g.RatFrequencySelectionPriorityId != nil {
		buf.Write(marshalAVP(0, *g.RatFrequencySelectionPriorityId, false, false))
	}

	// Marshal TraceData (optional)
	if g.TraceData != nil {
		buf.Write(marshalAVP(0, *g.TraceData, false, false))
	}

	// Marshal GprsSubscriptionData (optional)
	if g.GprsSubscriptionData != nil {
		buf.Write(marshalAVP(0, *g.GprsSubscriptionData, false, false))
	}

	// Marshal CsgSubscriptionData (repeated, grouped)
	for _, v := range g.CsgSubscriptionData {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1436, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal RoamingRestricted (optional)
	if g.RoamingRestricted != nil {
		buf.Write(marshalAVP(0, *g.RoamingRestricted, false, false))
	}

	// Marshal SubscribedPeriodicRauTauTimer (optional)
	if g.SubscribedPeriodicRauTauTimer != nil {
		buf.Write(marshalAVP(0, *g.SubscribedPeriodicRauTauTimer, false, false))
	}

	// Marshal MpsPriority (optional)
	if g.MpsPriority != nil {
		buf.Write(marshalAVP(0, *g.MpsPriority, false, false))
	}

	// Marshal VplmnLipaAllowed (optional)
	if g.VplmnLipaAllowed != nil {
		buf.Write(marshalAVP(0, *g.VplmnLipaAllowed, false, false))
	}

	// Marshal RelayNodeIndicator (optional)
	if g.RelayNodeIndicator != nil {
		buf.Write(marshalAVP(0, *g.RelayNodeIndicator, false, false))
	}

	// Marshal MdtUserConsent (optional)
	if g.MdtUserConsent != nil {
		buf.Write(marshalAVP(0, *g.MdtUserConsent, false, false))
	}

	// Marshal SubscribedVsrvcc (optional)
	if g.SubscribedVsrvcc != nil {
		buf.Write(marshalAVP(0, *g.SubscribedVsrvcc, false, false))
	}

	// Marshal ProseSubscriptionData (optional)
	if g.ProseSubscriptionData != nil {
		buf.Write(marshalAVP(0, *g.ProseSubscriptionData, false, false))
	}

	// Marshal SubscriptionDataFlags (optional)
	if g.SubscriptionDataFlags != nil {
		buf.Write(marshalAVP(0, *g.SubscriptionDataFlags, false, false))
	}

	// Marshal AdjacentAccessRestrictionData (repeated)
	for _, v := range g.AdjacentAccessRestrictionData {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal DlBufferingSuggestedPacketCount (optional)
	if g.DlBufferingSuggestedPacketCount != nil {
		buf.Write(marshalAVP(0, *g.DlBufferingSuggestedPacketCount, false, false))
	}

	// Marshal ImsiGroupId (repeated)
	for _, v := range g.ImsiGroupId {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal UeUsageType (optional)
	if g.UeUsageType != nil {
		buf.Write(marshalAVP(0, *g.UeUsageType, false, false))
	}

	// Marshal AeseCommunicationPattern (repeated)
	for _, v := range g.AeseCommunicationPattern {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal MonitoringEventConfiguration (repeated)
	for _, v := range g.MonitoringEventConfiguration {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal EmergencyInfo (optional)
	if g.EmergencyInfo != nil {
		buf.Write(marshalAVP(0, *g.EmergencyInfo, false, false))
	}

	// Marshal V2xSubscriptionData (optional)
	if g.V2xSubscriptionData != nil {
		buf.Write(marshalAVP(0, *g.V2xSubscriptionData, false, false))
	}

	// Marshal EdrxCycleLength (optional)
	if g.EdrxCycleLength != nil {
		buf.Write(marshalAVP(0, *g.EdrxCycleLength, false, false))
	}

	// Marshal ExternalIdentifier (optional)
	if g.ExternalIdentifier != nil {
		buf.Write(marshalAVP(0, *g.ExternalIdentifier, false, false))
	}

	// Marshal ActiveTime (optional)
	if g.ActiveTime != nil {
		buf.Write(marshalAVP(0, *g.ActiveTime, false, false))
	}

	// Marshal ServiceGapTime (optional)
	if g.ServiceGapTime != nil {
		buf.Write(marshalAVP(0, *g.ServiceGapTime, false, false))
	}

	// Marshal BroadcastLocationAssistanceDataTypes (optional)
	if g.BroadcastLocationAssistanceDataTypes != nil {
		buf.Write(marshalAVP(0, *g.BroadcastLocationAssistanceDataTypes, false, false))
	}

	// Marshal AerialUeSubscriptionInformation (optional)
	if g.AerialUeSubscriptionInformation != nil {
		buf.Write(marshalAVP(0, *g.AerialUeSubscriptionInformation, false, false))
	}

	// Marshal CoreNetworkRestrictions (optional)
	if g.CoreNetworkRestrictions != nil {
		buf.Write(marshalAVP(0, *g.CoreNetworkRestrictions, false, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into SubscriptionData
func (g *SubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1424: // Subscriber-Status
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.SubscriberStatus = &v
			}
		case 701: // MSISDN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Msisdn = &v
			}
		case 1643: // A-MSISDN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.AMsisdn = &v
			}
		// case 0: // STN-SR (AVP code not defined)
		// case 0: // ICS-Indicator (AVP code not defined)
		// case 0: // Network-Access-Mode (AVP code not defined)
		case 1425: // Operator-Determined-Barring
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.OperatorDeterminedBarring = &v
			}
		// case 0: // HPLMN-ODB (AVP code not defined)
		// case 0: // Regional-Subscription-Zone-Code (AVP code not defined)
		case 1426: // Access-Restriction-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AccessRestrictionData = &v
			}
		case 1427: // APN-OI-Replacement
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.ApnOiReplacement = &v
			}
		// case 0: // LCS-Info (AVP code not defined)
		// case 0: // Teleservice-List (AVP code not defined)
		// case 0: // Call-Barring-Info (AVP code not defined)
		// case 0: // 3GPP-Charging-Characteristics (AVP code not defined)
		case 1435: // AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AMBR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Ambr = grouped
			}
		case 1429: // APN-Configuration-Profile
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &APNConfigurationProfile{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ApnConfigurationProfile = grouped
			}
		// case 0: // RAT-Frequency-Selection-Priority-ID (AVP code not defined)
		// case 0: // Trace-Data (AVP code not defined)
		// case 0: // GPRS-Subscription-Data (AVP code not defined)
		case 1436: // CSG-Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &CSGSubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.CsgSubscriptionData = append(g.CsgSubscriptionData, grouped)
			}
			// case 0: // Roaming-Restricted-Due-To-Unsupported-Feature (AVP code not defined)
			// case 0: // Subscribed-Periodic-RAU-TAU-Timer (AVP code not defined)
			// case 0: // MPS-Priority (AVP code not defined)
			// case 0: // VPLMN-LIPA-Allowed (AVP code not defined)
			// case 0: // Relay-Node-Indicator (AVP code not defined)
			// case 0: // MDT-User-Consent (AVP code not defined)
			// case 0: // Subscribed-VSRVCC (AVP code not defined)
			// case 0: // ProSe-Subscription-Data (AVP code not defined)
			// case 0: // Subscription-Data-Flags (AVP code not defined)
			// case 0: // Adjacent-Access-Restriction-Data (AVP code not defined)
			// case 0: // DL-Buffering-Suggested-Packet-Count (AVP code not defined)
			// case 0: // IMSI-Group-Id (AVP code not defined)
			// case 0: // UE-Usage-Type (AVP code not defined)
			// case 0: // AESE-Communication-Pattern (AVP code not defined)
			// case 0: // Monitoring-Event-Configuration (AVP code not defined)
			// case 0: // Emergency-Info (AVP code not defined)
			// case 0: // V2X-Subscription-Data (AVP code not defined)
			// case 0: // eDRX-Cycle-Length (AVP code not defined)
			// case 0: // External-Identifier (AVP code not defined)
			// case 0: // Active-Time (AVP code not defined)
			// case 0: // Service-Gap-Time (AVP code not defined)
			// case 0: // Broadcast-Location-Assistance-Data-Types (AVP code not defined)
			// case 0: // Aerial-UE-Subscription-Information (AVP code not defined)
			// case 0: // Core-Network-Restrictions (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AMBR represents the AMBR grouped AVP (AVP Code 1435)
type AMBR struct {
	MaxRequestedBandwidthUl  models_base.OctetString  // Required - WARNING: AVP code not defined, DO NOT USE
	MaxRequestedBandwidthDl  models_base.OctetString  // Required - WARNING: AVP code not defined, DO NOT USE
	ExtendedMaxRequestedBwUl *models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ExtendedMaxRequestedBwDl *models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes AMBR to bytes
func (g *AMBR) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal MaxRequestedBandwidthUl (required)
	buf.Write(marshalAVP(0, g.MaxRequestedBandwidthUl, false, false))

	// Marshal MaxRequestedBandwidthDl (required)
	buf.Write(marshalAVP(0, g.MaxRequestedBandwidthDl, false, false))

	// Marshal ExtendedMaxRequestedBwUl (optional)
	if g.ExtendedMaxRequestedBwUl != nil {
		buf.Write(marshalAVP(0, *g.ExtendedMaxRequestedBwUl, false, false))
	}

	// Marshal ExtendedMaxRequestedBwDl (optional)
	if g.ExtendedMaxRequestedBwDl != nil {
		buf.Write(marshalAVP(0, *g.ExtendedMaxRequestedBwDl, false, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AMBR
func (g *AMBR) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// VendorSpecificApplicationId represents the Vendor-Specific-Application-Id grouped AVP (AVP Code 260)
type VendorSpecificApplicationId struct {
	VendorId          *models_base.Unsigned32 // Optional
	AuthApplicationId *models_base.Unsigned32 // Optional
	AcctApplicationId *models_base.Unsigned32 // Optional
}

// Marshal serializes VendorSpecificApplicationId to bytes
func (g *VendorSpecificApplicationId) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VendorId (optional)
	if g.VendorId != nil {
		buf.Write(marshalAVP(266, *g.VendorId, true, false))
	}

	// Marshal AuthApplicationId (optional)
	if g.AuthApplicationId != nil {
		buf.Write(marshalAVP(258, *g.AuthApplicationId, true, false))
	}

	// Marshal AcctApplicationId (optional)
	if g.AcctApplicationId != nil {
		buf.Write(marshalAVP(259, *g.AcctApplicationId, true, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into VendorSpecificApplicationId
func (g *VendorSpecificApplicationId) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.VendorId = &v
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AuthApplicationId = &v
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AcctApplicationId = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// FailedAVP represents the Failed-AVP grouped AVP (AVP Code 279)
type FailedAVP struct {
	Avp []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes FailedAVP to bytes
func (g *FailedAVP) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal Avp (repeated)
	for _, v := range g.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into FailedAVP
func (g *FailedAVP) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// CSGSubscriptionData represents the CSG-Subscription-Data grouped AVP (AVP Code 1436)
type CSGSubscriptionData struct {
	CsgId            models_base.OctetString  // Required - WARNING: AVP code not defined, DO NOT USE
	ExpirationDate   *models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ServiceSelection []models_base.UTF8String // Optional
	VisitedPlmnId    *models_base.OctetString // Optional
}

// Marshal serializes CSGSubscriptionData to bytes
func (g *CSGSubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal CsgId (required)
	buf.Write(marshalAVP(0, g.CsgId, false, false))

	// Marshal ExpirationDate (optional)
	if g.ExpirationDate != nil {
		buf.Write(marshalAVP(0, *g.ExpirationDate, false, false))
	}

	// Marshal ServiceSelection (repeated)
	for _, v := range g.ServiceSelection {
		buf.Write(marshalAVP(493, v, true, false))
	}

	// Marshal VisitedPlmnId (optional)
	if g.VisitedPlmnId != nil {
		buf.Write(marshalAVPWithVendor(1407, *g.VisitedPlmnId, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into CSGSubscriptionData
func (g *CSGSubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		// case 0: // CSG-Id (AVP code not defined)
		// case 0: // Expiration-Date (AVP code not defined)
		case 493: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				g.ServiceSelection = append(g.ServiceSelection, val.(models_base.UTF8String))
			}
		case 1407: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.VisitedPlmnId = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// GERANVector represents the GERAN-Vector grouped AVP (AVP Code 1416)
type GERANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Sres       models_base.OctetString // Required
	Kc         models_base.OctetString // Required
}

// Marshal serializes GERANVector to bytes
func (g *GERANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(1419, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(1447, g.Rand, true, false, 10415))

	// Marshal Sres (required)
	buf.Write(marshalAVPWithVendor(1454, g.Sres, true, false, 10415))

	// Marshal Kc (required)
	buf.Write(marshalAVPWithVendor(1453, g.Kc, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into GERANVector
func (g *GERANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1419: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case 1447: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case 1454: // SRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Sres = val.(models_base.OctetString)
			}
		case 1453: // Kc
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Kc = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// APNConfiguration represents the APN-Configuration grouped AVP (AVP Code 1430)
type APNConfiguration struct {
	ContextIdentifier           models_base.Unsigned32    // Required
	ServedPartyIpAddress        []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	PdnType                     models_base.OctetString   // Required - WARNING: AVP code not defined, DO NOT USE
	ServiceSelection            models_base.UTF8String    // Required
	EpsSubscribedQosProfile     *EPSSubscribedQoSProfile  // Optional
	VplmnDynamicAddressAllowed  *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	Mip6AgentInfo               *MIP6AgentInfo            // Optional
	VisitedNetworkIdentifier    *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	PdnGwAllocationType         *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ChargingCharacteristics     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	Ambr                        *AMBR                     // Optional
	SpecificApnInfo             []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ApnOiReplacement            *models_base.UTF8String   // Optional
	SiptoPermission             *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	LipaPermission              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	RestorationPriority         *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SiptoLocalNetworkPermission *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	WlanOffloadability          *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	NonIpPdnTypeIndicator       *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	NonIpDataDeliveryMechanism  *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ScefId                      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ScefRealm                   *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	PreferredDataMode           *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	PdnConnectionContinuity     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes APNConfiguration to bytes
func (g *APNConfiguration) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ContextIdentifier (required)
	buf.Write(marshalAVPWithVendor(1423, g.ContextIdentifier, true, false, 10415))

	// Marshal ServedPartyIpAddress (repeated)
	for _, v := range g.ServedPartyIpAddress {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal PdnType (required)
	buf.Write(marshalAVP(0, g.PdnType, false, false))

	// Marshal ServiceSelection (required)
	buf.Write(marshalAVP(493, g.ServiceSelection, true, false))

	// Marshal EpsSubscribedQosProfile (grouped)
	if g.EpsSubscribedQosProfile != nil {
		if groupedData, err := g.EpsSubscribedQosProfile.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1431, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal VplmnDynamicAddressAllowed (optional)
	if g.VplmnDynamicAddressAllowed != nil {
		buf.Write(marshalAVP(0, *g.VplmnDynamicAddressAllowed, false, false))
	}

	// Marshal Mip6AgentInfo (grouped)
	if g.Mip6AgentInfo != nil {
		if groupedData, err := g.Mip6AgentInfo.Marshal(); err == nil {
			buf.Write(marshalAVP(486, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal VisitedNetworkIdentifier (optional)
	if g.VisitedNetworkIdentifier != nil {
		buf.Write(marshalAVP(0, *g.VisitedNetworkIdentifier, false, false))
	}

	// Marshal PdnGwAllocationType (optional)
	if g.PdnGwAllocationType != nil {
		buf.Write(marshalAVP(0, *g.PdnGwAllocationType, false, false))
	}

	// Marshal ChargingCharacteristics (optional)
	if g.ChargingCharacteristics != nil {
		buf.Write(marshalAVP(0, *g.ChargingCharacteristics, false, false))
	}

	// Marshal Ambr (grouped)
	if g.Ambr != nil {
		if groupedData, err := g.Ambr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1435, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal SpecificApnInfo (repeated)
	for _, v := range g.SpecificApnInfo {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal ApnOiReplacement (optional)
	if g.ApnOiReplacement != nil {
		buf.Write(marshalAVPWithVendor(1427, *g.ApnOiReplacement, true, false, 10415))
	}

	// Marshal SiptoPermission (optional)
	if g.SiptoPermission != nil {
		buf.Write(marshalAVP(0, *g.SiptoPermission, false, false))
	}

	// Marshal LipaPermission (optional)
	if g.LipaPermission != nil {
		buf.Write(marshalAVP(0, *g.LipaPermission, false, false))
	}

	// Marshal RestorationPriority (optional)
	if g.RestorationPriority != nil {
		buf.Write(marshalAVP(0, *g.RestorationPriority, false, false))
	}

	// Marshal SiptoLocalNetworkPermission (optional)
	if g.SiptoLocalNetworkPermission != nil {
		buf.Write(marshalAVP(0, *g.SiptoLocalNetworkPermission, false, false))
	}

	// Marshal WlanOffloadability (optional)
	if g.WlanOffloadability != nil {
		buf.Write(marshalAVP(0, *g.WlanOffloadability, false, false))
	}

	// Marshal NonIpPdnTypeIndicator (optional)
	if g.NonIpPdnTypeIndicator != nil {
		buf.Write(marshalAVP(0, *g.NonIpPdnTypeIndicator, false, false))
	}

	// Marshal NonIpDataDeliveryMechanism (optional)
	if g.NonIpDataDeliveryMechanism != nil {
		buf.Write(marshalAVP(0, *g.NonIpDataDeliveryMechanism, false, false))
	}

	// Marshal ScefId (optional)
	if g.ScefId != nil {
		buf.Write(marshalAVP(0, *g.ScefId, false, false))
	}

	// Marshal ScefRealm (optional)
	if g.ScefRealm != nil {
		buf.Write(marshalAVP(0, *g.ScefRealm, false, false))
	}

	// Marshal PreferredDataMode (optional)
	if g.PreferredDataMode != nil {
		buf.Write(marshalAVP(0, *g.PreferredDataMode, false, false))
	}

	// Marshal PdnConnectionContinuity (optional)
	if g.PdnConnectionContinuity != nil {
		buf.Write(marshalAVP(0, *g.PdnConnectionContinuity, false, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into APNConfiguration
func (g *APNConfiguration) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1423: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ContextIdentifier = val.(models_base.Unsigned32)
			}
		// case 0: // Served-Party-IP-Address (AVP code not defined)
		// case 0: // PDN-Type (AVP code not defined)
		case 493: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				g.ServiceSelection = val.(models_base.UTF8String)
			}
		case 1431: // EPS-Subscribed-QoS-Profile
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EPSSubscribedQoSProfile{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EpsSubscribedQosProfile = grouped
			}
		// case 0: // VPLMN-Dynamic-Address-Allowed (AVP code not defined)
		case 486: // MIP6-Agent-Info
			grouped := &MIP6AgentInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Mip6AgentInfo = grouped
			}
		// case 0: // Visited-Network-Identifier (AVP code not defined)
		// case 0: // PDN-GW-Allocation-Type (AVP code not defined)
		// case 0: // 3GPP-Charging-Characteristics (AVP code not defined)
		case 1435: // AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AMBR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Ambr = grouped
			}
		// case 0: // Specific-APN-Info (AVP code not defined)
		case 1427: // APN-OI-Replacement
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.ApnOiReplacement = &v
			}
			// case 0: // SIPTO-Permission (AVP code not defined)
			// case 0: // LIPA-Permission (AVP code not defined)
			// case 0: // Restoration-Priority (AVP code not defined)
			// case 0: // SIPTO-Local-Network-Permission (AVP code not defined)
			// case 0: // WLAN-offloadability (AVP code not defined)
			// case 0: // Non-IP-PDN-Type-Indicator (AVP code not defined)
			// case 0: // Non-IP-Data-Delivery-Mechanism (AVP code not defined)
			// case 0: // SCEF-ID (AVP code not defined)
			// case 0: // SCEF-Realm (AVP code not defined)
			// case 0: // Preferred-Data-Mode (AVP code not defined)
			// case 0: // PDN-Connection-Continuity (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MIPHomeAgentHost represents the MIP-Home-Agent-Host grouped AVP (AVP Code 348)
type MIPHomeAgentHost struct {
	DestinationRealm models_base.DiameterIdentity // Required
	DestinationHost  models_base.DiameterIdentity // Required
}

// Marshal serializes MIPHomeAgentHost to bytes
func (g *MIPHomeAgentHost) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, g.DestinationRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, g.DestinationHost, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into MIPHomeAgentHost
func (g *MIPHomeAgentHost) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.DestinationHost = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// RequestedUTRANGERANAuthenticationInfo represents the Requested-UTRAN-GERAN-Authentication-Info grouped AVP (AVP Code 1409)
type RequestedUTRANGERANAuthenticationInfo struct {
	NumberOfRequestedVectors   *models_base.Unsigned32  // Optional
	ImmediateResponsePreferred *models_base.Unsigned32  // Optional
	ReSynchronizationInfo      *models_base.OctetString // Optional
}

// Marshal serializes RequestedUTRANGERANAuthenticationInfo to bytes
func (g *RequestedUTRANGERANAuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal NumberOfRequestedVectors (optional)
	if g.NumberOfRequestedVectors != nil {
		buf.Write(marshalAVPWithVendor(1410, *g.NumberOfRequestedVectors, true, false, 10415))
	}

	// Marshal ImmediateResponsePreferred (optional)
	if g.ImmediateResponsePreferred != nil {
		buf.Write(marshalAVPWithVendor(1412, *g.ImmediateResponsePreferred, true, false, 10415))
	}

	// Marshal ReSynchronizationInfo (optional)
	if g.ReSynchronizationInfo != nil {
		buf.Write(marshalAVPWithVendor(1411, *g.ReSynchronizationInfo, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into RequestedUTRANGERANAuthenticationInfo
func (g *RequestedUTRANGERANAuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1410: // Number-Of-Requested-Vectors
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.NumberOfRequestedVectors = &v
			}
		case 1412: // Immediate-Response-Preferred
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ImmediateResponsePreferred = &v
			}
		case 1411: // Re-Synchronization-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ReSynchronizationInfo = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AuthenticationInfo represents the Authentication-Info grouped AVP (AVP Code 1413)
type AuthenticationInfo struct {
	EUtranVector []*EUTRANVector // Optional
	UtranVector  []*UTRANVector  // Optional
	GeranVector  []*GERANVector  // Optional
}

// Marshal serializes AuthenticationInfo to bytes
func (g *AuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal EUtranVector (repeated, grouped)
	for _, v := range g.EUtranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1414, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal UtranVector (repeated, grouped)
	for _, v := range g.UtranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1415, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal GeranVector (repeated, grouped)
	for _, v := range g.GeranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1416, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AuthenticationInfo
func (g *AuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1414: // E-UTRAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EUTRANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EUtranVector = append(g.EUtranVector, grouped)
			}
		case 1415: // UTRAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &UTRANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.UtranVector = append(g.UtranVector, grouped)
			}
		case 1416: // GERAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &GERANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.GeranVector = append(g.GeranVector, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// TerminalInformation represents the Terminal-Information grouped AVP (AVP Code 1401)
type TerminalInformation struct {
	Imei            *models_base.UTF8String  // Optional
	Meid            *models_base.OctetString // Optional
	SoftwareVersion *models_base.UTF8String  // Optional
}

// Marshal serializes TerminalInformation to bytes
func (g *TerminalInformation) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal Imei (optional)
	if g.Imei != nil {
		buf.Write(marshalAVPWithVendor(1402, *g.Imei, true, false, 10415))
	}

	// Marshal Meid (optional)
	if g.Meid != nil {
		buf.Write(marshalAVPWithVendor(1471, *g.Meid, true, false, 10415))
	}

	// Marshal SoftwareVersion (optional)
	if g.SoftwareVersion != nil {
		buf.Write(marshalAVPWithVendor(1403, *g.SoftwareVersion, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into TerminalInformation
func (g *TerminalInformation) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1402: // IMEI
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.Imei = &v
			}
		case 1471: // 3GPP2-MEID
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Meid = &v
			}
		case 1403: // Software-Version
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.SoftwareVersion = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EUTRANVector represents the E-UTRAN-Vector grouped AVP (AVP Code 1414)
type EUTRANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Xres       models_base.OctetString // Required
	Autn       models_base.OctetString // Required
	Kasme      models_base.OctetString // Required
}

// Marshal serializes EUTRANVector to bytes
func (g *EUTRANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(1419, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(1447, g.Rand, true, false, 10415))

	// Marshal Xres (required)
	buf.Write(marshalAVPWithVendor(1448, g.Xres, true, false, 10415))

	// Marshal Autn (required)
	buf.Write(marshalAVPWithVendor(1449, g.Autn, true, false, 10415))

	// Marshal Kasme (required)
	buf.Write(marshalAVPWithVendor(1450, g.Kasme, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EUTRANVector
func (g *EUTRANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1419: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case 1447: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case 1448: // XRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Xres = val.(models_base.OctetString)
			}
		case 1449: // AUTN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Autn = val.(models_base.OctetString)
			}
		case 1450: // KASME
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Kasme = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MIP6AgentInfo represents the MIP6-Agent-Info grouped AVP (AVP Code 486)
type MIP6AgentInfo struct {
	MipHomeAgentAddress []models_base.Address    // Optional
	MipHomeAgentHost    *MIPHomeAgentHost        // Optional
	Mip6HomeLinkPrefix  *models_base.OctetString // Optional
}

// Marshal serializes MIP6AgentInfo to bytes
func (g *MIP6AgentInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal MipHomeAgentAddress (repeated)
	for _, v := range g.MipHomeAgentAddress {
		buf.Write(marshalAVP(334, v, true, false))
	}

	// Marshal MipHomeAgentHost (grouped)
	if g.MipHomeAgentHost != nil {
		if groupedData, err := g.MipHomeAgentHost.Marshal(); err == nil {
			buf.Write(marshalAVP(348, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal Mip6HomeLinkPrefix (optional)
	if g.Mip6HomeLinkPrefix != nil {
		buf.Write(marshalAVP(125, *g.Mip6HomeLinkPrefix, true, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into MIP6AgentInfo
func (g *MIP6AgentInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 334: // MIP-Home-Agent-Address
			val, err := models_base.DecodeAddress(avpValue)
			if err == nil {
				g.MipHomeAgentAddress = append(g.MipHomeAgentAddress, val.(models_base.Address))
			}
		case 348: // MIP-Home-Agent-Host
			grouped := &MIPHomeAgentHost{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.MipHomeAgentHost = grouped
			}
		case 125: // MIP6-Home-Link-Prefix
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Mip6HomeLinkPrefix = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// APNConfigurationProfile represents the APN-Configuration-Profile grouped AVP (AVP Code 1429)
type APNConfigurationProfile struct {
	ContextIdentifier    models_base.Unsigned32 // Required
	AllApnConfigIncluded models_base.Enumerated // Required
	ApnConfiguration     []*APNConfiguration    // Optional
}

// Marshal serializes APNConfigurationProfile to bytes
func (g *APNConfigurationProfile) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ContextIdentifier (required)
	buf.Write(marshalAVPWithVendor(1423, g.ContextIdentifier, true, false, 10415))

	// Marshal AllApnConfigIncluded (required)
	buf.Write(marshalAVPWithVendor(1428, g.AllApnConfigIncluded, true, false, 10415))

	// Marshal ApnConfiguration (repeated, grouped)
	for _, v := range g.ApnConfiguration {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1430, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into APNConfigurationProfile
func (g *APNConfigurationProfile) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1423: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ContextIdentifier = val.(models_base.Unsigned32)
			}
		case 1428: // All-APN-Configurations-Included-Indicator
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				g.AllApnConfigIncluded = val.(models_base.Enumerated)
			}
		case 1430: // APN-Configuration
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &APNConfiguration{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ApnConfiguration = append(g.ApnConfiguration, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EPSSubscribedQoSProfile represents the EPS-Subscribed-QoS-Profile grouped AVP (AVP Code 1431)
type EPSSubscribedQoSProfile struct {
	QosClassIdentifier          models_base.OctetString // Required - WARNING: AVP code not defined, DO NOT USE
	AllocationRetentionPriority models_base.OctetString // Required - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes EPSSubscribedQoSProfile to bytes
func (g *EPSSubscribedQoSProfile) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal QosClassIdentifier (required)
	buf.Write(marshalAVP(0, g.QosClassIdentifier, false, false))

	// Marshal AllocationRetentionPriority (required)
	buf.Write(marshalAVP(0, g.AllocationRetentionPriority, false, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EPSSubscribedQoSProfile
func (g *EPSSubscribedQoSProfile) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// E2ESequence represents the E2E-Sequence grouped AVP (AVP Code 300)
type E2ESequence struct {
	Avp models_base.OctetString // Required - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes E2ESequence to bytes
func (g *E2ESequence) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal Avp (required)
	buf.Write(marshalAVP(0, g.Avp, false, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into E2ESequence
func (g *E2ESequence) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// RequestedEUTRANAuthenticationInfo represents the Requested-EUTRAN-Authentication-Info grouped AVP (AVP Code 1408)
type RequestedEUTRANAuthenticationInfo struct {
	NumberOfRequestedVectors   *models_base.Unsigned32  // Optional
	ImmediateResponsePreferred *models_base.Unsigned32  // Optional
	ReSynchronizationInfo      *models_base.OctetString // Optional
}

// Marshal serializes RequestedEUTRANAuthenticationInfo to bytes
func (g *RequestedEUTRANAuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal NumberOfRequestedVectors (optional)
	if g.NumberOfRequestedVectors != nil {
		buf.Write(marshalAVPWithVendor(1410, *g.NumberOfRequestedVectors, true, false, 10415))
	}

	// Marshal ImmediateResponsePreferred (optional)
	if g.ImmediateResponsePreferred != nil {
		buf.Write(marshalAVPWithVendor(1412, *g.ImmediateResponsePreferred, true, false, 10415))
	}

	// Marshal ReSynchronizationInfo (optional)
	if g.ReSynchronizationInfo != nil {
		buf.Write(marshalAVPWithVendor(1411, *g.ReSynchronizationInfo, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into RequestedEUTRANAuthenticationInfo
func (g *RequestedEUTRANAuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1410: // Number-Of-Requested-Vectors
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.NumberOfRequestedVectors = &v
			}
		case 1412: // Immediate-Response-Preferred
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ImmediateResponsePreferred = &v
			}
		case 1411: // Re-Synchronization-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ReSynchronizationInfo = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// UTRANVector represents the UTRAN-Vector grouped AVP (AVP Code 1415)
type UTRANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Xres       models_base.OctetString // Required
	Autn       models_base.OctetString // Required
	Ck         models_base.OctetString // Required
	Ik         models_base.OctetString // Required
}

// Marshal serializes UTRANVector to bytes
func (g *UTRANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(1419, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(1447, g.Rand, true, false, 10415))

	// Marshal Xres (required)
	buf.Write(marshalAVPWithVendor(1448, g.Xres, true, false, 10415))

	// Marshal Autn (required)
	buf.Write(marshalAVPWithVendor(1449, g.Autn, true, false, 10415))

	// Marshal Ck (required)
	buf.Write(marshalAVPWithVendor(1451, g.Ck, true, false, 10415))

	// Marshal Ik (required)
	buf.Write(marshalAVPWithVendor(1452, g.Ik, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into UTRANVector
func (g *UTRANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1419: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case 1447: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case 1448: // XRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Xres = val.(models_base.OctetString)
			}
		case 1449: // AUTN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Autn = val.(models_base.OctetString)
			}
		case 1451: // Confidentiality-Key
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Ck = val.(models_base.OctetString)
			}
		case 1452: // Integrity-Key
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Ik = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AVP Codes
const (
	AVPCodeXRES                                  uint32 = 1448
	AVPCodeAPNCONFIGURATION                      uint32 = 1430
	AVPCodeSUBSCRIBERSTATUS                      uint32 = 1424
	AVPCodeERRORREPORTINGHOST                    uint32 = 294
	AVPCodeMIPHOMEAGENTHOST                      uint32 = 348
	AVPCodeSUPPORTEDVENDORID                     uint32 = 265
	AVPCodeSESSIONBINDING                        uint32 = 270
	AVPCodeKC                                    uint32 = 1453
	AVPCodeIDAFLAGS                              uint32 = 1441
	AVPCodePROXYHOST                             uint32 = 280
	AVPCodePRODUCTNAME                           uint32 = 269
	AVPCodeEVENTTIMESTAMP                        uint32 = 55
	AVPCodeACCTMULTISESSIONID                    uint32 = 50
	AVPCodeROUTERECORD                           uint32 = 282
	AVPCodeREQUESTEDUTRANGERANAUTHENTICATIONINFO uint32 = 1409
	AVPCodeAUTHENTICATIONINFO                    uint32 = 1413
	AVPCodeFIRMWAREREVISION                      uint32 = 267
	AVPCodeAUTHGRACEPERIOD                       uint32 = 276
	AVPCodeACCOUNTINGREALTIMEREQUIRED            uint32 = 483
	AVPCodeERRORMESSAGE                          uint32 = 281
	AVPCodeACCOUNTINGSUBSESSIONID                uint32 = 287
	AVPCodeACCESSRESTRICTIONDATA                 uint32 = 1426
	AVPCodeSGSNNUMBER                            uint32 = 1489
	AVPCodeCLRFLAGS                              uint32 = 1638
	AVPCodeACCTINTERIMINTERVAL                   uint32 = 85
	AVPCodeERRORDIAGNOSTIC                       uint32 = 1614
	AVPCodeVISITEDPLMNID                         uint32 = 1407
	AVPCodeCONTEXTIDENTIFIER                     uint32 = 1423
	AVPCodeSERVICESELECTION                      uint32 = 493
	AVPCodePROXYSTATE                            uint32 = 33
	AVPCodeSESSIONSERVERFAILOVER                 uint32 = 271
	AVPCodeTERMINALINFORMATION                   uint32 = 1401
	AVPCodeEUTRANVECTOR                          uint32 = 1414
	AVPCodeKASME                                 uint32 = 1450
	AVPCodeACCTAPPLICATIONID                     uint32 = 259
	AVPCodeVENDORID                              uint32 = 266
	AVPCodeACCTSESSIONID                         uint32 = 44
	AVPCodeMULTIROUNDTIMEOUT                     uint32 = 272
	AVPCodeMIP6AGENTINFO                         uint32 = 486
	AVPCodeMIPHOMEAGENTADDRESS                   uint32 = 334
	AVPCodeSOFTWAREVERSION                       uint32 = 1403
	AVPCodeCLASS                                 uint32 = 25
	AVPCodeIMEI                                  uint32 = 1402
	AVPCodeAPNCONFIGURATIONPROFILE               uint32 = 1429
	AVPCodeITEMNUMBER                            uint32 = 1419
	AVPCodeRAND                                  uint32 = 1447
	AVPCodeEPSSUBSCRIBEDQOSPROFILE               uint32 = 1431
	AVPCodeAPNOIREPLACEMENT                      uint32 = 1427
	AVPCodeMIP6HOMELINKPREFIX                    uint32 = 125
	AVPCodeDESTINATIONHOST                       uint32 = 293
	AVPCodeE2ESEQUENCE                           uint32 = 300
	AVPCode3GPP2MEID                             uint32 = 1471
	AVPCodeREQUESTEDEUTRANAUTHENTICATIONINFO     uint32 = 1408
	AVPCodeULRFLAGS                              uint32 = 1405
	AVPCodeUTRANVECTOR                           uint32 = 1415
	AVPCodePUAFLAGS                              uint32 = 1442
	AVPCodeREDIRECTHOSTUSAGE                     uint32 = 261
	AVPCodeEXPERIMENTALRESULT                    uint32 = 297
	AVPCodeINBANDSECURITYID                      uint32 = 299
	AVPCodeHOSTIPADDRESS                         uint32 = 257
	AVPCodePROXYINFO                             uint32 = 284
	AVPCodeSUBSCRIPTIONDATA                      uint32 = 1400
	AVPCodeAMBR                                  uint32 = 1435
	AVPCodeALERTREASON                           uint32 = 1434
	AVPCodeREAUTHREQUESTTYPE                     uint32 = 285
	AVPCodeVENDORSPECIFICAPPLICATIONID           uint32 = 260
	AVPCodeIMMEDIATERESPONSEPREFERRED            uint32 = 1412
	AVPCodeCONFIDENTIALITYKEY                    uint32 = 1451
	AVPCodeAMSISDN                               uint32 = 1643
	AVPCodeRESYNCHRONIZATIONINFO                 uint32 = 1411
	AVPCodeMSISDN                                uint32 = 701
	AVPCodeTERMINATIONCAUSE                      uint32 = 295
	AVPCodeORIGINHOST                            uint32 = 264
	AVPCodeAUTHREQUESTTYPE                       uint32 = 274
	AVPCodeDSAFLAGS                              uint32 = 1422
	AVPCodeUESRVCCCAPABILITY                     uint32 = 1615
	AVPCodeCANCELLATIONTYPE                      uint32 = 1420
	AVPCodeSRES                                  uint32 = 1454
	AVPCodeAUTHAPPLICATIONID                     uint32 = 258
	AVPCodeAUTHORIZATIONLIFETIME                 uint32 = 291
	AVPCodeREDIRECTMAXCACHETIME                  uint32 = 262
	AVPCodePURFLAGS                              uint32 = 1635
	AVPCodeOPERATORDETERMINEDBARRING             uint32 = 1425
	AVPCodeRESULTCODE                            uint32 = 268
	AVPCodeDISCONNECTCAUSE                       uint32 = 273
	AVPCodeFAILEDAVP                             uint32 = 279
	AVPCodeACCOUNTINGRECORDNUMBER                uint32 = 485
	AVPCodeRATTYPE                               uint32 = 1032
	AVPCodeALLAPNCONFIGURATIONSINCLUDEDINDICATOR uint32 = 1428
	AVPCodeNUMBEROFREQUESTEDVECTORS              uint32 = 1410
	AVPCodeCSGSUBSCRIPTIONDATA                   uint32 = 1436
	AVPCodeDESTINATIONREALM                      uint32 = 283
	AVPCodeSESSIONID                             uint32 = 263
	AVPCodeEQUIPMENTSTATUS                       uint32 = 1445
	AVPCodeULAFLAGS                              uint32 = 1406
	AVPCodeAUTN                                  uint32 = 1449
	AVPCodeNORFLAGS                              uint32 = 1443
	AVPCodeIDRFLAGS                              uint32 = 1490
	AVPCodeAUTHSESSIONSTATE                      uint32 = 277
	AVPCodeEXPERIMENTALRESULTCODE                uint32 = 298
	AVPCodeORIGINREALM                           uint32 = 296
	AVPCodeSESSIONTIMEOUT                        uint32 = 27
	AVPCodeAIRFLAGS                              uint32 = 1679
	AVPCodeINTEGRITYKEY                          uint32 = 1452
	AVPCodeGERANVECTOR                           uint32 = 1416
	AVPCodeDSRFLAGS                              uint32 = 1421
	AVPCodeUSERNAME                              uint32 = 1
	AVPCodeREDIRECTHOST                          uint32 = 292
	AVPCodeORIGINSTATEID                         uint32 = 278
	AVPCodeACCOUNTINGRECORDTYPE                  uint32 = 480
)

// Command Codes
const (
	CommandCodeCAPABILITIESEXCHANGEREQUEST uint32 = 257
	CommandCodeCAPABILITIESEXCHANGEANSWER  uint32 = 257
	CommandCodeDEVICEWATCHDOGREQUEST       uint32 = 280
	CommandCodeDEVICEWATCHDOGANSWER        uint32 = 280
	CommandCodeDISCONNECTPEERREQUEST       uint32 = 282
	CommandCodeDISCONNECTPEERANSWER        uint32 = 282
	CommandCodeREAUTHREQUEST               uint32 = 258
	CommandCodeREAUTHANSWER                uint32 = 258
	CommandCodeSESSIONTERMINATIONREQUEST   uint32 = 275
	CommandCodeSESSIONTERMINATIONANSWER    uint32 = 275
	CommandCodeABORTSESSIONREQUEST         uint32 = 274
	CommandCodeABORTSESSIONANSWER          uint32 = 274
	CommandCodeACCOUNTINGREQUEST           uint32 = 271
	CommandCodeACCOUNTINGANSWER            uint32 = 271
)

// CapabilitiesExchangeRequest represents the Capabilities-Exchange-Request (CER) Diameter command
// Command Code: 257, Application ID: 0
type CapabilitiesExchangeRequest struct {
	Header DiameterHeader

	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	HostIpAddress               []models_base.Address          // Required
	VendorId                    models_base.Unsigned32         // Required
	ProductName                 models_base.UTF8String         // Required
	OriginStateId               *models_base.Unsigned32        // Optional
	SupportedVendorId           []models_base.Unsigned32       // Optional
	AuthApplicationId           []models_base.Unsigned32       // Optional
	InbandSecurityId            []models_base.Unsigned32       // Optional
	AcctApplicationId           []models_base.Unsigned32       // Optional
	VendorSpecificApplicationId []*VendorSpecificApplicationId // Optional
	FirmwareRevision            *models_base.Unsigned32        // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewCapabilitiesExchangeRequest creates a new CER message
func NewCapabilitiesExchangeRequest() *CapabilitiesExchangeRequest {
	return &CapabilitiesExchangeRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   257,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in CapabilitiesExchangeRequest
func (m *CapabilitiesExchangeRequest) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if len(m.HostIpAddress) == 0 {
		return fmt.Errorf("required repeated field Host-IP-Address is empty")
	}
	if m.ProductName == "" {
		return fmt.Errorf("required field Product-Name is empty")
	}

	return nil
}

// Marshal serializes the CapabilitiesExchangeRequest to bytes using a buffer for optimal performance
func (m *CapabilitiesExchangeRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal HostIpAddress (repeated)
	for _, v := range m.HostIpAddress {
		buf.Write(marshalAVP(257, v, true, false))
	}

	// Marshal VendorId (required)
	buf.Write(marshalAVP(266, m.VendorId, true, false))

	// Marshal ProductName (required)
	buf.Write(marshalAVP(269, m.ProductName, false, false))

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal SupportedVendorId (repeated)
	for _, v := range m.SupportedVendorId {
		buf.Write(marshalAVP(265, v, true, false))
	}

	// Marshal AuthApplicationId (repeated)
	for _, v := range m.AuthApplicationId {
		buf.Write(marshalAVP(258, v, true, false))
	}

	// Marshal InbandSecurityId (repeated)
	for _, v := range m.InbandSecurityId {
		buf.Write(marshalAVP(299, v, true, false))
	}

	// Marshal AcctApplicationId (repeated)
	for _, v := range m.AcctApplicationId {
		buf.Write(marshalAVP(259, v, true, false))
	}

	// Marshal VendorSpecificApplicationId (repeated, grouped)
	for _, v := range m.VendorSpecificApplicationId {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(260, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal FirmwareRevision (optional)
	if m.FirmwareRevision != nil {
		buf.Write(marshalAVP(267, *m.FirmwareRevision, false, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CapabilitiesExchangeRequest
func (m *CapabilitiesExchangeRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 257: // Host-IP-Address
			val, err := models_base.DecodeAddress(avpValue)
			if err == nil {
				m.HostIpAddress = append(m.HostIpAddress, val.(models_base.Address))
			}
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.VendorId = val.(models_base.Unsigned32)
			}
		case 269: // Product-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.ProductName = val.(models_base.UTF8String)
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 265: // Supported-Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.SupportedVendorId = append(m.SupportedVendorId, val.(models_base.Unsigned32))
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = append(m.AuthApplicationId, val.(models_base.Unsigned32))
			}
		case 299: // Inband-Security-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.InbandSecurityId = append(m.InbandSecurityId, val.(models_base.Unsigned32))
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AcctApplicationId = append(m.AcctApplicationId, val.(models_base.Unsigned32))
			}
		case 260: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = append(m.VendorSpecificApplicationId, grouped)
			}
		case 267: // Firmware-Revision
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.FirmwareRevision = &v
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CapabilitiesExchangeRequest message
func (m *CapabilitiesExchangeRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CapabilitiesExchangeRequest
func (m *CapabilitiesExchangeRequest) String() string {
	return fmt.Sprintf("CapabilitiesExchangeRequest{OriginHost:%v, OriginRealm:%v, HostIpAddress:%v, VendorId:%v, ProductName:%v, OriginStateId:%v, SupportedVendorId:%v, AuthApplicationId:%v, InbandSecurityId:%v, AcctApplicationId:%v, VendorSpecificApplicationId:%v, FirmwareRevision:%v, Avp:%v}", m.OriginHost, m.OriginRealm, m.HostIpAddress, m.VendorId, m.ProductName, m.OriginStateId, m.SupportedVendorId, m.AuthApplicationId, m.InbandSecurityId, m.AcctApplicationId, m.VendorSpecificApplicationId, m.FirmwareRevision, m.Avp)
}

// CapabilitiesExchangeAnswer represents the Capabilities-Exchange-Answer (CEA) Diameter command
// Command Code: 257, Application ID: 0
type CapabilitiesExchangeAnswer struct {
	Header DiameterHeader

	ResultCode                  models_base.Unsigned32         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	HostIpAddress               []models_base.Address          // Required
	VendorId                    models_base.Unsigned32         // Required
	ProductName                 models_base.UTF8String         // Required
	OriginStateId               *models_base.Unsigned32        // Optional
	ErrorMessage                *models_base.UTF8String        // Optional
	FailedAvp                   *FailedAVP                     // Optional
	SupportedVendorId           []models_base.Unsigned32       // Optional
	AuthApplicationId           []models_base.Unsigned32       // Optional
	InbandSecurityId            []models_base.Unsigned32       // Optional
	AcctApplicationId           []models_base.Unsigned32       // Optional
	VendorSpecificApplicationId []*VendorSpecificApplicationId // Optional
	FirmwareRevision            *models_base.Unsigned32        // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewCapabilitiesExchangeAnswer creates a new CEA message
func NewCapabilitiesExchangeAnswer() *CapabilitiesExchangeAnswer {
	return &CapabilitiesExchangeAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   257,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in CapabilitiesExchangeAnswer
func (m *CapabilitiesExchangeAnswer) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if len(m.HostIpAddress) == 0 {
		return fmt.Errorf("required repeated field Host-IP-Address is empty")
	}
	if m.ProductName == "" {
		return fmt.Errorf("required field Product-Name is empty")
	}

	return nil
}

// Marshal serializes the CapabilitiesExchangeAnswer to bytes using a buffer for optimal performance
func (m *CapabilitiesExchangeAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal HostIpAddress (repeated)
	for _, v := range m.HostIpAddress {
		buf.Write(marshalAVP(257, v, true, false))
	}

	// Marshal VendorId (required)
	buf.Write(marshalAVP(266, m.VendorId, true, false))

	// Marshal ProductName (required)
	buf.Write(marshalAVP(269, m.ProductName, false, false))

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal ErrorMessage (optional)
	if m.ErrorMessage != nil {
		buf.Write(marshalAVP(281, *m.ErrorMessage, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal SupportedVendorId (repeated)
	for _, v := range m.SupportedVendorId {
		buf.Write(marshalAVP(265, v, true, false))
	}

	// Marshal AuthApplicationId (repeated)
	for _, v := range m.AuthApplicationId {
		buf.Write(marshalAVP(258, v, true, false))
	}

	// Marshal InbandSecurityId (repeated)
	for _, v := range m.InbandSecurityId {
		buf.Write(marshalAVP(299, v, true, false))
	}

	// Marshal AcctApplicationId (repeated)
	for _, v := range m.AcctApplicationId {
		buf.Write(marshalAVP(259, v, true, false))
	}

	// Marshal VendorSpecificApplicationId (repeated, grouped)
	for _, v := range m.VendorSpecificApplicationId {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(260, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal FirmwareRevision (optional)
	if m.FirmwareRevision != nil {
		buf.Write(marshalAVP(267, *m.FirmwareRevision, false, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CapabilitiesExchangeAnswer
func (m *CapabilitiesExchangeAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 257: // Host-IP-Address
			val, err := models_base.DecodeAddress(avpValue)
			if err == nil {
				m.HostIpAddress = append(m.HostIpAddress, val.(models_base.Address))
			}
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.VendorId = val.(models_base.Unsigned32)
			}
		case 269: // Product-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.ProductName = val.(models_base.UTF8String)
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 281: // Error-Message
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ErrorMessage = &v
			}
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case 265: // Supported-Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.SupportedVendorId = append(m.SupportedVendorId, val.(models_base.Unsigned32))
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = append(m.AuthApplicationId, val.(models_base.Unsigned32))
			}
		case 299: // Inband-Security-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.InbandSecurityId = append(m.InbandSecurityId, val.(models_base.Unsigned32))
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AcctApplicationId = append(m.AcctApplicationId, val.(models_base.Unsigned32))
			}
		case 260: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = append(m.VendorSpecificApplicationId, grouped)
			}
		case 267: // Firmware-Revision
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.FirmwareRevision = &v
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CapabilitiesExchangeAnswer message
func (m *CapabilitiesExchangeAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CapabilitiesExchangeAnswer
func (m *CapabilitiesExchangeAnswer) String() string {
	return fmt.Sprintf("CapabilitiesExchangeAnswer{ResultCode:%v, OriginHost:%v, OriginRealm:%v, HostIpAddress:%v, VendorId:%v, ProductName:%v, OriginStateId:%v, ErrorMessage:%v, FailedAvp:%v, SupportedVendorId:%v, AuthApplicationId:%v, InbandSecurityId:%v, AcctApplicationId:%v, VendorSpecificApplicationId:%v, FirmwareRevision:%v, Avp:%v}", m.ResultCode, m.OriginHost, m.OriginRealm, m.HostIpAddress, m.VendorId, m.ProductName, m.OriginStateId, m.ErrorMessage, m.FailedAvp, m.SupportedVendorId, m.AuthApplicationId, m.InbandSecurityId, m.AcctApplicationId, m.VendorSpecificApplicationId, m.FirmwareRevision, m.Avp)
}

// DeviceWatchdogRequest represents the Device-Watchdog-Request (DWR) Diameter command
// Command Code: 280, Application ID: 0
type DeviceWatchdogRequest struct {
	Header DiameterHeader

	OriginHost    models_base.DiameterIdentity // Required
	OriginRealm   models_base.DiameterIdentity // Required
	OriginStateId *models_base.Unsigned32      // Optional
	Avp           []models_base.OctetString    // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewDeviceWatchdogRequest creates a new DWR message
func NewDeviceWatchdogRequest() *DeviceWatchdogRequest {
	return &DeviceWatchdogRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   280,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DeviceWatchdogRequest
func (m *DeviceWatchdogRequest) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DeviceWatchdogRequest to bytes using a buffer for optimal performance
func (m *DeviceWatchdogRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeviceWatchdogRequest
func (m *DeviceWatchdogRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeviceWatchdogRequest message
func (m *DeviceWatchdogRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeviceWatchdogRequest
func (m *DeviceWatchdogRequest) String() string {
	return fmt.Sprintf("DeviceWatchdogRequest{OriginHost:%v, OriginRealm:%v, OriginStateId:%v, Avp:%v}", m.OriginHost, m.OriginRealm, m.OriginStateId, m.Avp)
}

// DeviceWatchdogAnswer represents the Device-Watchdog-Answer (DWA) Diameter command
// Command Code: 280, Application ID: 0
type DeviceWatchdogAnswer struct {
	Header DiameterHeader

	ResultCode    models_base.Unsigned32       // Required
	OriginHost    models_base.DiameterIdentity // Required
	OriginRealm   models_base.DiameterIdentity // Required
	ErrorMessage  *models_base.UTF8String      // Optional
	FailedAvp     *FailedAVP                   // Optional
	OriginStateId *models_base.Unsigned32      // Optional
	Avp           []models_base.OctetString    // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewDeviceWatchdogAnswer creates a new DWA message
func NewDeviceWatchdogAnswer() *DeviceWatchdogAnswer {
	return &DeviceWatchdogAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   280,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DeviceWatchdogAnswer
func (m *DeviceWatchdogAnswer) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DeviceWatchdogAnswer to bytes using a buffer for optimal performance
func (m *DeviceWatchdogAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal ErrorMessage (optional)
	if m.ErrorMessage != nil {
		buf.Write(marshalAVP(281, *m.ErrorMessage, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeviceWatchdogAnswer
func (m *DeviceWatchdogAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 281: // Error-Message
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ErrorMessage = &v
			}
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeviceWatchdogAnswer message
func (m *DeviceWatchdogAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeviceWatchdogAnswer
func (m *DeviceWatchdogAnswer) String() string {
	return fmt.Sprintf("DeviceWatchdogAnswer{ResultCode:%v, OriginHost:%v, OriginRealm:%v, ErrorMessage:%v, FailedAvp:%v, OriginStateId:%v, Avp:%v}", m.ResultCode, m.OriginHost, m.OriginRealm, m.ErrorMessage, m.FailedAvp, m.OriginStateId, m.Avp)
}

// DisconnectPeerRequest represents the Disconnect-Peer-Request (DPR) Diameter command
// Command Code: 282, Application ID: 0
type DisconnectPeerRequest struct {
	Header DiameterHeader

	OriginHost      models_base.DiameterIdentity // Required
	OriginRealm     models_base.DiameterIdentity // Required
	DisconnectCause models_base.Enumerated       // Required
	Avp             []models_base.OctetString    // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewDisconnectPeerRequest creates a new DPR message
func NewDisconnectPeerRequest() *DisconnectPeerRequest {
	return &DisconnectPeerRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   282,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DisconnectPeerRequest
func (m *DisconnectPeerRequest) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DisconnectPeerRequest to bytes using a buffer for optimal performance
func (m *DisconnectPeerRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DisconnectCause (required)
	buf.Write(marshalAVP(273, m.DisconnectCause, true, false))

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DisconnectPeerRequest
func (m *DisconnectPeerRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 273: // Disconnect-Cause
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.DisconnectCause = val.(models_base.Enumerated)
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DisconnectPeerRequest message
func (m *DisconnectPeerRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DisconnectPeerRequest
func (m *DisconnectPeerRequest) String() string {
	return fmt.Sprintf("DisconnectPeerRequest{OriginHost:%v, OriginRealm:%v, DisconnectCause:%v, Avp:%v}", m.OriginHost, m.OriginRealm, m.DisconnectCause, m.Avp)
}

// DisconnectPeerAnswer represents the Disconnect-Peer-Answer (DPA) Diameter command
// Command Code: 282, Application ID: 0
type DisconnectPeerAnswer struct {
	Header DiameterHeader

	ResultCode   models_base.Unsigned32       // Required
	OriginHost   models_base.DiameterIdentity // Required
	OriginRealm  models_base.DiameterIdentity // Required
	ErrorMessage *models_base.UTF8String      // Optional
	FailedAvp    *FailedAVP                   // Optional
	Avp          []models_base.OctetString    // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewDisconnectPeerAnswer creates a new DPA message
func NewDisconnectPeerAnswer() *DisconnectPeerAnswer {
	return &DisconnectPeerAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   282,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DisconnectPeerAnswer
func (m *DisconnectPeerAnswer) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DisconnectPeerAnswer to bytes using a buffer for optimal performance
func (m *DisconnectPeerAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal ErrorMessage (optional)
	if m.ErrorMessage != nil {
		buf.Write(marshalAVP(281, *m.ErrorMessage, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DisconnectPeerAnswer
func (m *DisconnectPeerAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 281: // Error-Message
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ErrorMessage = &v
			}
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DisconnectPeerAnswer message
func (m *DisconnectPeerAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DisconnectPeerAnswer
func (m *DisconnectPeerAnswer) String() string {
	return fmt.Sprintf("DisconnectPeerAnswer{ResultCode:%v, OriginHost:%v, OriginRealm:%v, ErrorMessage:%v, FailedAvp:%v, Avp:%v}", m.ResultCode, m.OriginHost, m.OriginRealm, m.ErrorMessage, m.FailedAvp, m.Avp)
}

// ReAuthRequest represents the Re-Auth-Request (RAR) Diameter command
// Command Code: 258, Application ID: 0
type ReAuthRequest struct {
	Header DiameterHeader

	SessionId         models_base.UTF8String         // Required
	OriginHost        models_base.DiameterIdentity   // Required
	OriginRealm       models_base.DiameterIdentity   // Required
	DestinationRealm  models_base.DiameterIdentity   // Required
	DestinationHost   models_base.DiameterIdentity   // Required
	AuthApplicationId models_base.Unsigned32         // Required
	ReAuthRequestType models_base.Enumerated         // Required
	UserName          *models_base.UTF8String        // Optional
	OriginStateId     *models_base.Unsigned32        // Optional
	ProxyInfo         []*ProxyInfo                   // Optional
	RouteRecord       []models_base.DiameterIdentity // Optional
	Avp               []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewReAuthRequest creates a new RAR message
func NewReAuthRequest() *ReAuthRequest {
	return &ReAuthRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   258,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ReAuthRequest
func (m *ReAuthRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}

	return nil
}

// Marshal serializes the ReAuthRequest to bytes using a buffer for optimal performance
func (m *ReAuthRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, true, false))

	// Marshal AuthApplicationId (required)
	buf.Write(marshalAVP(258, m.AuthApplicationId, true, false))

	// Marshal ReAuthRequestType (required)
	buf.Write(marshalAVP(285, m.ReAuthRequestType, true, false))

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, true, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ReAuthRequest
func (m *ReAuthRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = val.(models_base.Unsigned32)
			}
		case 285: // Re-Auth-Request-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.ReAuthRequestType = val.(models_base.Enumerated)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ReAuthRequest message
func (m *ReAuthRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ReAuthRequest
func (m *ReAuthRequest) String() string {
	return fmt.Sprintf("ReAuthRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, DestinationHost:%v, AuthApplicationId:%v, ReAuthRequestType:%v, UserName:%v, OriginStateId:%v, ProxyInfo:%v, RouteRecord:%v, Avp:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.DestinationHost, m.AuthApplicationId, m.ReAuthRequestType, m.UserName, m.OriginStateId, m.ProxyInfo, m.RouteRecord, m.Avp)
}

// ReAuthAnswer represents the Re-Auth-Answer (RAA) Diameter command
// Command Code: 258, Application ID: 0
type ReAuthAnswer struct {
	Header DiameterHeader

	SessionId            models_base.UTF8String        // Required
	ResultCode           models_base.Unsigned32        // Required
	OriginHost           models_base.DiameterIdentity  // Required
	OriginRealm          models_base.DiameterIdentity  // Required
	UserName             *models_base.UTF8String       // Optional
	OriginStateId        *models_base.Unsigned32       // Optional
	ErrorMessage         *models_base.UTF8String       // Optional
	ErrorReportingHost   *models_base.DiameterIdentity // Optional
	FailedAvp            *FailedAVP                    // Optional
	RedirectHost         []models_base.DiameterURI     // Optional
	RedirectHostUsage    *models_base.Enumerated       // Optional
	RedirectMaxCacheTime *models_base.Unsigned32       // Optional
	ProxyInfo            []*ProxyInfo                  // Optional
	Avp                  []models_base.OctetString     // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewReAuthAnswer creates a new RAA message
func NewReAuthAnswer() *ReAuthAnswer {
	return &ReAuthAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   258,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ReAuthAnswer
func (m *ReAuthAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the ReAuthAnswer to bytes using a buffer for optimal performance
func (m *ReAuthAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal ErrorMessage (optional)
	if m.ErrorMessage != nil {
		buf.Write(marshalAVP(281, *m.ErrorMessage, false, false))
	}

	// Marshal ErrorReportingHost (optional)
	if m.ErrorReportingHost != nil {
		buf.Write(marshalAVP(294, *m.ErrorReportingHost, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal RedirectHost (repeated)
	for _, v := range m.RedirectHost {
		buf.Write(marshalAVP(292, v, true, false))
	}

	// Marshal RedirectHostUsage (optional)
	if m.RedirectHostUsage != nil {
		buf.Write(marshalAVP(261, *m.RedirectHostUsage, true, false))
	}

	// Marshal RedirectMaxCacheTime (optional)
	if m.RedirectMaxCacheTime != nil {
		buf.Write(marshalAVP(262, *m.RedirectMaxCacheTime, true, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ReAuthAnswer
func (m *ReAuthAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 281: // Error-Message
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ErrorMessage = &v
			}
		case 294: // Error-Reporting-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.ErrorReportingHost = &v
			}
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case 292: // Redirect-Host
			val, err := models_base.DecodeDiameterURI(avpValue)
			if err == nil {
				m.RedirectHost = append(m.RedirectHost, val.(models_base.DiameterURI))
			}
		case 261: // Redirect-Host-Usage
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.RedirectHostUsage = &v
			}
		case 262: // Redirect-Max-Cache-Time
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.RedirectMaxCacheTime = &v
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ReAuthAnswer message
func (m *ReAuthAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ReAuthAnswer
func (m *ReAuthAnswer) String() string {
	return fmt.Sprintf("ReAuthAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v, UserName:%v, OriginStateId:%v, ErrorMessage:%v, ErrorReportingHost:%v, FailedAvp:%v, RedirectHost:%v, RedirectHostUsage:%v, RedirectMaxCacheTime:%v, ProxyInfo:%v, Avp:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm, m.UserName, m.OriginStateId, m.ErrorMessage, m.ErrorReportingHost, m.FailedAvp, m.RedirectHost, m.RedirectHostUsage, m.RedirectMaxCacheTime, m.ProxyInfo, m.Avp)
}

// SessionTerminationRequest represents the Session-Termination-Request (STR) Diameter command
// Command Code: 275, Application ID: 0
type SessionTerminationRequest struct {
	Header DiameterHeader

	SessionId         models_base.UTF8String         // Required
	OriginHost        models_base.DiameterIdentity   // Required
	OriginRealm       models_base.DiameterIdentity   // Required
	DestinationRealm  models_base.DiameterIdentity   // Required
	AuthApplicationId models_base.Unsigned32         // Required
	TerminationCause  models_base.Enumerated         // Required
	UserName          *models_base.UTF8String        // Optional
	DestinationHost   *models_base.DiameterIdentity  // Optional
	Class             []models_base.OctetString      // Optional
	OriginStateId     *models_base.Unsigned32        // Optional
	ProxyInfo         []*ProxyInfo                   // Optional
	RouteRecord       []models_base.DiameterIdentity // Optional
	Avp               []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewSessionTerminationRequest creates a new STR message
func NewSessionTerminationRequest() *SessionTerminationRequest {
	return &SessionTerminationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   275,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in SessionTerminationRequest
func (m *SessionTerminationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}

	return nil
}

// Marshal serializes the SessionTerminationRequest to bytes using a buffer for optimal performance
func (m *SessionTerminationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal AuthApplicationId (required)
	buf.Write(marshalAVP(258, m.AuthApplicationId, true, false))

	// Marshal TerminationCause (required)
	buf.Write(marshalAVP(295, m.TerminationCause, true, false))

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, true, false))
	}

	// Marshal Class (repeated)
	for _, v := range m.Class {
		buf.Write(marshalAVP(25, v, true, true))
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, true, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into SessionTerminationRequest
func (m *SessionTerminationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = val.(models_base.Unsigned32)
			}
		case 295: // Termination-Cause
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.TerminationCause = val.(models_base.Enumerated)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		case 25: // Class
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.Class = append(m.Class, val.(models_base.OctetString))
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the SessionTerminationRequest message
func (m *SessionTerminationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of SessionTerminationRequest
func (m *SessionTerminationRequest) String() string {
	return fmt.Sprintf("SessionTerminationRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, AuthApplicationId:%v, TerminationCause:%v, UserName:%v, DestinationHost:%v, Class:%v, OriginStateId:%v, ProxyInfo:%v, RouteRecord:%v, Avp:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.AuthApplicationId, m.TerminationCause, m.UserName, m.DestinationHost, m.Class, m.OriginStateId, m.ProxyInfo, m.RouteRecord, m.Avp)
}

// SessionTerminationAnswer represents the Session-Termination-Answer (STA) Diameter command
// Command Code: 275, Application ID: 0
type SessionTerminationAnswer struct {
	Header DiameterHeader

	SessionId            models_base.UTF8String        // Required
	ResultCode           models_base.Unsigned32        // Required
	OriginHost           models_base.DiameterIdentity  // Required
	OriginRealm          models_base.DiameterIdentity  // Required
	UserName             *models_base.UTF8String       // Optional
	Class                []models_base.OctetString     // Optional
	ErrorMessage         *models_base.UTF8String       // Optional
	ErrorReportingHost   *models_base.DiameterIdentity // Optional
	FailedAvp            *FailedAVP                    // Optional
	OriginStateId        *models_base.Unsigned32       // Optional
	RedirectHost         []models_base.DiameterURI     // Optional
	RedirectHostUsage    *models_base.Enumerated       // Optional
	RedirectMaxCacheTime *models_base.Unsigned32       // Optional
	ProxyInfo            []*ProxyInfo                  // Optional
	Avp                  []models_base.OctetString     // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewSessionTerminationAnswer creates a new STA message
func NewSessionTerminationAnswer() *SessionTerminationAnswer {
	return &SessionTerminationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   275,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in SessionTerminationAnswer
func (m *SessionTerminationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the SessionTerminationAnswer to bytes using a buffer for optimal performance
func (m *SessionTerminationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal Class (repeated)
	for _, v := range m.Class {
		buf.Write(marshalAVP(25, v, true, true))
	}

	// Marshal ErrorMessage (optional)
	if m.ErrorMessage != nil {
		buf.Write(marshalAVP(281, *m.ErrorMessage, false, false))
	}

	// Marshal ErrorReportingHost (optional)
	if m.ErrorReportingHost != nil {
		buf.Write(marshalAVP(294, *m.ErrorReportingHost, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal RedirectHost (repeated)
	for _, v := range m.RedirectHost {
		buf.Write(marshalAVP(292, v, true, false))
	}

	// Marshal RedirectHostUsage (optional)
	if m.RedirectHostUsage != nil {
		buf.Write(marshalAVP(261, *m.RedirectHostUsage, true, false))
	}

	// Marshal RedirectMaxCacheTime (optional)
	if m.RedirectMaxCacheTime != nil {
		buf.Write(marshalAVP(262, *m.RedirectMaxCacheTime, true, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into SessionTerminationAnswer
func (m *SessionTerminationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 25: // Class
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.Class = append(m.Class, val.(models_base.OctetString))
			}
		case 281: // Error-Message
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ErrorMessage = &v
			}
		case 294: // Error-Reporting-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.ErrorReportingHost = &v
			}
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 292: // Redirect-Host
			val, err := models_base.DecodeDiameterURI(avpValue)
			if err == nil {
				m.RedirectHost = append(m.RedirectHost, val.(models_base.DiameterURI))
			}
		case 261: // Redirect-Host-Usage
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.RedirectHostUsage = &v
			}
		case 262: // Redirect-Max-Cache-Time
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.RedirectMaxCacheTime = &v
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the SessionTerminationAnswer message
func (m *SessionTerminationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of SessionTerminationAnswer
func (m *SessionTerminationAnswer) String() string {
	return fmt.Sprintf("SessionTerminationAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v, UserName:%v, Class:%v, ErrorMessage:%v, ErrorReportingHost:%v, FailedAvp:%v, OriginStateId:%v, RedirectHost:%v, RedirectHostUsage:%v, RedirectMaxCacheTime:%v, ProxyInfo:%v, Avp:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm, m.UserName, m.Class, m.ErrorMessage, m.ErrorReportingHost, m.FailedAvp, m.OriginStateId, m.RedirectHost, m.RedirectHostUsage, m.RedirectMaxCacheTime, m.ProxyInfo, m.Avp)
}

// AbortSessionRequest represents the Abort-Session-Request (ASR) Diameter command
// Command Code: 274, Application ID: 0
type AbortSessionRequest struct {
	Header DiameterHeader

	SessionId         models_base.UTF8String         // Required
	OriginHost        models_base.DiameterIdentity   // Required
	OriginRealm       models_base.DiameterIdentity   // Required
	DestinationRealm  models_base.DiameterIdentity   // Required
	DestinationHost   models_base.DiameterIdentity   // Required
	AuthApplicationId models_base.Unsigned32         // Required
	UserName          *models_base.UTF8String        // Optional
	OriginStateId     *models_base.Unsigned32        // Optional
	ProxyInfo         []*ProxyInfo                   // Optional
	RouteRecord       []models_base.DiameterIdentity // Optional
	Avp               []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewAbortSessionRequest creates a new ASR message
func NewAbortSessionRequest() *AbortSessionRequest {
	return &AbortSessionRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   274,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AbortSessionRequest
func (m *AbortSessionRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}

	return nil
}

// Marshal serializes the AbortSessionRequest to bytes using a buffer for optimal performance
func (m *AbortSessionRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, true, false))

	// Marshal AuthApplicationId (required)
	buf.Write(marshalAVP(258, m.AuthApplicationId, true, false))

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, true, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AbortSessionRequest
func (m *AbortSessionRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = val.(models_base.Unsigned32)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AbortSessionRequest message
func (m *AbortSessionRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AbortSessionRequest
func (m *AbortSessionRequest) String() string {
	return fmt.Sprintf("AbortSessionRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, DestinationHost:%v, AuthApplicationId:%v, UserName:%v, OriginStateId:%v, ProxyInfo:%v, RouteRecord:%v, Avp:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.DestinationHost, m.AuthApplicationId, m.UserName, m.OriginStateId, m.ProxyInfo, m.RouteRecord, m.Avp)
}

// AbortSessionAnswer represents the Abort-Session-Answer (ASA) Diameter command
// Command Code: 274, Application ID: 0
type AbortSessionAnswer struct {
	Header DiameterHeader

	SessionId            models_base.UTF8String        // Required
	ResultCode           models_base.Unsigned32        // Required
	OriginHost           models_base.DiameterIdentity  // Required
	OriginRealm          models_base.DiameterIdentity  // Required
	UserName             *models_base.UTF8String       // Optional
	OriginStateId        *models_base.Unsigned32       // Optional
	ErrorMessage         *models_base.UTF8String       // Optional
	ErrorReportingHost   *models_base.DiameterIdentity // Optional
	FailedAvp            *FailedAVP                    // Optional
	RedirectHost         []models_base.DiameterURI     // Optional
	RedirectHostUsage    *models_base.Enumerated       // Optional
	RedirectMaxCacheTime *models_base.Unsigned32       // Optional
	ProxyInfo            []*ProxyInfo                  // Optional
	Avp                  []models_base.OctetString     // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewAbortSessionAnswer creates a new ASA message
func NewAbortSessionAnswer() *AbortSessionAnswer {
	return &AbortSessionAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   274,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AbortSessionAnswer
func (m *AbortSessionAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the AbortSessionAnswer to bytes using a buffer for optimal performance
func (m *AbortSessionAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal ErrorMessage (optional)
	if m.ErrorMessage != nil {
		buf.Write(marshalAVP(281, *m.ErrorMessage, false, false))
	}

	// Marshal ErrorReportingHost (optional)
	if m.ErrorReportingHost != nil {
		buf.Write(marshalAVP(294, *m.ErrorReportingHost, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal RedirectHost (repeated)
	for _, v := range m.RedirectHost {
		buf.Write(marshalAVP(292, v, true, false))
	}

	// Marshal RedirectHostUsage (optional)
	if m.RedirectHostUsage != nil {
		buf.Write(marshalAVP(261, *m.RedirectHostUsage, true, false))
	}

	// Marshal RedirectMaxCacheTime (optional)
	if m.RedirectMaxCacheTime != nil {
		buf.Write(marshalAVP(262, *m.RedirectMaxCacheTime, true, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AbortSessionAnswer
func (m *AbortSessionAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 281: // Error-Message
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ErrorMessage = &v
			}
		case 294: // Error-Reporting-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.ErrorReportingHost = &v
			}
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case 292: // Redirect-Host
			val, err := models_base.DecodeDiameterURI(avpValue)
			if err == nil {
				m.RedirectHost = append(m.RedirectHost, val.(models_base.DiameterURI))
			}
		case 261: // Redirect-Host-Usage
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.RedirectHostUsage = &v
			}
		case 262: // Redirect-Max-Cache-Time
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.RedirectMaxCacheTime = &v
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AbortSessionAnswer message
func (m *AbortSessionAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AbortSessionAnswer
func (m *AbortSessionAnswer) String() string {
	return fmt.Sprintf("AbortSessionAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v, UserName:%v, OriginStateId:%v, ErrorMessage:%v, ErrorReportingHost:%v, FailedAvp:%v, RedirectHost:%v, RedirectHostUsage:%v, RedirectMaxCacheTime:%v, ProxyInfo:%v, Avp:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm, m.UserName, m.OriginStateId, m.ErrorMessage, m.ErrorReportingHost, m.FailedAvp, m.RedirectHost, m.RedirectHostUsage, m.RedirectMaxCacheTime, m.ProxyInfo, m.Avp)
}

// AccountingRequest represents the Accounting-Request (AR) Diameter command
// Command Code: 271, Application ID: 3
type AccountingRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	AccountingRecordType        models_base.Enumerated         // Required
	AccountingRecordNumber      models_base.Unsigned32         // Required
	AcctApplicationId           *models_base.Unsigned32        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	UserName                    *models_base.UTF8String        // Optional
	DestinationHost             *models_base.DiameterIdentity  // Optional
	AccountingSubSessionId      *models_base.Unsigned64        // Optional
	AcctSessionId               *models_base.OctetString       // Optional
	AcctMultiSessionId          *models_base.UTF8String        // Optional
	AcctInterimInterval         *models_base.Unsigned32        // Optional
	AccountingRealtimeRequired  *models_base.Enumerated        // Optional
	OriginStateId               *models_base.Unsigned32        // Optional
	EventTimestamp              *models_base.Time              // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewAccountingRequest creates a new AR message
func NewAccountingRequest() *AccountingRequest {
	return &AccountingRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   271,
			ApplicationID: 3,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AccountingRequest
func (m *AccountingRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}

	return nil
}

// Marshal serializes the AccountingRequest to bytes using a buffer for optimal performance
func (m *AccountingRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal AccountingRecordType (required)
	buf.Write(marshalAVP(480, m.AccountingRecordType, true, false))

	// Marshal AccountingRecordNumber (required)
	buf.Write(marshalAVP(485, m.AccountingRecordNumber, true, false))

	// Marshal AcctApplicationId (optional)
	if m.AcctApplicationId != nil {
		buf.Write(marshalAVP(259, *m.AcctApplicationId, true, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(260, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, true, false))
	}

	// Marshal AccountingSubSessionId (optional)
	if m.AccountingSubSessionId != nil {
		buf.Write(marshalAVP(287, *m.AccountingSubSessionId, true, false))
	}

	// Marshal AcctSessionId (optional)
	if m.AcctSessionId != nil {
		buf.Write(marshalAVP(44, *m.AcctSessionId, true, false))
	}

	// Marshal AcctMultiSessionId (optional)
	if m.AcctMultiSessionId != nil {
		buf.Write(marshalAVP(50, *m.AcctMultiSessionId, true, false))
	}

	// Marshal AcctInterimInterval (optional)
	if m.AcctInterimInterval != nil {
		buf.Write(marshalAVP(85, *m.AcctInterimInterval, true, false))
	}

	// Marshal AccountingRealtimeRequired (optional)
	if m.AccountingRealtimeRequired != nil {
		buf.Write(marshalAVP(483, *m.AccountingRealtimeRequired, true, false))
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal EventTimestamp (optional)
	if m.EventTimestamp != nil {
		buf.Write(marshalAVP(55, *m.EventTimestamp, true, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, true, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AccountingRequest
func (m *AccountingRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 480: // Accounting-Record-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AccountingRecordType = val.(models_base.Enumerated)
			}
		case 485: // Accounting-Record-Number
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AccountingRecordNumber = val.(models_base.Unsigned32)
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.AcctApplicationId = &v
			}
		case 260: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		case 287: // Accounting-Sub-Session-Id
			val, err := models_base.DecodeUnsigned64(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned64)
				m.AccountingSubSessionId = &v
			}
		case 44: // Acct-Session-Id
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.AcctSessionId = &v
			}
		case 50: // Acct-Multi-Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.AcctMultiSessionId = &v
			}
		case 85: // Acct-Interim-Interval
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.AcctInterimInterval = &v
			}
		case 483: // Accounting-Realtime-Required
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.AccountingRealtimeRequired = &v
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 55: // Event-Timestamp
			val, err := models_base.DecodeTime(avpValue)
			if err == nil {
				v := val.(models_base.Time)
				m.EventTimestamp = &v
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AccountingRequest message
func (m *AccountingRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AccountingRequest
func (m *AccountingRequest) String() string {
	return fmt.Sprintf("AccountingRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, AccountingRecordType:%v, AccountingRecordNumber:%v, AcctApplicationId:%v, VendorSpecificApplicationId:%v, UserName:%v, DestinationHost:%v, AccountingSubSessionId:%v, AcctSessionId:%v, AcctMultiSessionId:%v, AcctInterimInterval:%v, AccountingRealtimeRequired:%v, OriginStateId:%v, EventTimestamp:%v, ProxyInfo:%v, RouteRecord:%v, Avp:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.AccountingRecordType, m.AccountingRecordNumber, m.AcctApplicationId, m.VendorSpecificApplicationId, m.UserName, m.DestinationHost, m.AccountingSubSessionId, m.AcctSessionId, m.AcctMultiSessionId, m.AcctInterimInterval, m.AccountingRealtimeRequired, m.OriginStateId, m.EventTimestamp, m.ProxyInfo, m.RouteRecord, m.Avp)
}

// AccountingAnswer represents the Accounting-Answer (AA) Diameter command
// Command Code: 271, Application ID: 3
type AccountingAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String        // Required
	ResultCode                  models_base.Unsigned32        // Required
	OriginHost                  models_base.DiameterIdentity  // Required
	OriginRealm                 models_base.DiameterIdentity  // Required
	AccountingRecordType        models_base.Enumerated        // Required
	AccountingRecordNumber      models_base.Unsigned32        // Required
	AcctApplicationId           *models_base.Unsigned32       // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId  // Optional
	UserName                    *models_base.UTF8String       // Optional
	AcctInterimInterval         *models_base.Unsigned32       // Optional
	AccountingRealtimeRequired  *models_base.Enumerated       // Optional
	OriginStateId               *models_base.Unsigned32       // Optional
	EventTimestamp              *models_base.Time             // Optional
	ErrorMessage                *models_base.UTF8String       // Optional
	ErrorReportingHost          *models_base.DiameterIdentity // Optional
	FailedAvp                   *FailedAVP                    // Optional
	ProxyInfo                   []*ProxyInfo                  // Optional
	Avp                         []models_base.OctetString     // Optional - WARNING: AVP code not defined, DO NOT USE
}

// NewAccountingAnswer creates a new AA message
func NewAccountingAnswer() *AccountingAnswer {
	return &AccountingAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   271,
			ApplicationID: 3,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AccountingAnswer
func (m *AccountingAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the AccountingAnswer to bytes using a buffer for optimal performance
func (m *AccountingAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal AccountingRecordType (required)
	buf.Write(marshalAVP(480, m.AccountingRecordType, true, false))

	// Marshal AccountingRecordNumber (required)
	buf.Write(marshalAVP(485, m.AccountingRecordNumber, true, false))

	// Marshal AcctApplicationId (optional)
	if m.AcctApplicationId != nil {
		buf.Write(marshalAVP(259, *m.AcctApplicationId, true, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(260, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, true, true))
	}

	// Marshal AcctInterimInterval (optional)
	if m.AcctInterimInterval != nil {
		buf.Write(marshalAVP(85, *m.AcctInterimInterval, true, false))
	}

	// Marshal AccountingRealtimeRequired (optional)
	if m.AccountingRealtimeRequired != nil {
		buf.Write(marshalAVP(483, *m.AccountingRealtimeRequired, true, false))
	}

	// Marshal OriginStateId (optional)
	if m.OriginStateId != nil {
		buf.Write(marshalAVP(278, *m.OriginStateId, false, false))
	}

	// Marshal EventTimestamp (optional)
	if m.EventTimestamp != nil {
		buf.Write(marshalAVP(55, *m.EventTimestamp, true, false))
	}

	// Marshal ErrorMessage (optional)
	if m.ErrorMessage != nil {
		buf.Write(marshalAVP(281, *m.ErrorMessage, false, false))
	}

	// Marshal ErrorReportingHost (optional)
	if m.ErrorReportingHost != nil {
		buf.Write(marshalAVP(294, *m.ErrorReportingHost, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AccountingAnswer
func (m *AccountingAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 480: // Accounting-Record-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AccountingRecordType = val.(models_base.Enumerated)
			}
		case 485: // Accounting-Record-Number
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AccountingRecordNumber = val.(models_base.Unsigned32)
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.AcctApplicationId = &v
			}
		case 260: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 85: // Acct-Interim-Interval
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.AcctInterimInterval = &v
			}
		case 483: // Accounting-Realtime-Required
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.AccountingRealtimeRequired = &v
			}
		case 278: // Origin-State-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.OriginStateId = &v
			}
		case 55: // Event-Timestamp
			val, err := models_base.DecodeTime(avpValue)
			if err == nil {
				v := val.(models_base.Time)
				m.EventTimestamp = &v
			}
		case 281: // Error-Message
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ErrorMessage = &v
			}
		case 294: // Error-Reporting-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.ErrorReportingHost = &v
			}
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
			// case 0: // AVP (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AccountingAnswer message
func (m *AccountingAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AccountingAnswer
func (m *AccountingAnswer) String() string {
	return fmt.Sprintf("AccountingAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v, AccountingRecordType:%v, AccountingRecordNumber:%v, AcctApplicationId:%v, VendorSpecificApplicationId:%v, UserName:%v, AcctInterimInterval:%v, AccountingRealtimeRequired:%v, OriginStateId:%v, EventTimestamp:%v, ErrorMessage:%v, ErrorReportingHost:%v, FailedAvp:%v, ProxyInfo:%v, Avp:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm, m.AccountingRecordType, m.AccountingRecordNumber, m.AcctApplicationId, m.VendorSpecificApplicationId, m.UserName, m.AcctInterimInterval, m.AccountingRealtimeRequired, m.OriginStateId, m.EventTimestamp, m.ErrorMessage, m.ErrorReportingHost, m.FailedAvp, m.ProxyInfo, m.Avp)
}

// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// marshalAVPWithVendor serializes an AVP with optional vendor ID
func marshalAVPWithVendor(code uint32, data models_base.Type, mandatory, protected bool, vendorID uint32) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Determine if we need vendor ID in header
	hasVendor := vendorID != 0

	// Calculate header size
	headerSize := 8
	if hasVendor {
		headerSize = 12 // With vendor ID
	}

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if hasVendor {
		flags |= 0x80 // V-bit
	}
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Vendor ID (if needed)
	if hasVendor {
		binary.BigEndian.PutUint32(buf[8:12], vendorID)
	}

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// Pointer helper functions for grouped AVP field assignments in tests
func ptrUTF8String(s string) *models_base.UTF8String {
	v := models_base.UTF8String(s)
	return &v
}

func ptrOctetString(b []byte) *models_base.OctetString {
	v := models_base.OctetString(b)
	return &v
}

func ptrUnsigned32(u uint32) *models_base.Unsigned32 {
	v := models_base.Unsigned32(u)
	return &v
}

func ptrUnsigned64(u uint64) *models_base.Unsigned64 {
	v := models_base.Unsigned64(u)
	return &v
}

func ptrEnumerated(e uint32) *models_base.Enumerated {
	v := models_base.Enumerated(e)
	return &v
}

func ptrDiameterIdentity(d string) *models_base.DiameterIdentity {
	v := models_base.DiameterIdentity(d)
	return &v
}

func ptrAddress(a models_base.Address) *models_base.Address {
	return &a
}

func ptrTime(t models_base.Time) *models_base.Time {
	return &t
}

func ptrFloat32(f float32) *models_base.Float32 {
	v := models_base.Float32(f)
	return &v
}

func ptrFloat64(f float64) *models_base.Float64 {
	v := models_base.Float64(f)
	return &v
}
