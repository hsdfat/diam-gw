// Code generated by diameter-codegen. DO NOT EDIT.

package base

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/hsdfat8/diam-gw/models_base"
)

// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

// AVP Codes
const (
	AVPCodeORIGINSTATEID               uint32 = 278
	AVPCodeSUPPORTEDVENDORID           uint32 = 265
	AVPCodeFAILEDAVP                   uint32 = 279
	AVPCodeDISCONNECTCAUSE             uint32 = 273
	AVPCodeTERMINATIONCAUSE            uint32 = 295
	AVPCodeINBANDSECURITYID            uint32 = 299
	AVPCodeFIRMWAREREVISION            uint32 = 267
	AVPCodeUSERNAME                    uint32 = 1
	AVPCodeERRORMESSAGE                uint32 = 281
	AVPCodeHOSTIPADDRESS               uint32 = 257
	AVPCodeVENDORID                    uint32 = 266
	AVPCodePRODUCTNAME                 uint32 = 269
	AVPCodeAUTHAPPLICATIONID           uint32 = 258
	AVPCodeACCTAPPLICATIONID           uint32 = 259
	AVPCodeVENDORSPECIFICAPPLICATIONID uint32 = 260
	AVPCodeSESSIONID                   uint32 = 263
	AVPCodeORIGINHOST                  uint32 = 264
	AVPCodeORIGINREALM                 uint32 = 296
	AVPCodeDESTINATIONREALM            uint32 = 283
	AVPCodeDESTINATIONHOST             uint32 = 293
	AVPCodeREAUTHREQUESTTYPE           uint32 = 285
	AVPCodeACCOUNTINGRECORDTYPE        uint32 = 480
	AVPCodeACCOUNTINGRECORDNUMBER      uint32 = 485
	AVPCodeRESULTCODE                  uint32 = 268
)

// Command Codes
const (
	CommandCodeCAPABILITIESEXCHANGEREQUEST uint32 = 257
	CommandCodeCAPABILITIESEXCHANGEANSWER  uint32 = 257
	CommandCodeDEVICEWATCHDOGREQUEST       uint32 = 280
	CommandCodeDEVICEWATCHDOGANSWER        uint32 = 280
	CommandCodeDISCONNECTPEERREQUEST       uint32 = 282
	CommandCodeDISCONNECTPEERANSWER        uint32 = 282
	CommandCodeREAUTHREQUEST               uint32 = 258
	CommandCodeREAUTHANSWER                uint32 = 258
	CommandCodeSESSIONTERMINATIONREQUEST   uint32 = 275
	CommandCodeSESSIONTERMINATIONANSWER    uint32 = 275
	CommandCodeABORTSESSIONREQUEST         uint32 = 274
	CommandCodeABORTSESSIONANSWER          uint32 = 274
	CommandCodeACCOUNTINGREQUEST           uint32 = 271
	CommandCodeACCOUNTINGANSWER            uint32 = 271
)

// CapabilitiesExchangeRequest represents the Capabilities-Exchange-Request (CER) Diameter command
// Command Code: 257, Application ID: 0
type CapabilitiesExchangeRequest struct {
	Header DiameterHeader

	OriginHost                  models_base.DiameterIdentity // Required
	OriginRealm                 models_base.DiameterIdentity // Required
	HostIpAddress               []models_base.Address        // Required
	VendorId                    models_base.Unsigned32       // Required
	ProductName                 models_base.UTF8String       // Required
	SupportedVendorId           []models_base.Unsigned32     // Optional
	AuthApplicationId           []models_base.Unsigned32     // Optional
	InbandSecurityId            []models_base.Unsigned32     // Optional
	AcctApplicationId           []models_base.Unsigned32     // Optional
	VendorSpecificApplicationId []models_base.Grouped        // Optional
}

// NewCapabilitiesExchangeRequest creates a new CER message
func NewCapabilitiesExchangeRequest() *CapabilitiesExchangeRequest {
	return &CapabilitiesExchangeRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   257,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in CapabilitiesExchangeRequest
func (m *CapabilitiesExchangeRequest) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if len(m.HostIpAddress) == 0 {
		return fmt.Errorf("required repeated field Host-IP-Address is empty")
	}
	if m.ProductName == "" {
		return fmt.Errorf("required field Product-Name is empty")
	}

	return nil
}

// Marshal serializes the CapabilitiesExchangeRequest to bytes using a buffer for optimal performance
func (m *CapabilitiesExchangeRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal HostIpAddress (repeated)
	for _, v := range m.HostIpAddress {
		buf.Write(marshalAVP(257, v, true, false))
	}

	// Marshal VendorId (required)
	buf.Write(marshalAVP(266, m.VendorId, true, false))

	// Marshal ProductName (required)
	buf.Write(marshalAVP(269, m.ProductName, false, false))

	// Marshal SupportedVendorId (repeated)
	for _, v := range m.SupportedVendorId {
		buf.Write(marshalAVP(265, v, false, false))
	}

	// Marshal AuthApplicationId (repeated)
	for _, v := range m.AuthApplicationId {
		buf.Write(marshalAVP(258, v, false, false))
	}

	// Marshal InbandSecurityId (repeated)
	for _, v := range m.InbandSecurityId {
		buf.Write(marshalAVP(299, v, false, false))
	}

	// Marshal AcctApplicationId (repeated)
	for _, v := range m.AcctApplicationId {
		buf.Write(marshalAVP(259, v, false, false))
	}

	// Marshal VendorSpecificApplicationId (repeated)
	for _, v := range m.VendorSpecificApplicationId {
		buf.Write(marshalAVP(260, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CapabilitiesExchangeRequest
func (m *CapabilitiesExchangeRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 257: // Host-IP-Address
			val, err := models_base.DecodeAddress(avpValue)
			if err == nil {
				m.HostIpAddress = append(m.HostIpAddress, val.(models_base.Address))
			}
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.VendorId = val.(models_base.Unsigned32)
			}
		case 269: // Product-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.ProductName = val.(models_base.UTF8String)
			}
		case 265: // Supported-Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.SupportedVendorId = append(m.SupportedVendorId, val.(models_base.Unsigned32))
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = append(m.AuthApplicationId, val.(models_base.Unsigned32))
			}
		case 299: // Inband-Security-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.InbandSecurityId = append(m.InbandSecurityId, val.(models_base.Unsigned32))
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AcctApplicationId = append(m.AcctApplicationId, val.(models_base.Unsigned32))
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.VendorSpecificApplicationId = append(m.VendorSpecificApplicationId, val.(models_base.Grouped))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CapabilitiesExchangeRequest message
func (m *CapabilitiesExchangeRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CapabilitiesExchangeRequest
func (m *CapabilitiesExchangeRequest) String() string {
	return fmt.Sprintf("CapabilitiesExchangeRequest{OriginHost:%v, OriginRealm:%v, HostIpAddress:%v, VendorId:%v, ProductName:%v, SupportedVendorId:%v, AuthApplicationId:%v, InbandSecurityId:%v, AcctApplicationId:%v, VendorSpecificApplicationId:%v}", m.OriginHost, m.OriginRealm, m.HostIpAddress, m.VendorId, m.ProductName, m.SupportedVendorId, m.AuthApplicationId, m.InbandSecurityId, m.AcctApplicationId, m.VendorSpecificApplicationId)
}

// CapabilitiesExchangeAnswer represents the Capabilities-Exchange-Answer (CEA) Diameter command
// Command Code: 257, Application ID: 0
type CapabilitiesExchangeAnswer struct {
	Header DiameterHeader

	ResultCode                  models_base.Unsigned32       // Required
	OriginHost                  models_base.DiameterIdentity // Required
	OriginRealm                 models_base.DiameterIdentity // Required
	HostIpAddress               []models_base.Address        // Required
	VendorId                    models_base.Unsigned32       // Required
	ProductName                 models_base.UTF8String       // Required
	SupportedVendorId           []models_base.Unsigned32     // Optional
	AuthApplicationId           []models_base.Unsigned32     // Optional
	InbandSecurityId            []models_base.Unsigned32     // Optional
	AcctApplicationId           []models_base.Unsigned32     // Optional
	VendorSpecificApplicationId []models_base.Grouped        // Optional
}

// NewCapabilitiesExchangeAnswer creates a new CEA message
func NewCapabilitiesExchangeAnswer() *CapabilitiesExchangeAnswer {
	return &CapabilitiesExchangeAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   257,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in CapabilitiesExchangeAnswer
func (m *CapabilitiesExchangeAnswer) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if len(m.HostIpAddress) == 0 {
		return fmt.Errorf("required repeated field Host-IP-Address is empty")
	}
	if m.ProductName == "" {
		return fmt.Errorf("required field Product-Name is empty")
	}

	return nil
}

// Marshal serializes the CapabilitiesExchangeAnswer to bytes using a buffer for optimal performance
func (m *CapabilitiesExchangeAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal HostIpAddress (repeated)
	for _, v := range m.HostIpAddress {
		buf.Write(marshalAVP(257, v, true, false))
	}

	// Marshal VendorId (required)
	buf.Write(marshalAVP(266, m.VendorId, true, false))

	// Marshal ProductName (required)
	buf.Write(marshalAVP(269, m.ProductName, false, false))

	// Marshal SupportedVendorId (repeated)
	for _, v := range m.SupportedVendorId {
		buf.Write(marshalAVP(265, v, false, false))
	}

	// Marshal AuthApplicationId (repeated)
	for _, v := range m.AuthApplicationId {
		buf.Write(marshalAVP(258, v, false, false))
	}

	// Marshal InbandSecurityId (repeated)
	for _, v := range m.InbandSecurityId {
		buf.Write(marshalAVP(299, v, false, false))
	}

	// Marshal AcctApplicationId (repeated)
	for _, v := range m.AcctApplicationId {
		buf.Write(marshalAVP(259, v, false, false))
	}

	// Marshal VendorSpecificApplicationId (repeated)
	for _, v := range m.VendorSpecificApplicationId {
		buf.Write(marshalAVP(260, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CapabilitiesExchangeAnswer
func (m *CapabilitiesExchangeAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 257: // Host-IP-Address
			val, err := models_base.DecodeAddress(avpValue)
			if err == nil {
				m.HostIpAddress = append(m.HostIpAddress, val.(models_base.Address))
			}
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.VendorId = val.(models_base.Unsigned32)
			}
		case 269: // Product-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.ProductName = val.(models_base.UTF8String)
			}
		case 265: // Supported-Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.SupportedVendorId = append(m.SupportedVendorId, val.(models_base.Unsigned32))
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = append(m.AuthApplicationId, val.(models_base.Unsigned32))
			}
		case 299: // Inband-Security-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.InbandSecurityId = append(m.InbandSecurityId, val.(models_base.Unsigned32))
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AcctApplicationId = append(m.AcctApplicationId, val.(models_base.Unsigned32))
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.VendorSpecificApplicationId = append(m.VendorSpecificApplicationId, val.(models_base.Grouped))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CapabilitiesExchangeAnswer message
func (m *CapabilitiesExchangeAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CapabilitiesExchangeAnswer
func (m *CapabilitiesExchangeAnswer) String() string {
	return fmt.Sprintf("CapabilitiesExchangeAnswer{ResultCode:%v, OriginHost:%v, OriginRealm:%v, HostIpAddress:%v, VendorId:%v, ProductName:%v, SupportedVendorId:%v, AuthApplicationId:%v, InbandSecurityId:%v, AcctApplicationId:%v, VendorSpecificApplicationId:%v}", m.ResultCode, m.OriginHost, m.OriginRealm, m.HostIpAddress, m.VendorId, m.ProductName, m.SupportedVendorId, m.AuthApplicationId, m.InbandSecurityId, m.AcctApplicationId, m.VendorSpecificApplicationId)
}

// DeviceWatchdogRequest represents the Device-Watchdog-Request (DWR) Diameter command
// Command Code: 280, Application ID: 0
type DeviceWatchdogRequest struct {
	Header DiameterHeader

	OriginHost  models_base.DiameterIdentity // Required
	OriginRealm models_base.DiameterIdentity // Required
}

// NewDeviceWatchdogRequest creates a new DWR message
func NewDeviceWatchdogRequest() *DeviceWatchdogRequest {
	return &DeviceWatchdogRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   280,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DeviceWatchdogRequest
func (m *DeviceWatchdogRequest) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DeviceWatchdogRequest to bytes using a buffer for optimal performance
func (m *DeviceWatchdogRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeviceWatchdogRequest
func (m *DeviceWatchdogRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeviceWatchdogRequest message
func (m *DeviceWatchdogRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeviceWatchdogRequest
func (m *DeviceWatchdogRequest) String() string {
	return fmt.Sprintf("DeviceWatchdogRequest{OriginHost:%v, OriginRealm:%v}", m.OriginHost, m.OriginRealm)
}

// DeviceWatchdogAnswer represents the Device-Watchdog-Answer (DWA) Diameter command
// Command Code: 280, Application ID: 0
type DeviceWatchdogAnswer struct {
	Header DiameterHeader

	ResultCode  models_base.Unsigned32       // Required
	OriginHost  models_base.DiameterIdentity // Required
	OriginRealm models_base.DiameterIdentity // Required
}

// NewDeviceWatchdogAnswer creates a new DWA message
func NewDeviceWatchdogAnswer() *DeviceWatchdogAnswer {
	return &DeviceWatchdogAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   280,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DeviceWatchdogAnswer
func (m *DeviceWatchdogAnswer) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DeviceWatchdogAnswer to bytes using a buffer for optimal performance
func (m *DeviceWatchdogAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeviceWatchdogAnswer
func (m *DeviceWatchdogAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeviceWatchdogAnswer message
func (m *DeviceWatchdogAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeviceWatchdogAnswer
func (m *DeviceWatchdogAnswer) String() string {
	return fmt.Sprintf("DeviceWatchdogAnswer{ResultCode:%v, OriginHost:%v, OriginRealm:%v}", m.ResultCode, m.OriginHost, m.OriginRealm)
}

// DisconnectPeerRequest represents the Disconnect-Peer-Request (DPR) Diameter command
// Command Code: 282, Application ID: 0
type DisconnectPeerRequest struct {
	Header DiameterHeader

	OriginHost      models_base.DiameterIdentity // Required
	OriginRealm     models_base.DiameterIdentity // Required
	DisconnectCause models_base.Enumerated       // Required
}

// NewDisconnectPeerRequest creates a new DPR message
func NewDisconnectPeerRequest() *DisconnectPeerRequest {
	return &DisconnectPeerRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   282,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DisconnectPeerRequest
func (m *DisconnectPeerRequest) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DisconnectPeerRequest to bytes using a buffer for optimal performance
func (m *DisconnectPeerRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DisconnectCause (required)
	buf.Write(marshalAVP(273, m.DisconnectCause, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DisconnectPeerRequest
func (m *DisconnectPeerRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 273: // Disconnect-Cause
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.DisconnectCause = val.(models_base.Enumerated)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DisconnectPeerRequest message
func (m *DisconnectPeerRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DisconnectPeerRequest
func (m *DisconnectPeerRequest) String() string {
	return fmt.Sprintf("DisconnectPeerRequest{OriginHost:%v, OriginRealm:%v, DisconnectCause:%v}", m.OriginHost, m.OriginRealm, m.DisconnectCause)
}

// DisconnectPeerAnswer represents the Disconnect-Peer-Answer (DPA) Diameter command
// Command Code: 282, Application ID: 0
type DisconnectPeerAnswer struct {
	Header DiameterHeader

	ResultCode  models_base.Unsigned32       // Required
	OriginHost  models_base.DiameterIdentity // Required
	OriginRealm models_base.DiameterIdentity // Required
}

// NewDisconnectPeerAnswer creates a new DPA message
func NewDisconnectPeerAnswer() *DisconnectPeerAnswer {
	return &DisconnectPeerAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   282,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: false,
			},
		},
	}
}

// Validate checks if all required fields are set in DisconnectPeerAnswer
func (m *DisconnectPeerAnswer) Validate() error {
	// Validate required fields
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DisconnectPeerAnswer to bytes using a buffer for optimal performance
func (m *DisconnectPeerAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DisconnectPeerAnswer
func (m *DisconnectPeerAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DisconnectPeerAnswer message
func (m *DisconnectPeerAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DisconnectPeerAnswer
func (m *DisconnectPeerAnswer) String() string {
	return fmt.Sprintf("DisconnectPeerAnswer{ResultCode:%v, OriginHost:%v, OriginRealm:%v}", m.ResultCode, m.OriginHost, m.OriginRealm)
}

// ReAuthRequest represents the Re-Auth-Request (RAR) Diameter command
// Command Code: 258, Application ID: 0
type ReAuthRequest struct {
	Header DiameterHeader

	SessionId         models_base.UTF8String       // Required
	OriginHost        models_base.DiameterIdentity // Required
	OriginRealm       models_base.DiameterIdentity // Required
	DestinationRealm  models_base.DiameterIdentity // Required
	DestinationHost   models_base.DiameterIdentity // Required
	AuthApplicationId models_base.Unsigned32       // Required
	ReAuthRequestType models_base.Enumerated       // Required
}

// NewReAuthRequest creates a new RAR message
func NewReAuthRequest() *ReAuthRequest {
	return &ReAuthRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   258,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ReAuthRequest
func (m *ReAuthRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}

	return nil
}

// Marshal serializes the ReAuthRequest to bytes using a buffer for optimal performance
func (m *ReAuthRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, false, false))

	// Marshal AuthApplicationId (required)
	buf.Write(marshalAVP(258, m.AuthApplicationId, false, false))

	// Marshal ReAuthRequestType (required)
	buf.Write(marshalAVP(285, m.ReAuthRequestType, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ReAuthRequest
func (m *ReAuthRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = val.(models_base.Unsigned32)
			}
		case 285: // Re-Auth-Request-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.ReAuthRequestType = val.(models_base.Enumerated)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ReAuthRequest message
func (m *ReAuthRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ReAuthRequest
func (m *ReAuthRequest) String() string {
	return fmt.Sprintf("ReAuthRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, DestinationHost:%v, AuthApplicationId:%v, ReAuthRequestType:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.DestinationHost, m.AuthApplicationId, m.ReAuthRequestType)
}

// ReAuthAnswer represents the Re-Auth-Answer (RAA) Diameter command
// Command Code: 258, Application ID: 0
type ReAuthAnswer struct {
	Header DiameterHeader

	SessionId   models_base.UTF8String       // Required
	ResultCode  models_base.Unsigned32       // Required
	OriginHost  models_base.DiameterIdentity // Required
	OriginRealm models_base.DiameterIdentity // Required
}

// NewReAuthAnswer creates a new RAA message
func NewReAuthAnswer() *ReAuthAnswer {
	return &ReAuthAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   258,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ReAuthAnswer
func (m *ReAuthAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the ReAuthAnswer to bytes using a buffer for optimal performance
func (m *ReAuthAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ReAuthAnswer
func (m *ReAuthAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ReAuthAnswer message
func (m *ReAuthAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ReAuthAnswer
func (m *ReAuthAnswer) String() string {
	return fmt.Sprintf("ReAuthAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm)
}

// SessionTerminationRequest represents the Session-Termination-Request (STR) Diameter command
// Command Code: 275, Application ID: 0
type SessionTerminationRequest struct {
	Header DiameterHeader

	SessionId         models_base.UTF8String       // Required
	OriginHost        models_base.DiameterIdentity // Required
	OriginRealm       models_base.DiameterIdentity // Required
	DestinationRealm  models_base.DiameterIdentity // Required
	AuthApplicationId models_base.Unsigned32       // Required
	TerminationCause  models_base.Enumerated       // Required
}

// NewSessionTerminationRequest creates a new STR message
func NewSessionTerminationRequest() *SessionTerminationRequest {
	return &SessionTerminationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   275,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in SessionTerminationRequest
func (m *SessionTerminationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}

	return nil
}

// Marshal serializes the SessionTerminationRequest to bytes using a buffer for optimal performance
func (m *SessionTerminationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal AuthApplicationId (required)
	buf.Write(marshalAVP(258, m.AuthApplicationId, false, false))

	// Marshal TerminationCause (required)
	buf.Write(marshalAVP(295, m.TerminationCause, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into SessionTerminationRequest
func (m *SessionTerminationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = val.(models_base.Unsigned32)
			}
		case 295: // Termination-Cause
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.TerminationCause = val.(models_base.Enumerated)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the SessionTerminationRequest message
func (m *SessionTerminationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of SessionTerminationRequest
func (m *SessionTerminationRequest) String() string {
	return fmt.Sprintf("SessionTerminationRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, AuthApplicationId:%v, TerminationCause:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.AuthApplicationId, m.TerminationCause)
}

// SessionTerminationAnswer represents the Session-Termination-Answer (STA) Diameter command
// Command Code: 275, Application ID: 0
type SessionTerminationAnswer struct {
	Header DiameterHeader

	SessionId   models_base.UTF8String       // Required
	ResultCode  models_base.Unsigned32       // Required
	OriginHost  models_base.DiameterIdentity // Required
	OriginRealm models_base.DiameterIdentity // Required
}

// NewSessionTerminationAnswer creates a new STA message
func NewSessionTerminationAnswer() *SessionTerminationAnswer {
	return &SessionTerminationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   275,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in SessionTerminationAnswer
func (m *SessionTerminationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the SessionTerminationAnswer to bytes using a buffer for optimal performance
func (m *SessionTerminationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into SessionTerminationAnswer
func (m *SessionTerminationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the SessionTerminationAnswer message
func (m *SessionTerminationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of SessionTerminationAnswer
func (m *SessionTerminationAnswer) String() string {
	return fmt.Sprintf("SessionTerminationAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm)
}

// AbortSessionRequest represents the Abort-Session-Request (ASR) Diameter command
// Command Code: 274, Application ID: 0
type AbortSessionRequest struct {
	Header DiameterHeader

	SessionId         models_base.UTF8String       // Required
	OriginHost        models_base.DiameterIdentity // Required
	OriginRealm       models_base.DiameterIdentity // Required
	DestinationRealm  models_base.DiameterIdentity // Required
	DestinationHost   models_base.DiameterIdentity // Required
	AuthApplicationId models_base.Unsigned32       // Required
}

// NewAbortSessionRequest creates a new ASR message
func NewAbortSessionRequest() *AbortSessionRequest {
	return &AbortSessionRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   274,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AbortSessionRequest
func (m *AbortSessionRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}

	return nil
}

// Marshal serializes the AbortSessionRequest to bytes using a buffer for optimal performance
func (m *AbortSessionRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, false, false))

	// Marshal AuthApplicationId (required)
	buf.Write(marshalAVP(258, m.AuthApplicationId, false, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AbortSessionRequest
func (m *AbortSessionRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AuthApplicationId = val.(models_base.Unsigned32)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AbortSessionRequest message
func (m *AbortSessionRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AbortSessionRequest
func (m *AbortSessionRequest) String() string {
	return fmt.Sprintf("AbortSessionRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, DestinationHost:%v, AuthApplicationId:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.DestinationHost, m.AuthApplicationId)
}

// AbortSessionAnswer represents the Abort-Session-Answer (ASA) Diameter command
// Command Code: 274, Application ID: 0
type AbortSessionAnswer struct {
	Header DiameterHeader

	SessionId   models_base.UTF8String       // Required
	ResultCode  models_base.Unsigned32       // Required
	OriginHost  models_base.DiameterIdentity // Required
	OriginRealm models_base.DiameterIdentity // Required
}

// NewAbortSessionAnswer creates a new ASA message
func NewAbortSessionAnswer() *AbortSessionAnswer {
	return &AbortSessionAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   274,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AbortSessionAnswer
func (m *AbortSessionAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the AbortSessionAnswer to bytes using a buffer for optimal performance
func (m *AbortSessionAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AbortSessionAnswer
func (m *AbortSessionAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AbortSessionAnswer message
func (m *AbortSessionAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AbortSessionAnswer
func (m *AbortSessionAnswer) String() string {
	return fmt.Sprintf("AbortSessionAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm)
}

// AccountingRequest represents the Accounting-Request (AR) Diameter command
// Command Code: 271, Application ID: 0
type AccountingRequest struct {
	Header DiameterHeader

	SessionId              models_base.UTF8String       // Required
	OriginHost             models_base.DiameterIdentity // Required
	OriginRealm            models_base.DiameterIdentity // Required
	DestinationRealm       models_base.DiameterIdentity // Required
	AccountingRecordType   models_base.Enumerated       // Required
	AccountingRecordNumber models_base.Unsigned32       // Required
}

// NewAccountingRequest creates a new AR message
func NewAccountingRequest() *AccountingRequest {
	return &AccountingRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   271,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AccountingRequest
func (m *AccountingRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}

	return nil
}

// Marshal serializes the AccountingRequest to bytes using a buffer for optimal performance
func (m *AccountingRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal AccountingRecordType (required)
	buf.Write(marshalAVP(480, m.AccountingRecordType, true, false))

	// Marshal AccountingRecordNumber (required)
	buf.Write(marshalAVP(485, m.AccountingRecordNumber, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AccountingRequest
func (m *AccountingRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 480: // Accounting-Record-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AccountingRecordType = val.(models_base.Enumerated)
			}
		case 485: // Accounting-Record-Number
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AccountingRecordNumber = val.(models_base.Unsigned32)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AccountingRequest message
func (m *AccountingRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AccountingRequest
func (m *AccountingRequest) String() string {
	return fmt.Sprintf("AccountingRequest{SessionId:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, AccountingRecordType:%v, AccountingRecordNumber:%v}", m.SessionId, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.AccountingRecordType, m.AccountingRecordNumber)
}

// AccountingAnswer represents the Accounting-Answer (AA) Diameter command
// Command Code: 271, Application ID: 0
type AccountingAnswer struct {
	Header DiameterHeader

	SessionId              models_base.UTF8String       // Required
	ResultCode             models_base.Unsigned32       // Required
	OriginHost             models_base.DiameterIdentity // Required
	OriginRealm            models_base.DiameterIdentity // Required
	AccountingRecordType   models_base.Enumerated       // Required
	AccountingRecordNumber models_base.Unsigned32       // Required
}

// NewAccountingAnswer creates a new AA message
func NewAccountingAnswer() *AccountingAnswer {
	return &AccountingAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   271,
			ApplicationID: 0,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AccountingAnswer
func (m *AccountingAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the AccountingAnswer to bytes using a buffer for optimal performance
func (m *AccountingAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal ResultCode (required)
	buf.Write(marshalAVP(268, m.ResultCode, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal AccountingRecordType (required)
	buf.Write(marshalAVP(480, m.AccountingRecordType, true, false))

	// Marshal AccountingRecordNumber (required)
	buf.Write(marshalAVP(485, m.AccountingRecordNumber, true, false))

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AccountingAnswer
func (m *AccountingAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ResultCode = val.(models_base.Unsigned32)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 480: // Accounting-Record-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AccountingRecordType = val.(models_base.Enumerated)
			}
		case 485: // Accounting-Record-Number
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.AccountingRecordNumber = val.(models_base.Unsigned32)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AccountingAnswer message
func (m *AccountingAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AccountingAnswer
func (m *AccountingAnswer) String() string {
	return fmt.Sprintf("AccountingAnswer{SessionId:%v, ResultCode:%v, OriginHost:%v, OriginRealm:%v, AccountingRecordType:%v, AccountingRecordNumber:%v}", m.SessionId, m.ResultCode, m.OriginHost, m.OriginRealm, m.AccountingRecordType, m.AccountingRecordNumber)
}

// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}
