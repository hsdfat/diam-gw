// Code generated by diameter-codegen. DO NOT EDIT.

package s13

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/hsdfat8/diam-gw/models_base"
)

// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

// AVP Codes
const (
	AVPCodeSOFTWAREVERSION             uint32 = 1403
	AVPCode3GPP2MEID                   uint32 = 1471
	AVPCodeSESSIONID                   uint32 = 263
	AVPCodeAUTHSESSIONSTATE            uint32 = 277
	AVPCodeORIGINREALM                 uint32 = 296
	AVPCodeTERMINALINFORMATION         uint32 = 1401
	AVPCodeIMEI                        uint32 = 1402
	AVPCodeEXPERIMENTALRESULT          uint32 = 297
	AVPCodeEXPERIMENTALRESULTCODE      uint32 = 298
	AVPCodeDESTINATIONHOST             uint32 = 293
	AVPCodeUSERNAME                    uint32 = 1
	AVPCodePROXYINFO                   uint32 = 284
	AVPCodeROUTERECORD                 uint32 = 282
	AVPCodeORIGINHOST                  uint32 = 264
	AVPCodeEQUIPMENTSTATUS             uint32 = 1445
	AVPCodeDRMP                        uint32 = 301
	AVPCodeSUPPORTEDFEATURES           uint32 = 628
	AVPCodeFEATURELISTID               uint32 = 629
	AVPCodeVENDORSPECIFICAPPLICATIONID uint32 = 260
	AVPCodeFAILEDAVP                   uint32 = 279
	AVPCodeFEATURELIST                 uint32 = 630
	AVPCodeDESTINATIONREALM            uint32 = 283
	AVPCodeRESULTCODE                  uint32 = 268
)

// Command Codes
const (
	CommandCodeMEIDENTITYCHECKREQUEST uint32 = 324
	CommandCodeMEIDENTITYCHECKANSWER  uint32 = 324
)

// MEIdentityCheckRequest represents the ME-Identity-Check-Request (MICR) Diameter command
// Command Code: 324, Application ID: 16777252
type MEIdentityCheckRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             *models_base.DiameterIdentity  // Optional
	DestinationRealm            models_base.DiameterIdentity   // Required
	TerminalInformation         models_base.Grouped            // Required
	UserName                    *models_base.UTF8String        // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewMEIdentityCheckRequest creates a new MICR message
func NewMEIdentityCheckRequest() *MEIdentityCheckRequest {
	return &MEIdentityCheckRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   324,
			ApplicationID: 16777252,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in MEIdentityCheckRequest
func (m *MEIdentityCheckRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}

	return nil
}

// Marshal serializes the MEIdentityCheckRequest to bytes using a buffer for optimal performance
func (m *MEIdentityCheckRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, false, false))
	}

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal TerminalInformation (required)
	buf.Write(marshalAVP(1401, m.TerminalInformation, true, false))

	// Marshal UserName (optional)
	if m.UserName != nil {
		buf.Write(marshalAVP(1, *m.UserName, false, true))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into MEIdentityCheckRequest
func (m *MEIdentityCheckRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1401: // Terminal-Information
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.TerminalInformation = val.(models_base.Grouped)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.UserName = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the MEIdentityCheckRequest message
func (m *MEIdentityCheckRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of MEIdentityCheckRequest
func (m *MEIdentityCheckRequest) String() string {
	return fmt.Sprintf("MEIdentityCheckRequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, TerminalInformation:%v, UserName:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.TerminalInformation, m.UserName, m.ProxyInfo, m.RouteRecord)
}

// MEIdentityCheckAnswer represents the ME-Identity-Check-Answer (MICA) Diameter command
// Command Code: 324, Application ID: 16777252
type MEIdentityCheckAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	EquipmentStatus             *models_base.Enumerated        // Optional
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewMEIdentityCheckAnswer creates a new MICA message
func NewMEIdentityCheckAnswer() *MEIdentityCheckAnswer {
	return &MEIdentityCheckAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   324,
			ApplicationID: 16777252,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in MEIdentityCheckAnswer
func (m *MEIdentityCheckAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the MEIdentityCheckAnswer to bytes using a buffer for optimal performance
func (m *MEIdentityCheckAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal EquipmentStatus (optional)
	if m.EquipmentStatus != nil {
		buf.Write(marshalAVP(1445, *m.EquipmentStatus, true, false))
	}

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into MEIdentityCheckAnswer
func (m *MEIdentityCheckAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 1445: // Equipment-Status
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.EquipmentStatus = &v
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the MEIdentityCheckAnswer message
func (m *MEIdentityCheckAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of MEIdentityCheckAnswer
func (m *MEIdentityCheckAnswer) String() string {
	return fmt.Sprintf("MEIdentityCheckAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, ResultCode:%v, ExperimentalResult:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, EquipmentStatus:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.ResultCode, m.ExperimentalResult, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.EquipmentStatus, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}
