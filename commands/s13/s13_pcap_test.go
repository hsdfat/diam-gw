// Code generated by diameter-codegen. DO NOT EDIT.

package s13

import (
	"net"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcapgo"
	"github.com/hsdfat8/diam-gw/models_base"
)

// writeDiameterToPcap writes a Diameter message to a pcap file with proper network layers
func writeDiameterToPcap(filename string, diameterData []byte, srcIP, dstIP net.IP, port int) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	// Create packet layers
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(port),
		DstPort: layers.TCPPort(3868), // Diameter default port
		Seq:     1000,
		Ack:     0,
		SYN:     false,
		ACK:     true,
		PSH:     true,
		Window:  65535,
	}

	// Set TCP options for better compatibility
	tcp.Options = []layers.TCPOption{
		{
			OptionType:   layers.TCPOptionKindMSS,
			OptionLength: 4,
			OptionData:   []byte{0x05, 0xb4}, // MSS = 1460
		},
		{
			OptionType: layers.TCPOptionKindNop,
		},
		{
			OptionType:   layers.TCPOptionKindWindowScale,
			OptionLength: 3,
			OptionData:   []byte{0x07}, // Window scale = 7
		},
	}

	// Calculate TCP checksum
	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize the packet
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	// Create payload (Diameter data)
	payload := gopacket.Payload(diameterData)

	// Serialize all layers
	err = gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet to pcap file
	ci := gopacket.CaptureInfo{
		Timestamp:     time.Now(),
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	err = w.WritePacket(ci, packetBuf.Bytes())
	if err != nil {
		return err
	}

	return nil
}

// writePacketToPcap writes a single packet to an existing pcap writer
func writePacketToPcap(w *pcapgo.Writer, diameterData []byte, srcIP, dstIP net.IP, srcPort, dstPort int, seq, ack uint32, timestamp time.Time) error {
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(dstPort),
		Seq:     seq,
		Ack:     ack,
		SYN:     ack == 0 && seq == 1000, // Only for SYN packet
		ACK:     ack > 0,                 // ACK if we have acknowledgment number
		PSH:     true,                    // Push flag for data packets
		Window:  65535,
	}

	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	payload := gopacket.Payload(diameterData)

	err := gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet
	ci := gopacket.CaptureInfo{
		Timestamp:     timestamp,
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	return w.WritePacket(ci, packetBuf.Bytes())
}

// writeDiameterPairToPcap writes a request-response pair to a single pcap file
func writeDiameterPairToPcap(filename string, requestData, responseData []byte, clientIP, serverIP net.IP) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	baseTime := time.Now()
	clientPort := 54321
	serverPort := 3868

	// Write request packet (client -> server)
	err = writePacketToPcap(w, requestData, clientIP, serverIP, clientPort, serverPort, 1000, 1, baseTime)
	if err != nil {
		return err
	}

	// Write response packet (server -> client) with small delay
	responseTime := baseTime.Add(10 * time.Millisecond)
	err = writePacketToPcap(w, responseData, serverIP, clientIP, serverPort, clientPort, 1, 1000+uint32(len(requestData)), responseTime)
	if err != nil {
		return err
	}

	return nil
}

// TestMEIdentityCheckRequest_PCAP tests PCAP file generation for Request message
func TestMEIdentityCheckRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_micr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	msg := NewMEIdentityCheckRequest()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.AuthSessionState = models_base.Enumerated(1)
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.TerminalInformation = &TerminalInformation{
		Imei:            ptrUTF8String("123456789012345"),
		Meid:            ptrOctetString([]byte{0x01, 0x02, 0x03}),
		SoftwareVersion: ptrUTF8String("01"),
	}

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestMEIdentityCheckAnswer_PCAP tests PCAP file generation for Answer message
func TestMEIdentityCheckAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_mica.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message
	msg := NewMEIdentityCheckAnswer()
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.AuthSessionState = models_base.Enumerated(1)
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestMIC_Pair_PCAP tests PCAP file generation for MIC request-response pair
func TestMIC_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_mic_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message
	request := NewMEIdentityCheckRequest()
	request.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	request.AuthSessionState = models_base.Enumerated(1)
	request.OriginHost = models_base.DiameterIdentity("client.example.com")
	request.OriginRealm = models_base.DiameterIdentity("client.example.com")
	request.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	request.TerminalInformation = &TerminalInformation{
		Imei:            ptrUTF8String("123456789012345"),
		Meid:            ptrOctetString([]byte{0x01, 0x02, 0x03}),
		SoftwareVersion: ptrUTF8String("01"),
	}

	// Set header identifiers for request
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message
	answer := NewMEIdentityCheckAnswer()
	answer.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	answer.AuthSessionState = models_base.Enumerated(1)
	answer.OriginHost = models_base.DiameterIdentity("server.example.com")
	answer.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for answer (must match request)
	answer.Header.HopByHopID = 0x12345678
	answer.Header.EndToEndID = 0x87654321

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}
