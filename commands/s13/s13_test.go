// Code generated by diameter-codegen. DO NOT EDIT.

package s13

import (
	"bytes"
	"testing"

	"github.com/hsdfat8/diam-gw/models_base"
)

// TestMEIdentityCheckRequest_Creation tests basic creation and initialization
func TestMEIdentityCheckRequest_Creation(t *testing.T) {
	msg := NewMEIdentityCheckRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 324 {
		t.Errorf("Expected command code 324, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 16777252 {
		t.Errorf("Expected application ID 16777252, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestMEIdentityCheckRequest_Validation tests field validation
func TestMEIdentityCheckRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &MEIdentityCheckRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewMEIdentityCheckRequest()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.AuthSessionState = models_base.Enumerated(1)
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
		msg.TerminalInformation = &TerminalInformation{
			Imei:            ptrUTF8String("123456789012345"),
			Meid:            ptrOctetString([]byte{0x01, 0x02, 0x03}),
			SoftwareVersion: ptrUTF8String("01"),
		}

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestMEIdentityCheckRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestMEIdentityCheckRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewMEIdentityCheckRequest()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.AuthSessionState = models_base.Enumerated(1)
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	original.TerminalInformation = &TerminalInformation{
		Imei:            ptrUTF8String("123456789012345"),
		Meid:            ptrOctetString([]byte{0x01, 0x02, 0x03}),
		SoftwareVersion: ptrUTF8String("01"),
	}

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &MEIdentityCheckRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.AuthSessionState != original.AuthSessionState {
		t.Errorf("AuthSessionState mismatch: got %d, want %d", decoded.AuthSessionState, original.AuthSessionState)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.DestinationRealm != original.DestinationRealm {
		t.Errorf("DestinationRealm mismatch: got %v, want %v", decoded.DestinationRealm, original.DestinationRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

// TestMEIdentityCheckAnswer_Creation tests basic creation and initialization
func TestMEIdentityCheckAnswer_Creation(t *testing.T) {
	msg := NewMEIdentityCheckAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 324 {
		t.Errorf("Expected command code 324, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 16777252 {
		t.Errorf("Expected application ID 16777252, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestMEIdentityCheckAnswer_Validation tests field validation
func TestMEIdentityCheckAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &MEIdentityCheckAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewMEIdentityCheckAnswer()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.AuthSessionState = models_base.Enumerated(1)
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestMEIdentityCheckAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestMEIdentityCheckAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewMEIdentityCheckAnswer()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.AuthSessionState = models_base.Enumerated(1)
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &MEIdentityCheckAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.AuthSessionState != original.AuthSessionState {
		t.Errorf("AuthSessionState mismatch: got %d, want %d", decoded.AuthSessionState, original.AuthSessionState)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}
