// Code generated by diameter-codegen. DO NOT EDIT.

package s6a

import (
	"bytes"
	"testing"

	"github.com/hsdfat8/diam-gw/models_base"
)

// TestUpdateLocationRequest_Creation tests basic creation and initialization
func TestUpdateLocationRequest_Creation(t *testing.T) {
	msg := NewUpdateLocationRequest()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 316 {
		t.Errorf("Expected command code 316, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 16777251 {
		t.Errorf("Expected application ID 16777251, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != true {
		t.Errorf("Expected Request flag true, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestUpdateLocationRequest_Validation tests field validation
func TestUpdateLocationRequest_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &UpdateLocationRequest{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewUpdateLocationRequest()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.AuthSessionState = models_base.Enumerated(1)
		msg.OriginHost = models_base.DiameterIdentity("client.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
		msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
		msg.UserName = models_base.UTF8String("test")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestUpdateLocationRequest_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestUpdateLocationRequest_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewUpdateLocationRequest()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.AuthSessionState = models_base.Enumerated(1)
	original.OriginHost = models_base.DiameterIdentity("client.example.com")
	original.OriginRealm = models_base.DiameterIdentity("client.example.com")
	original.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	original.UserName = models_base.UTF8String("test")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &UpdateLocationRequest{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.AuthSessionState != original.AuthSessionState {
		t.Errorf("AuthSessionState mismatch: got %d, want %d", decoded.AuthSessionState, original.AuthSessionState)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}
	if decoded.DestinationRealm != original.DestinationRealm {
		t.Errorf("DestinationRealm mismatch: got %v, want %v", decoded.DestinationRealm, original.DestinationRealm)
	}
	if decoded.UserName != original.UserName {
		t.Errorf("UserName mismatch: got %v, want %v", decoded.UserName, original.UserName)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}

// TestUpdateLocationAnswer_Creation tests basic creation and initialization
func TestUpdateLocationAnswer_Creation(t *testing.T) {
	msg := NewUpdateLocationAnswer()

	// Verify header initialization
	if msg.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", msg.Header.Version)
	}

	if msg.Header.CommandCode != 316 {
		t.Errorf("Expected command code 316, got %d", msg.Header.CommandCode)
	}

	if msg.Header.ApplicationID != 16777251 {
		t.Errorf("Expected application ID 16777251, got %d", msg.Header.ApplicationID)
	}

	if msg.Header.Flags.Request != false {
		t.Errorf("Expected Request flag false, got %v", msg.Header.Flags.Request)
	}

	if msg.Header.Flags.Proxiable != true {
		t.Errorf("Expected Proxiable flag true, got %v", msg.Header.Flags.Proxiable)
	}
}

// TestUpdateLocationAnswer_Validation tests field validation
func TestUpdateLocationAnswer_Validation(t *testing.T) {
	t.Run("EmptyMessage", func(t *testing.T) {
		msg := &UpdateLocationAnswer{}
		err := msg.Validate()
		if err == nil {
			t.Error("Expected validation error for empty message, got nil")
		}
	})

	t.Run("ValidMessage", func(t *testing.T) {
		msg := NewUpdateLocationAnswer()
		msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
		msg.AuthSessionState = models_base.Enumerated(1)
		msg.OriginHost = models_base.DiameterIdentity("server.example.com")
		msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

		err := msg.Validate()
		if err != nil {
			t.Errorf("Expected no validation error, got: %v", err)
		}
	})
}

// TestUpdateLocationAnswer_MarshalUnmarshal tests Marshal and Unmarshal roundtrip
func TestUpdateLocationAnswer_MarshalUnmarshal(t *testing.T) {
	// Create original message
	original := NewUpdateLocationAnswer()
	original.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	original.AuthSessionState = models_base.Enumerated(1)
	original.OriginHost = models_base.DiameterIdentity("server.example.com")
	original.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Set header identifiers for comparison
	original.Header.HopByHopID = 0xAABBCCDD
	original.Header.EndToEndID = 0x11223344

	// Marshal original
	data, err := original.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal into new message
	decoded := &UpdateLocationAnswer{}
	err = decoded.Unmarshal(data)
	if err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify header fields
	if decoded.Header.Version != original.Header.Version {
		t.Errorf("Version mismatch: got %d, want %d", decoded.Header.Version, original.Header.Version)
	}
	if decoded.Header.CommandCode != original.Header.CommandCode {
		t.Errorf("CommandCode mismatch: got %d, want %d", decoded.Header.CommandCode, original.Header.CommandCode)
	}
	if decoded.Header.ApplicationID != original.Header.ApplicationID {
		t.Errorf("ApplicationID mismatch: got %d, want %d", decoded.Header.ApplicationID, original.Header.ApplicationID)
	}
	if decoded.Header.HopByHopID != original.Header.HopByHopID {
		t.Errorf("HopByHopID mismatch: got 0x%X, want 0x%X", decoded.Header.HopByHopID, original.Header.HopByHopID)
	}
	if decoded.Header.EndToEndID != original.Header.EndToEndID {
		t.Errorf("EndToEndID mismatch: got 0x%X, want 0x%X", decoded.Header.EndToEndID, original.Header.EndToEndID)
	}

	if decoded.SessionId != original.SessionId {
		t.Errorf("SessionId mismatch: got %v, want %v", decoded.SessionId, original.SessionId)
	}
	if decoded.AuthSessionState != original.AuthSessionState {
		t.Errorf("AuthSessionState mismatch: got %d, want %d", decoded.AuthSessionState, original.AuthSessionState)
	}
	if decoded.OriginHost != original.OriginHost {
		t.Errorf("OriginHost mismatch: got %v, want %v", decoded.OriginHost, original.OriginHost)
	}
	if decoded.OriginRealm != original.OriginRealm {
		t.Errorf("OriginRealm mismatch: got %v, want %v", decoded.OriginRealm, original.OriginRealm)
	}

	// Marshal again and compare bytes
	data2, err := decoded.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal decoded message: %v", err)
	}

	if !bytes.Equal(data, data2) {
		t.Errorf("Marshaled data differs after roundtrip (len: %d vs %d)", len(data), len(data2))
	}
}
