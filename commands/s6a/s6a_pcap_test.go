// Code generated by diameter-codegen. DO NOT EDIT.

package s6a

import (
	"net"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcapgo"
	"github.com/hsdfat8/diam-gw/models_base"
)

// writeDiameterToPcap writes a Diameter message to a pcap file with proper network layers
func writeDiameterToPcap(filename string, diameterData []byte, srcIP, dstIP net.IP, port int) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	// Create packet layers
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(port),
		DstPort: layers.TCPPort(3868), // Diameter default port
		Seq:     1000,
		Ack:     0,
		SYN:     false,
		ACK:     true,
		PSH:     true,
		Window:  65535,
	}

	// Set TCP options for better compatibility
	tcp.Options = []layers.TCPOption{
		{
			OptionType:   layers.TCPOptionKindMSS,
			OptionLength: 4,
			OptionData:   []byte{0x05, 0xb4}, // MSS = 1460
		},
		{
			OptionType: layers.TCPOptionKindNop,
		},
		{
			OptionType:   layers.TCPOptionKindWindowScale,
			OptionLength: 3,
			OptionData:   []byte{0x07}, // Window scale = 7
		},
	}

	// Calculate TCP checksum
	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize the packet
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	// Create payload (Diameter data)
	payload := gopacket.Payload(diameterData)

	// Serialize all layers
	err = gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet to pcap file
	ci := gopacket.CaptureInfo{
		Timestamp:     time.Now(),
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	err = w.WritePacket(ci, packetBuf.Bytes())
	if err != nil {
		return err
	}

	return nil
}

// writePacketToPcap writes a single packet to an existing pcap writer
func writePacketToPcap(w *pcapgo.Writer, diameterData []byte, srcIP, dstIP net.IP, srcPort, dstPort int, seq, ack uint32, timestamp time.Time) error {
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(dstPort),
		Seq:     seq,
		Ack:     ack,
		SYN:     ack == 0 && seq == 1000, // Only for SYN packet
		ACK:     ack > 0,                 // ACK if we have acknowledgment number
		PSH:     true,                    // Push flag for data packets
		Window:  65535,
	}

	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	payload := gopacket.Payload(diameterData)

	err := gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet
	ci := gopacket.CaptureInfo{
		Timestamp:     timestamp,
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	return w.WritePacket(ci, packetBuf.Bytes())
}

// writeDiameterPairToPcap writes a request-response pair to a single pcap file
func writeDiameterPairToPcap(filename string, requestData, responseData []byte, clientIP, serverIP net.IP) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	baseTime := time.Now()
	clientPort := 54321
	serverPort := 3868

	// Write request packet (client -> server)
	err = writePacketToPcap(w, requestData, clientIP, serverIP, clientPort, serverPort, 1000, 1, baseTime)
	if err != nil {
		return err
	}

	// Write response packet (server -> client) with small delay
	responseTime := baseTime.Add(10 * time.Millisecond)
	err = writePacketToPcap(w, responseData, serverIP, clientIP, serverPort, clientPort, 1, 1000+uint32(len(requestData)), responseTime)
	if err != nil {
		return err
	}

	return nil
}

// createUpdateLocationRequestForTest creates a UpdateLocationRequest message with ALL fields populated for testing
func createUpdateLocationRequestForTest() *UpdateLocationRequest {
	msg := NewUpdateLocationRequest()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.AuthSessionState = models_base.Enumerated(1)
	msg.OriginHost = models_base.DiameterIdentity("client.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("client.example.com")
	msg.DestinationRealm = models_base.DiameterIdentity("server.example.com")
	msg.UserName = models_base.UTF8String("test")

	// Optional fields (for complete PCAP examples)
	msg.Drmp = ptrOctetString([]byte{0x01, 0x02, 0x03})
	msg.VendorSpecificApplicationId = &VendorSpecificApplicationId{
		VendorId:          ptrUnsigned32(10415),
		AuthApplicationId: ptrUnsigned32(16777252),
		AcctApplicationId: ptrUnsigned32(1),
	}
	msg.DestinationHost = ptrDiameterIdentity("server.example.com")
	msg.SupportedFeatures = ptrOctetString([]byte{0x01, 0x02, 0x03})
	msg.TerminalInformation = &TerminalInformation{
		Imei:            ptrUTF8String("123456789012345"),
		Meid:            ptrOctetString([]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}),
		SoftwareVersion: ptrUTF8String("01"),
	}
	msg.RatType = ptrEnumerated(1)
	msg.UlrFlags = ptrUnsigned32(1)
	msg.VisitedPlmnId = ptrOctetString([]byte{0x00, 0xF1, 0x10})
	msg.SgsnNumber = ptrOctetString([]byte{0x01, 0x02, 0x03})
	msg.RequestedEutranAuthenticationInfo = &RequestedEUTRANAuthenticationInfo{
		NumberOfRequestedVectors:   ptrUnsigned32(1),
		ImmediateResponsePreferred: ptrEnumerated(1),
		ReSynchronizationInfo:      ptrOctetString([]byte{0x01, 0x02, 0x03}),
	}
	msg.RequestedUtranGeranAuthenticationInfo = &RequestedUTRANGERANAuthenticationInfo{
		NumberOfRequestedVectors:   ptrUnsigned32(1),
		ImmediateResponsePreferred: ptrEnumerated(1),
		ReSynchronizationInfo:      ptrOctetString([]byte{0x01, 0x02, 0x03}),
	}
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("client.example.com")}

	return msg
}

// createUpdateLocationAnswerForTest creates a UpdateLocationAnswer message with ALL fields populated for testing
func createUpdateLocationAnswerForTest() *UpdateLocationAnswer {
	msg := NewUpdateLocationAnswer()

	// Required fields
	msg.SessionId = models_base.UTF8String("client.example.com;1234567890;1")
	msg.AuthSessionState = models_base.Enumerated(1)
	msg.OriginHost = models_base.DiameterIdentity("server.example.com")
	msg.OriginRealm = models_base.DiameterIdentity("server.example.com")

	// Optional fields (for complete PCAP examples)
	msg.ResultCode = ptrUnsigned32(2001) // DIAMETER_SUCCESS
	msg.ExperimentalResult = &ExperimentalResult{
		VendorId:               models_base.Unsigned32(10415),
		ExperimentalResultCode: models_base.Unsigned32(1),
	}
	msg.Drmp = ptrOctetString([]byte{0x01, 0x02, 0x03})
	msg.VendorSpecificApplicationId = &VendorSpecificApplicationId{
		VendorId:          ptrUnsigned32(10415),
		AuthApplicationId: ptrUnsigned32(16777252),
		AcctApplicationId: ptrUnsigned32(1),
	}
	msg.UlaFlags = ptrUnsigned32(1)
	msg.SubscriptionData = &SubscriptionData{
		SubscriberStatus:             ptrEnumerated(1),
		Msisdn:                       ptrOctetString([]byte{0x01, 0x02, 0x03}),
		AMsisdn:                      ptrOctetString([]byte{0x01, 0x02, 0x03}),
		StnSr:                        ptrOctetString([]byte{0x01, 0x02, 0x03}),
		IcsIndicator:                 ptrOctetString([]byte{0x01, 0x02, 0x03}),
		NetworkAccessMode:            ptrEnumerated(1),
		OperatorDeterminedBarring:    ptrUnsigned32(1),
		HplmnOdb:                     ptrUnsigned32(1),
		RegionalSubscriptionZoneCode: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
		AccessRestrictionData:        ptrUnsigned32(1),
		ApnOiReplacement:             ptrUTF8String("test"),
		// LcsInfo: nil, // (type: Grouped) needs to be set
		// TeleserviceList: nil, // (type: Grouped) needs to be set
		// CallBarringInfo: nil, // (type: Grouped) needs to be set
		ChargingCharacteristics: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		// Ambr: nil, // (type: Grouped) needs to be set
		// ApnConfigurationProfile: nil, // (type: Grouped) needs to be set
		RatFrequencySelectionPriorityId: ptrUnsigned32(1),
		// TraceData: nil, // (type: Grouped) needs to be set
		// GprsSubscriptionData: nil, // (type: Grouped) needs to be set
		// CsgSubscriptionData: nil, // (type: Grouped) needs to be set
		RoamingRestricted:             ptrEnumerated(1),
		SubscribedPeriodicRauTauTimer: ptrUnsigned32(1),
		MpsPriority:                   ptrUnsigned32(1),
		VplmnLipaAllowed:              ptrEnumerated(1),
		RelayNodeIndicator:            ptrEnumerated(1),
		MdtUserConsent:                ptrEnumerated(1),
		SubscribedVsrvcc:              ptrUnsigned32(1),
		// ProseSubscriptionData: nil, // (type: Grouped) needs to be set
		SubscriptionDataFlags: ptrUnsigned32(1),
		// AdjacentAccessRestrictionData: nil, // (type: Grouped) needs to be set
		// DlBufferingSuggestedPacketCount: nil, // (type: Integer32) needs to be set
		// ImsiGroupId: nil, // (type: Grouped) needs to be set
		UeUsageType:              ptrUnsigned32(1),
		AeseCommunicationPattern: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
		// MonitoringEventConfiguration: nil, // (type: Grouped) needs to be set
		// EmergencyInfo: nil, // (type: Grouped) needs to be set
		// V2xSubscriptionData: nil, // (type: Grouped) needs to be set
		// EdrxCycleLength: nil, // (type: Grouped) needs to be set
		ExternalIdentifier:                   ptrOctetString([]byte{0x01, 0x02, 0x03}),
		ActiveTime:                           ptrOctetString([]byte{0x01, 0x02, 0x03}),
		ServiceGapTime:                       ptrOctetString([]byte{0x01, 0x02, 0x03}),
		BroadcastLocationAssistanceDataTypes: ptrOctetString([]byte{0x01, 0x02, 0x03}),
		AerialUeSubscriptionInformation:      ptrOctetString([]byte{0x01, 0x02, 0x03}),
		CoreNetworkRestrictions:              ptrOctetString([]byte{0x01, 0x02, 0x03}),
	}
	msg.SupportedFeatures = ptrOctetString([]byte{0x01, 0x02, 0x03})
	msg.Avp = []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})}
	msg.FailedAvp = &FailedAVP{
		Avp: []models_base.OctetString{models_base.OctetString([]byte{0x01, 0x02, 0x03})},
	}
	msg.ProxyInfo = []*ProxyInfo{
		&ProxyInfo{
			ProxyHost:  models_base.DiameterIdentity("client.example.com"),
			ProxyState: models_base.OctetString([]byte{0x01, 0x02, 0x03}),
		},
	}
	msg.RouteRecord = []models_base.DiameterIdentity{models_base.DiameterIdentity("server.example.com")}

	return msg
}

// TestUpdateLocationRequest_PCAP tests PCAP file generation for Request message
func TestUpdateLocationRequest_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ulr.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated
	msg := createUpdateLocationRequestForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Request message")
}

// TestUpdateLocationAnswer_PCAP tests PCAP file generation for Answer message
func TestUpdateLocationAnswer_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ula.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Answer message with ALL fields populated
	msg := createUpdateLocationAnswerForTest()

	// Set header identifiers
	msg.Header.HopByHopID = 0x12345678
	msg.Header.EndToEndID = 0x87654321

	// Marshal message
	data, err := msg.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal message: %v", err)
	}

	// Write to PCAP
	err = writeDiameterToPcap(pcapFile, data, net.ParseIP("192.168.1.1"), net.ParseIP("192.168.1.100"), 3868)
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the Answer message")
}

// TestUL_Pair_PCAP tests PCAP file generation for UL request-response pair
func TestUL_Pair_PCAP(t *testing.T) {
	// Create testdata directory
	if err := os.MkdirAll("testdata", 0755); err != nil {
		t.Fatalf("Failed to create testdata directory: %v", err)
	}

	// Create pcap file path
	pcapFile := filepath.Join("testdata", "test_ul_pair.pcap")
	// PCAP files are kept for Wireshark analysis

	// Create Request message with ALL fields populated (using helper function)
	request := createUpdateLocationRequestForTest()
	request.Header.HopByHopID = 0x12345678
	request.Header.EndToEndID = 0x87654321

	// Create Answer message with ALL fields populated (using helper function)
	answer := createUpdateLocationAnswerForTest()
	answer.Header.HopByHopID = 0x12345678 // Must match request
	answer.Header.EndToEndID = 0x87654321 // Must match request

	// Marshal request
	requestData, err := request.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	// Marshal answer
	answerData, err := answer.Marshal()
	if err != nil {
		t.Fatalf("Failed to marshal answer: %v", err)
	}

	// Write request-response pair to PCAP
	err = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP("192.168.1.100"), net.ParseIP("192.168.1.1"))
	if err != nil {
		t.Fatalf("Failed to write PCAP: %v", err)
	}

	// Verify PCAP file
	info, err := os.Stat(pcapFile)
	if err != nil {
		t.Fatalf("PCAP file not created: %v", err)
	}
	if info.Size() == 0 {
		t.Fatal("PCAP file is empty")
	}

	t.Logf("PCAP file created: %s (%d bytes)", pcapFile, info.Size())
	t.Logf("Open in Wireshark to view the request-response pair")
}
