// Code generated by diameter-codegen. DO NOT EDIT.

package s6a

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/hsdfat8/diam-gw/models_base"
)

// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

// AVP Codes
const (
	AVPCodeHOMOGENEOUSSUPPORTOFIMSVOICEOVERPSSESSIONS uint32 = 1493
	AVPCodeLOCATIONAREAIDENTITY                       uint32 = 1606
	AVPCodeORIGINHOST                                 uint32 = 264
	AVPCodeDSRFLAGS                                   uint32 = 1421
	AVPCodeCSGSUBSCRIPTIONDATA                        uint32 = 1436
	AVPCodePDNGWALLOCATIONTYPE                        uint32 = 1438
	AVPCodeTRACENETYPELIST                            uint32 = 1463
	AVPCodeGMLCRESTRICTION                            uint32 = 1481
	AVPCodePURFLAGS                                   uint32 = 1635
	AVPCodePROXYINFO                                  uint32 = 284
	AVPCodeMAXREQUESTEDBANDWIDTHUL                    uint32 = 516
	AVPCodeAPNCONFIGURATION                           uint32 = 1430
	AVPCodeERRORDIAGNOSTIC                            uint32 = 1614
	AVPCodeMMENUMBERFORMTSMS                          uint32 = 1645
	AVPCodeGPRSSUBSCRIPTIONDATA                       uint32 = 1467
	AVPCodeSGSNLOCATIONINFORMATION                    uint32 = 1601
	AVPCodeSUPPORTEDFEATURES                          uint32 = 628
	AVPCodeTERMINALINFORMATION                        uint32 = 1401
	AVPCodeXRES                                       uint32 = 1448
	AVPCodeTRACEREFERENCE                             uint32 = 1459
	AVPCodeSSSTATUS                                   uint32 = 1477
	AVPCodeEQUIVALENTPLMNLIST                         uint32 = 1637
	AVPCodeOPERATORDETERMINEDBARRING                  uint32 = 1425
	AVPCodeVPLMNDYNAMICADDRESSALLOWED                 uint32 = 1432
	AVPCodeMIP6AGENTINFO                              uint32 = 486
	AVPCodeAIRFLAGS                                   uint32 = 1679
	AVPCodeNOTIFICATIONTOUEUSER                       uint32 = 1478
	AVPCodeLASTUEACTIVITYTIME                         uint32 = 1494
	AVPCodeUSERNAME                                   uint32 = 1
	AVPCodeHPLMNODB                                   uint32 = 1418
	AVPCodeNORFLAGS                                   uint32 = 1443
	AVPCodeTSCODE                                     uint32 = 1487
	AVPCodeROUTINGAREAIDENTITY                        uint32 = 1605
	AVPCodeUSERSTATE                                  uint32 = 1499
	AVPCodeEXTPDPTYPE                                 uint32 = 1620
	AVPCodeIMMEDIATERESPONSEPREFERRED                 uint32 = 1412
	AVPCodeIDAFLAGS                                   uint32 = 1441
	AVPCodeEPSLOCATIONINFORMATION                     uint32 = 1496
	AVPCodeEXPIRATIONDATE                             uint32 = 1439
	AVPCodeEUTRANVECTOR                               uint32 = 1414
	AVPCodeMOLR                                       uint32 = 1485
	AVPCodeEXPERIMENTALRESULT                         uint32 = 297
	AVPCodeGEODETICINFORMATION                        uint32 = 1609
	AVPCodeRAND                                       uint32 = 1447
	AVPCodeEXTERNALCLIENT                             uint32 = 1479
	AVPCodeSERVICETYPE                                uint32 = 1483
	AVPCodeSERVICETYPEIDENTITY                        uint32 = 1484
	AVPCodeMMELOCATIONINFORMATION                     uint32 = 1600
	AVPCodeSUBSCRIBEDPERIODICRAUTAUTIMER              uint32 = 1619
	AVPCodeDESTINATIONREALM                           uint32 = 283
	AVPCodeCSGID                                      uint32 = 1437
	AVPCodeTRACEDATA                                  uint32 = 1458
	AVPCodeEUTRANCELLGLOBALIDENTITY                   uint32 = 1602
	AVPCodeUEUSAGETYPE                                uint32 = 1680
	AVPCodeIMEI                                       uint32 = 1402
	AVPCodeULAFLAGS                                   uint32 = 1406
	AVPCodeDSAFLAGS                                   uint32 = 1422
	AVPCodeEQUIPMENTSTATUS                            uint32 = 1445
	AVPCodeCOMPLETEDATALISTINCLUDEDINDICATOR          uint32 = 1468
	AVPCodeSGSNNUMBER                                 uint32 = 1489
	AVPCodeLOCALTIMEZONE                              uint32 = 1649
	AVPCodeTRACEINTERFACELIST                         uint32 = 1464
	AVPCodeRESULTCODE                                 uint32 = 268
	AVPCodeRESYNCHRONIZATIONINFO                      uint32 = 1411
	AVPCodeGMLCNUMBER                                 uint32 = 1474
	AVPCodePLMNCLIENT                                 uint32 = 1482
	AVPCodeVPLMNLIPAALLOWED                           uint32 = 1617
	AVPCode3GPP2MEID                                  uint32 = 1471
	AVPCodeEPSSUBSCRIBEDQOSPROFILE                    uint32 = 1431
	AVPCodeDRMP                                       uint32 = 301
	AVPCodeVISITEDNETWORKIDENTIFIER                   uint32 = 600
	AVPCodeCURRENTLOCATIONRETRIEVED                   uint32 = 1610
	AVPCodeACCESSRESTRICTIONDATA                      uint32 = 1426
	AVPCodeRATFREQUENCYSELECTIONPRIORITYID            uint32 = 1440
	AVPCodePDPTYPE                                    uint32 = 1470
	AVPCodeQOSSUBSCRIBED                              uint32 = 1404
	AVPCodeTELESERVICELIST                            uint32 = 1486
	AVPCodeIMSVOICEOVERPSSESSIONSSUPPORTED            uint32 = 1492
	AVPCodeSMSREGISTERREQUEST                         uint32 = 1648
	AVPCodeUSERID                                     uint32 = 1444
	AVPCodeCANCELLATIONTYPE                           uint32 = 1420
	AVPCodeSOFTWAREVERSION                            uint32 = 1403
	AVPCodeREQUESTEDEUTRANAUTHENTICATIONINFO          uint32 = 1408
	AVPCodeUTRANVECTOR                                uint32 = 1415
	AVPCodeCLRFLAGS                                   uint32 = 1638
	AVPCodeSUBSCRIBERSTATUS                           uint32 = 1424
	AVPCodeREGIONALSUBSCRIPTIONZONECODE               uint32 = 1446
	AVPCodeREQUESTEDUTRANGERANAUTHENTICATIONINFO      uint32 = 1409
	AVPCodeKC                                         uint32 = 1453
	AVPCodeCONTEXTIDENTIFIER                          uint32 = 1423
	AVPCodeAPNOIREPLACEMENT                           uint32 = 1427
	AVPCodeTRACEDEPTH                                 uint32 = 1462
	AVPCodeCLIENTIDENTITY                             uint32 = 1480
	AVPCodeLCSINFO                                    uint32 = 1473
	AVPCodeICSINDICATOR                               uint32 = 1491
	AVPCodeTRACKINGAREAIDENTITY                       uint32 = 1603
	AVPCodeACTIVEAPN                                  uint32 = 1612
	AVPCodeMPSPRIORITY                                uint32 = 1616
	AVPCodeEXPERIMENTALRESULTCODE                     uint32 = 298
	AVPCodeROUTERECORD                                uint32 = 282
	AVPCodeNUMBEROFREQUESTEDVECTORS                   uint32 = 1410
	AVPCodeOMCID                                      uint32 = 1466
	AVPCodeLCSPRIVACYEXCEPTION                        uint32 = 1475
	AVPCodeSGSNUSERSTATE                              uint32 = 1498
	AVPCodeGEOGRAPHICALINFORMATION                    uint32 = 1608
	AVPCodeRATTYPE                                    uint32 = 1032
	AVPCodeDESTINATIONHOST                            uint32 = 293
	AVPCodeAUTN                                       uint32 = 1449
	AVPCodeAMBR                                       uint32 = 1435
	AVPCodeROAMINGRESTRICTEDDUETOUNSUPPORTEDFEATURE   uint32 = 1457
	AVPCodeLIPAPERMISSION                             uint32 = 1618
	AVPCodeFAILEDAVP                                  uint32 = 279
	AVPCodeKASME                                      uint32 = 1450
	AVPCodeALERTREASON                                uint32 = 1434
	AVPCodePUAFLAGS                                   uint32 = 1442
	AVPCodePDNTYPE                                    uint32 = 1456
	AVPCodeIDRFLAGS                                   uint32 = 1490
	AVPCodeSERVICEAREAIDENTITY                        uint32 = 1607
	AVPCodeOCOLR                                      uint32 = 623
	AVPCodeLOAD                                       uint32 = 650
	AVPCodeSERVICESELECTION                           uint32 = 493
	AVPCodeGERANVECTOR                                uint32 = 1416
	AVPCodeSESSIONID                                  uint32 = 263
	AVPCodeVISITEDPLMNID                              uint32 = 1407
	AVPCodeORIGINREALM                                uint32 = 296
	AVPCodeAGEOFLOCATIONINFORMATION                   uint32 = 1611
	AVPCodeULRFLAGS                                   uint32 = 1405
	AVPCodeALLAPNCONFIGURATIONSINCLUDEDINDICATOR      uint32 = 1428
	AVPCodeCELLGLOBALIDENTITY                         uint32 = 1604
	AVPCodeFEATURELIST                                uint32 = 630
	AVPCodeVENDORSPECIFICAPPLICATIONID                uint32 = 260
	AVPCodeNETWORKACCESSMODE                          uint32 = 1417
	AVPCodeMAXREQUESTEDBANDWIDTHDL                    uint32 = 515
	AVPCodeTRACEEVENTLIST                             uint32 = 1465
	AVPCodeSSCODE                                     uint32 = 1476
	AVPCodeCALLBARRINGINFO                            uint32 = 1488
	AVPCodeUESRVCCCAPABILITY                          uint32 = 1615
	AVPCodeGMLCADDRESS                                uint32 = 2405
	AVPCodeRESETID                                    uint32 = 1670
	AVPCodeSRES                                       uint32 = 1454
	AVPCodeITEMNUMBER                                 uint32 = 1419
	AVPCodeAPNCONFIGURATIONPROFILE                    uint32 = 1429
	AVPCodeSTNSR                                      uint32 = 1433
	AVPCodeTRACECOLLECTIONENTITY                      uint32 = 1452
	AVPCodeMMEUSERSTATE                               uint32 = 1497
	AVPCodeOCSUPPORTEDFEATURES                        uint32 = 621
	AVPCodeSUBSCRIPTIONDATA                           uint32 = 1400
	AVPCodePDPCONTEXT                                 uint32 = 1469
	AVPCodeEPSUSERSTATE                               uint32 = 1495
	AVPCodeFEATURELISTID                              uint32 = 629
	AVPCodeAUTHSESSIONSTATE                           uint32 = 277
	AVPCodeAUTHENTICATIONINFO                         uint32 = 1413
	AVPCodeSPECIFICAPNINFO                            uint32 = 1472
)

// Command Codes
const (
	CommandCodeUPDATELOCATIONREQUEST            uint32 = 316
	CommandCodeUPDATELOCATIONANSWER             uint32 = 316
	CommandCodeAUTHENTICATIONINFORMATIONREQUEST uint32 = 318
	CommandCodeAUTHENTICATIONINFORMATIONANSWER  uint32 = 318
	CommandCodeCANCELLOCATIONREQUEST            uint32 = 317
	CommandCodeCANCELLOCATIONANSWER             uint32 = 317
	CommandCodeINSERTSUBSCRIBERDATAREQUEST      uint32 = 319
	CommandCodeINSERTSUBSCRIBERDATAANSWER       uint32 = 319
	CommandCodeDELETESUBSCRIBERDATAREQUEST      uint32 = 320
	CommandCodeDELETESUBSCRIBERDATAANSWER       uint32 = 320
	CommandCodePURGEUEREQUEST                   uint32 = 321
	CommandCodePURGEUEANSWER                    uint32 = 321
	CommandCodeRESETREQUEST                     uint32 = 322
	CommandCodeRESETANSWER                      uint32 = 322
	CommandCodeNOTIFYREQUEST                    uint32 = 323
	CommandCodeNOTIFYANSWER                     uint32 = 323
)

// UpdateLocationRequest represents the Update-Location-Request (ULR) Diameter command
// Command Code: 316, Application ID: 16777251
type UpdateLocationRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             *models_base.DiameterIdentity  // Optional
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	TerminalInformation         *models_base.Grouped           // Optional
	RatType                     models_base.Enumerated         // Required
	UlrFlags                    models_base.Unsigned32         // Required
	UeSrvccCapability           *models_base.Enumerated        // Optional
	VisitedPlmnId               models_base.OctetString        // Required
	SgsnNumber                  *models_base.OctetString       // Optional
	HomogeneousSupportImsVoice  *models_base.Enumerated        // Optional
	GmlcAddress                 *models_base.Address           // Optional
	ActiveApn                   []models_base.Grouped          // Optional
	EquivalentPlmnList          *models_base.Grouped           // Optional
	MmeNumberForMtSms           *models_base.OctetString       // Optional
	SmsRegisterRequest          *models_base.Enumerated        // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewUpdateLocationRequest creates a new ULR message
func NewUpdateLocationRequest() *UpdateLocationRequest {
	return &UpdateLocationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   316,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in UpdateLocationRequest
func (m *UpdateLocationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}
	if m.VisitedPlmnId == "" {
		return fmt.Errorf("required field Visited-PLMN-Id is empty")
	}

	return nil
}

// Marshal serializes the UpdateLocationRequest to bytes using a buffer for optimal performance
func (m *UpdateLocationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, false, false))
	}

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, false, true))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal TerminalInformation (optional)
	if m.TerminalInformation != nil {
		buf.Write(marshalAVP(1401, *m.TerminalInformation, true, false))
	}

	// Marshal RatType (required)
	buf.Write(marshalAVP(1032, m.RatType, true, false))

	// Marshal UlrFlags (required)
	buf.Write(marshalAVP(1405, m.UlrFlags, true, false))

	// Marshal UeSrvccCapability (optional)
	if m.UeSrvccCapability != nil {
		buf.Write(marshalAVP(1615, *m.UeSrvccCapability, true, false))
	}

	// Marshal VisitedPlmnId (required)
	buf.Write(marshalAVP(1407, m.VisitedPlmnId, true, false))

	// Marshal SgsnNumber (optional)
	if m.SgsnNumber != nil {
		buf.Write(marshalAVP(1489, *m.SgsnNumber, true, false))
	}

	// Marshal HomogeneousSupportImsVoice (optional)
	if m.HomogeneousSupportImsVoice != nil {
		buf.Write(marshalAVP(1493, *m.HomogeneousSupportImsVoice, true, false))
	}

	// Marshal GmlcAddress (optional)
	if m.GmlcAddress != nil {
		buf.Write(marshalAVP(2405, *m.GmlcAddress, true, false))
	}

	// Marshal ActiveApn (repeated)
	for _, v := range m.ActiveApn {
		buf.Write(marshalAVP(1612, v, true, false))
	}

	// Marshal EquivalentPlmnList (optional)
	if m.EquivalentPlmnList != nil {
		buf.Write(marshalAVP(1637, *m.EquivalentPlmnList, false, false))
	}

	// Marshal MmeNumberForMtSms (optional)
	if m.MmeNumberForMtSms != nil {
		buf.Write(marshalAVP(1645, *m.MmeNumberForMtSms, false, false))
	}

	// Marshal SmsRegisterRequest (optional)
	if m.SmsRegisterRequest != nil {
		buf.Write(marshalAVP(1648, *m.SmsRegisterRequest, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into UpdateLocationRequest
func (m *UpdateLocationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1401: // Terminal-Information
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.TerminalInformation = &v
			}
		case 1032: // RAT-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.RatType = val.(models_base.Enumerated)
			}
		case 1405: // ULR-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.UlrFlags = val.(models_base.Unsigned32)
			}
		case 1615: // UE-SRVCC-Capability
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.UeSrvccCapability = &v
			}
		case 1407: // Visited-PLMN-Id
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.VisitedPlmnId = val.(models_base.OctetString)
			}
		case 1489: // SGSN-Number
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.SgsnNumber = &v
			}
		case 1493: // Homogeneous-Support-of-IMS-Voice-Over-PS-Sessions
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.HomogeneousSupportImsVoice = &v
			}
		case 2405: // GMLC-Address
			val, err := models_base.DecodeAddress(avpValue)
			if err == nil {
				v := val.(models_base.Address)
				m.GmlcAddress = &v
			}
		case 1612: // Active-APN
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ActiveApn = append(m.ActiveApn, val.(models_base.Grouped))
			}
		case 1637: // Equivalent-PLMN-List
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.EquivalentPlmnList = &v
			}
		case 1645: // MME-Number-for-MT-SMS
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.MmeNumberForMtSms = &v
			}
		case 1648: // SMS-Register-Request
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.SmsRegisterRequest = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the UpdateLocationRequest message
func (m *UpdateLocationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of UpdateLocationRequest
func (m *UpdateLocationRequest) String() string {
	return fmt.Sprintf("UpdateLocationRequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, OcSupportedFeatures:%v, SupportedFeatures:%v, TerminalInformation:%v, RatType:%v, UlrFlags:%v, UeSrvccCapability:%v, VisitedPlmnId:%v, SgsnNumber:%v, HomogeneousSupportImsVoice:%v, GmlcAddress:%v, ActiveApn:%v, EquivalentPlmnList:%v, MmeNumberForMtSms:%v, SmsRegisterRequest:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.OcSupportedFeatures, m.SupportedFeatures, m.TerminalInformation, m.RatType, m.UlrFlags, m.UeSrvccCapability, m.VisitedPlmnId, m.SgsnNumber, m.HomogeneousSupportImsVoice, m.GmlcAddress, m.ActiveApn, m.EquivalentPlmnList, m.MmeNumberForMtSms, m.SmsRegisterRequest, m.ProxyInfo, m.RouteRecord)
}

// UpdateLocationAnswer represents the Update-Location-Answer (ULA) Diameter command
// Command Code: 316, Application ID: 16777251
type UpdateLocationAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	ErrorDiagnostic             *models_base.Enumerated        // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	OcOlr                       *models_base.Grouped           // Optional
	Load                        []models_base.Grouped          // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	UlaFlags                    *models_base.Unsigned32        // Optional
	SubscriptionData            *models_base.Grouped           // Optional
	ResetId                     []models_base.OctetString      // Optional
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewUpdateLocationAnswer creates a new ULA message
func NewUpdateLocationAnswer() *UpdateLocationAnswer {
	return &UpdateLocationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   316,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in UpdateLocationAnswer
func (m *UpdateLocationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the UpdateLocationAnswer to bytes using a buffer for optimal performance
func (m *UpdateLocationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal ErrorDiagnostic (optional)
	if m.ErrorDiagnostic != nil {
		buf.Write(marshalAVP(1614, *m.ErrorDiagnostic, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal OcOlr (optional)
	if m.OcOlr != nil {
		buf.Write(marshalAVP(623, *m.OcOlr, false, false))
	}

	// Marshal Load (repeated)
	for _, v := range m.Load {
		buf.Write(marshalAVP(650, v, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal UlaFlags (optional)
	if m.UlaFlags != nil {
		buf.Write(marshalAVP(1406, *m.UlaFlags, true, false))
	}

	// Marshal SubscriptionData (optional)
	if m.SubscriptionData != nil {
		buf.Write(marshalAVP(1400, *m.SubscriptionData, true, false))
	}

	// Marshal ResetId (repeated)
	for _, v := range m.ResetId {
		buf.Write(marshalAVP(1670, v, false, false))
	}

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into UpdateLocationAnswer
func (m *UpdateLocationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 1614: // Error-Diagnostic
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.ErrorDiagnostic = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 623: // OC-OLR
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcOlr = &v
			}
		case 650: // Load
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.Load = append(m.Load, val.(models_base.Grouped))
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1406: // ULA-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.UlaFlags = &v
			}
		case 1400: // Subscription-Data
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.SubscriptionData = &v
			}
		case 1670: // Reset-ID
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.ResetId = append(m.ResetId, val.(models_base.OctetString))
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the UpdateLocationAnswer message
func (m *UpdateLocationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of UpdateLocationAnswer
func (m *UpdateLocationAnswer) String() string {
	return fmt.Sprintf("UpdateLocationAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, ResultCode:%v, ExperimentalResult:%v, ErrorDiagnostic:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, SupportedFeatures:%v, UlaFlags:%v, SubscriptionData:%v, ResetId:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.ResultCode, m.ExperimentalResult, m.ErrorDiagnostic, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.OcSupportedFeatures, m.OcOlr, m.Load, m.SupportedFeatures, m.UlaFlags, m.SubscriptionData, m.ResetId, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// AuthenticationInformationRequest represents the Authentication-Information-Request (AIR) Diameter command
// Command Code: 318, Application ID: 16777251
type AuthenticationInformationRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             *models_base.DiameterIdentity  // Optional
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	RequestedEutranAuthInfo     *models_base.Grouped           // Optional
	RequestedUtranGeranAuthInfo *models_base.Grouped           // Optional
	VisitedPlmnId               models_base.OctetString        // Required
	AirFlags                    *models_base.Unsigned32        // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewAuthenticationInformationRequest creates a new AIR message
func NewAuthenticationInformationRequest() *AuthenticationInformationRequest {
	return &AuthenticationInformationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   318,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AuthenticationInformationRequest
func (m *AuthenticationInformationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}
	if m.VisitedPlmnId == "" {
		return fmt.Errorf("required field Visited-PLMN-Id is empty")
	}

	return nil
}

// Marshal serializes the AuthenticationInformationRequest to bytes using a buffer for optimal performance
func (m *AuthenticationInformationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, false, false))
	}

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, false, true))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal RequestedEutranAuthInfo (optional)
	if m.RequestedEutranAuthInfo != nil {
		buf.Write(marshalAVP(1408, *m.RequestedEutranAuthInfo, true, false))
	}

	// Marshal RequestedUtranGeranAuthInfo (optional)
	if m.RequestedUtranGeranAuthInfo != nil {
		buf.Write(marshalAVP(1409, *m.RequestedUtranGeranAuthInfo, true, false))
	}

	// Marshal VisitedPlmnId (required)
	buf.Write(marshalAVP(1407, m.VisitedPlmnId, true, false))

	// Marshal AirFlags (optional)
	if m.AirFlags != nil {
		buf.Write(marshalAVP(1679, *m.AirFlags, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AuthenticationInformationRequest
func (m *AuthenticationInformationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1408: // Requested-EUTRAN-Authentication-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.RequestedEutranAuthInfo = &v
			}
		case 1409: // Requested-UTRAN-GERAN-Authentication-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.RequestedUtranGeranAuthInfo = &v
			}
		case 1407: // Visited-PLMN-Id
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.VisitedPlmnId = val.(models_base.OctetString)
			}
		case 1679: // AIR-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.AirFlags = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AuthenticationInformationRequest message
func (m *AuthenticationInformationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AuthenticationInformationRequest
func (m *AuthenticationInformationRequest) String() string {
	return fmt.Sprintf("AuthenticationInformationRequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, OcSupportedFeatures:%v, SupportedFeatures:%v, RequestedEutranAuthInfo:%v, RequestedUtranGeranAuthInfo:%v, VisitedPlmnId:%v, AirFlags:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.OcSupportedFeatures, m.SupportedFeatures, m.RequestedEutranAuthInfo, m.RequestedUtranGeranAuthInfo, m.VisitedPlmnId, m.AirFlags, m.ProxyInfo, m.RouteRecord)
}

// AuthenticationInformationAnswer represents the Authentication-Information-Answer (AIA) Diameter command
// Command Code: 318, Application ID: 16777251
type AuthenticationInformationAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	ErrorDiagnostic             *models_base.Enumerated        // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	OcOlr                       *models_base.Grouped           // Optional
	Load                        []models_base.Grouped          // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	AuthenticationInfo          *models_base.Grouped           // Optional
	UeUsageType                 *models_base.Unsigned32        // Optional
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewAuthenticationInformationAnswer creates a new AIA message
func NewAuthenticationInformationAnswer() *AuthenticationInformationAnswer {
	return &AuthenticationInformationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   318,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AuthenticationInformationAnswer
func (m *AuthenticationInformationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the AuthenticationInformationAnswer to bytes using a buffer for optimal performance
func (m *AuthenticationInformationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal ErrorDiagnostic (optional)
	if m.ErrorDiagnostic != nil {
		buf.Write(marshalAVP(1614, *m.ErrorDiagnostic, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal OcOlr (optional)
	if m.OcOlr != nil {
		buf.Write(marshalAVP(623, *m.OcOlr, false, false))
	}

	// Marshal Load (repeated)
	for _, v := range m.Load {
		buf.Write(marshalAVP(650, v, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal AuthenticationInfo (optional)
	if m.AuthenticationInfo != nil {
		buf.Write(marshalAVP(1413, *m.AuthenticationInfo, true, false))
	}

	// Marshal UeUsageType (optional)
	if m.UeUsageType != nil {
		buf.Write(marshalAVP(1680, *m.UeUsageType, false, false))
	}

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AuthenticationInformationAnswer
func (m *AuthenticationInformationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 1614: // Error-Diagnostic
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.ErrorDiagnostic = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 623: // OC-OLR
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcOlr = &v
			}
		case 650: // Load
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.Load = append(m.Load, val.(models_base.Grouped))
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1413: // Authentication-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.AuthenticationInfo = &v
			}
		case 1680: // UE-Usage-Type
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.UeUsageType = &v
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AuthenticationInformationAnswer message
func (m *AuthenticationInformationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AuthenticationInformationAnswer
func (m *AuthenticationInformationAnswer) String() string {
	return fmt.Sprintf("AuthenticationInformationAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, ResultCode:%v, ExperimentalResult:%v, ErrorDiagnostic:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, SupportedFeatures:%v, AuthenticationInfo:%v, UeUsageType:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.ResultCode, m.ExperimentalResult, m.ErrorDiagnostic, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.OcSupportedFeatures, m.OcOlr, m.Load, m.SupportedFeatures, m.AuthenticationInfo, m.UeUsageType, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// CancelLocationRequest represents the Cancel-Location-Request (CLR) Diameter command
// Command Code: 317, Application ID: 16777251
type CancelLocationRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	SupportedFeatures           []models_base.Grouped          // Optional
	CancellationType            models_base.Enumerated         // Required
	ClrFlags                    *models_base.Unsigned32        // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewCancelLocationRequest creates a new CLR message
func NewCancelLocationRequest() *CancelLocationRequest {
	return &CancelLocationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   317,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in CancelLocationRequest
func (m *CancelLocationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the CancelLocationRequest to bytes using a buffer for optimal performance
func (m *CancelLocationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, false, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, false, true))

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal CancellationType (required)
	buf.Write(marshalAVP(1420, m.CancellationType, true, false))

	// Marshal ClrFlags (optional)
	if m.ClrFlags != nil {
		buf.Write(marshalAVP(1638, *m.ClrFlags, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CancelLocationRequest
func (m *CancelLocationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1420: // Cancellation-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.CancellationType = val.(models_base.Enumerated)
			}
		case 1638: // CLR-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ClrFlags = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CancelLocationRequest message
func (m *CancelLocationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CancelLocationRequest
func (m *CancelLocationRequest) String() string {
	return fmt.Sprintf("CancelLocationRequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, SupportedFeatures:%v, CancellationType:%v, ClrFlags:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.SupportedFeatures, m.CancellationType, m.ClrFlags, m.ProxyInfo, m.RouteRecord)
}

// CancelLocationAnswer represents the Cancel-Location-Answer (CLA) Diameter command
// Command Code: 317, Application ID: 16777251
type CancelLocationAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewCancelLocationAnswer creates a new CLA message
func NewCancelLocationAnswer() *CancelLocationAnswer {
	return &CancelLocationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   317,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in CancelLocationAnswer
func (m *CancelLocationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the CancelLocationAnswer to bytes using a buffer for optimal performance
func (m *CancelLocationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CancelLocationAnswer
func (m *CancelLocationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CancelLocationAnswer message
func (m *CancelLocationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CancelLocationAnswer
func (m *CancelLocationAnswer) String() string {
	return fmt.Sprintf("CancelLocationAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// InsertSubscriberDataRequest represents the Insert-Subscriber-Data-Request (ISDR) Diameter command
// Command Code: 319, Application ID: 16777251
type InsertSubscriberDataRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	SupportedFeatures           []models_base.Grouped          // Optional
	SubscriptionData            models_base.Grouped            // Required
	IdrFlags                    *models_base.Unsigned32        // Optional
	ResetId                     []models_base.OctetString      // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewInsertSubscriberDataRequest creates a new ISDR message
func NewInsertSubscriberDataRequest() *InsertSubscriberDataRequest {
	return &InsertSubscriberDataRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   319,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in InsertSubscriberDataRequest
func (m *InsertSubscriberDataRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the InsertSubscriberDataRequest to bytes using a buffer for optimal performance
func (m *InsertSubscriberDataRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, false, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, false, true))

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal SubscriptionData (required)
	buf.Write(marshalAVP(1400, m.SubscriptionData, true, false))

	// Marshal IdrFlags (optional)
	if m.IdrFlags != nil {
		buf.Write(marshalAVP(1490, *m.IdrFlags, true, false))
	}

	// Marshal ResetId (repeated)
	for _, v := range m.ResetId {
		buf.Write(marshalAVP(1670, v, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into InsertSubscriberDataRequest
func (m *InsertSubscriberDataRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1400: // Subscription-Data
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SubscriptionData = val.(models_base.Grouped)
			}
		case 1490: // IDR-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.IdrFlags = &v
			}
		case 1670: // Reset-ID
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.ResetId = append(m.ResetId, val.(models_base.OctetString))
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the InsertSubscriberDataRequest message
func (m *InsertSubscriberDataRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of InsertSubscriberDataRequest
func (m *InsertSubscriberDataRequest) String() string {
	return fmt.Sprintf("InsertSubscriberDataRequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, SupportedFeatures:%v, SubscriptionData:%v, IdrFlags:%v, ResetId:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.SupportedFeatures, m.SubscriptionData, m.IdrFlags, m.ResetId, m.ProxyInfo, m.RouteRecord)
}

// InsertSubscriberDataAnswer represents the Insert-Subscriber-Data-Answer (ISDA) Diameter command
// Command Code: 319, Application ID: 16777251
type InsertSubscriberDataAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	ImsVoiceOverPsSupported     *models_base.Enumerated        // Optional
	LastUeActivityTime          *models_base.Time              // Optional
	RatType                     *models_base.Enumerated        // Optional
	IdaFlags                    *models_base.Unsigned32        // Optional
	EpsUserState                *models_base.Grouped           // Optional
	EpsLocationInformation      *models_base.Grouped           // Optional
	LocalTimeZone               *models_base.Grouped           // Optional
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewInsertSubscriberDataAnswer creates a new ISDA message
func NewInsertSubscriberDataAnswer() *InsertSubscriberDataAnswer {
	return &InsertSubscriberDataAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   319,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in InsertSubscriberDataAnswer
func (m *InsertSubscriberDataAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the InsertSubscriberDataAnswer to bytes using a buffer for optimal performance
func (m *InsertSubscriberDataAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal ImsVoiceOverPsSupported (optional)
	if m.ImsVoiceOverPsSupported != nil {
		buf.Write(marshalAVP(1492, *m.ImsVoiceOverPsSupported, true, false))
	}

	// Marshal LastUeActivityTime (optional)
	if m.LastUeActivityTime != nil {
		buf.Write(marshalAVP(1494, *m.LastUeActivityTime, true, false))
	}

	// Marshal RatType (optional)
	if m.RatType != nil {
		buf.Write(marshalAVP(1032, *m.RatType, true, false))
	}

	// Marshal IdaFlags (optional)
	if m.IdaFlags != nil {
		buf.Write(marshalAVP(1441, *m.IdaFlags, true, false))
	}

	// Marshal EpsUserState (optional)
	if m.EpsUserState != nil {
		buf.Write(marshalAVP(1495, *m.EpsUserState, true, false))
	}

	// Marshal EpsLocationInformation (optional)
	if m.EpsLocationInformation != nil {
		buf.Write(marshalAVP(1496, *m.EpsLocationInformation, true, false))
	}

	// Marshal LocalTimeZone (optional)
	if m.LocalTimeZone != nil {
		buf.Write(marshalAVP(1649, *m.LocalTimeZone, false, false))
	}

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into InsertSubscriberDataAnswer
func (m *InsertSubscriberDataAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 1492: // IMS-Voice-Over-PS-Sessions-Supported
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.ImsVoiceOverPsSupported = &v
			}
		case 1494: // Last-UE-Activity-Time
			val, err := models_base.DecodeTime(avpValue)
			if err == nil {
				v := val.(models_base.Time)
				m.LastUeActivityTime = &v
			}
		case 1032: // RAT-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.RatType = &v
			}
		case 1441: // IDA-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.IdaFlags = &v
			}
		case 1495: // EPS-User-State
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.EpsUserState = &v
			}
		case 1496: // EPS-Location-Information
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.EpsLocationInformation = &v
			}
		case 1649: // Local-Time-Zone
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.LocalTimeZone = &v
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the InsertSubscriberDataAnswer message
func (m *InsertSubscriberDataAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of InsertSubscriberDataAnswer
func (m *InsertSubscriberDataAnswer) String() string {
	return fmt.Sprintf("InsertSubscriberDataAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, ImsVoiceOverPsSupported:%v, LastUeActivityTime:%v, RatType:%v, IdaFlags:%v, EpsUserState:%v, EpsLocationInformation:%v, LocalTimeZone:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.ImsVoiceOverPsSupported, m.LastUeActivityTime, m.RatType, m.IdaFlags, m.EpsUserState, m.EpsLocationInformation, m.LocalTimeZone, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// DeleteSubscriberDataRequest represents the Delete-Subscriber-Data-Request (DSDR) Diameter command
// Command Code: 320, Application ID: 16777251
type DeleteSubscriberDataRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	SupportedFeatures           []models_base.Grouped          // Optional
	DsrFlags                    models_base.Unsigned32         // Required
	ContextIdentifier           []models_base.Unsigned32       // Optional
	TraceReference              *models_base.OctetString       // Optional
	TsCode                      []models_base.OctetString      // Optional
	SsCode                      []models_base.OctetString      // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewDeleteSubscriberDataRequest creates a new DSDR message
func NewDeleteSubscriberDataRequest() *DeleteSubscriberDataRequest {
	return &DeleteSubscriberDataRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   320,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in DeleteSubscriberDataRequest
func (m *DeleteSubscriberDataRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the DeleteSubscriberDataRequest to bytes using a buffer for optimal performance
func (m *DeleteSubscriberDataRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, false, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, false, true))

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal DsrFlags (required)
	buf.Write(marshalAVP(1421, m.DsrFlags, true, false))

	// Marshal ContextIdentifier (repeated)
	for _, v := range m.ContextIdentifier {
		buf.Write(marshalAVP(1423, v, true, false))
	}

	// Marshal TraceReference (optional)
	if m.TraceReference != nil {
		buf.Write(marshalAVP(1459, *m.TraceReference, true, false))
	}

	// Marshal TsCode (repeated)
	for _, v := range m.TsCode {
		buf.Write(marshalAVP(1487, v, true, false))
	}

	// Marshal SsCode (repeated)
	for _, v := range m.SsCode {
		buf.Write(marshalAVP(1476, v, true, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeleteSubscriberDataRequest
func (m *DeleteSubscriberDataRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1421: // DSR-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.DsrFlags = val.(models_base.Unsigned32)
			}
		case 1423: // Context-Identifier
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ContextIdentifier = append(m.ContextIdentifier, val.(models_base.Unsigned32))
			}
		case 1459: // Trace-Reference
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.TraceReference = &v
			}
		case 1487: // TS-Code
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.TsCode = append(m.TsCode, val.(models_base.OctetString))
			}
		case 1476: // SS-Code
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.SsCode = append(m.SsCode, val.(models_base.OctetString))
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeleteSubscriberDataRequest message
func (m *DeleteSubscriberDataRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeleteSubscriberDataRequest
func (m *DeleteSubscriberDataRequest) String() string {
	return fmt.Sprintf("DeleteSubscriberDataRequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, SupportedFeatures:%v, DsrFlags:%v, ContextIdentifier:%v, TraceReference:%v, TsCode:%v, SsCode:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.SupportedFeatures, m.DsrFlags, m.ContextIdentifier, m.TraceReference, m.TsCode, m.SsCode, m.ProxyInfo, m.RouteRecord)
}

// DeleteSubscriberDataAnswer represents the Delete-Subscriber-Data-Answer (DSDA) Diameter command
// Command Code: 320, Application ID: 16777251
type DeleteSubscriberDataAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DsaFlags                    *models_base.Unsigned32        // Optional
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewDeleteSubscriberDataAnswer creates a new DSDA message
func NewDeleteSubscriberDataAnswer() *DeleteSubscriberDataAnswer {
	return &DeleteSubscriberDataAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   320,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in DeleteSubscriberDataAnswer
func (m *DeleteSubscriberDataAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DeleteSubscriberDataAnswer to bytes using a buffer for optimal performance
func (m *DeleteSubscriberDataAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DsaFlags (optional)
	if m.DsaFlags != nil {
		buf.Write(marshalAVP(1422, *m.DsaFlags, true, false))
	}

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeleteSubscriberDataAnswer
func (m *DeleteSubscriberDataAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 1422: // DSA-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.DsaFlags = &v
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeleteSubscriberDataAnswer message
func (m *DeleteSubscriberDataAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeleteSubscriberDataAnswer
func (m *DeleteSubscriberDataAnswer) String() string {
	return fmt.Sprintf("DeleteSubscriberDataAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DsaFlags:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DsaFlags, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// PurgeUERequest represents the Purge-UE-Request (PUR) Diameter command
// Command Code: 321, Application ID: 16777251
type PurgeUERequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             *models_base.DiameterIdentity  // Optional
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	PurFlags                    *models_base.Unsigned32        // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	EpsLocationInformation      *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewPurgeUERequest creates a new PUR message
func NewPurgeUERequest() *PurgeUERequest {
	return &PurgeUERequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   321,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in PurgeUERequest
func (m *PurgeUERequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the PurgeUERequest to bytes using a buffer for optimal performance
func (m *PurgeUERequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, false, false))
	}

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, false, true))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal PurFlags (optional)
	if m.PurFlags != nil {
		buf.Write(marshalAVP(1635, *m.PurFlags, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal EpsLocationInformation (optional)
	if m.EpsLocationInformation != nil {
		buf.Write(marshalAVP(1496, *m.EpsLocationInformation, true, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into PurgeUERequest
func (m *PurgeUERequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 1635: // PUR-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.PurFlags = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1496: // EPS-Location-Information
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.EpsLocationInformation = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the PurgeUERequest message
func (m *PurgeUERequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of PurgeUERequest
func (m *PurgeUERequest) String() string {
	return fmt.Sprintf("PurgeUERequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, OcSupportedFeatures:%v, PurFlags:%v, SupportedFeatures:%v, EpsLocationInformation:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.OcSupportedFeatures, m.PurFlags, m.SupportedFeatures, m.EpsLocationInformation, m.ProxyInfo, m.RouteRecord)
}

// PurgeUEAnswer represents the Purge-UE-Answer (PUA) Diameter command
// Command Code: 321, Application ID: 16777251
type PurgeUEAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	OcOlr                       *models_base.Grouped           // Optional
	Load                        []models_base.Grouped          // Optional
	PuaFlags                    *models_base.Unsigned32        // Optional
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewPurgeUEAnswer creates a new PUA message
func NewPurgeUEAnswer() *PurgeUEAnswer {
	return &PurgeUEAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   321,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in PurgeUEAnswer
func (m *PurgeUEAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the PurgeUEAnswer to bytes using a buffer for optimal performance
func (m *PurgeUEAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal OcOlr (optional)
	if m.OcOlr != nil {
		buf.Write(marshalAVP(623, *m.OcOlr, false, false))
	}

	// Marshal Load (repeated)
	for _, v := range m.Load {
		buf.Write(marshalAVP(650, v, false, false))
	}

	// Marshal PuaFlags (optional)
	if m.PuaFlags != nil {
		buf.Write(marshalAVP(1442, *m.PuaFlags, true, false))
	}

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into PurgeUEAnswer
func (m *PurgeUEAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 623: // OC-OLR
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcOlr = &v
			}
		case 650: // Load
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.Load = append(m.Load, val.(models_base.Grouped))
			}
		case 1442: // PUA-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.PuaFlags = &v
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the PurgeUEAnswer message
func (m *PurgeUEAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of PurgeUEAnswer
func (m *PurgeUEAnswer) String() string {
	return fmt.Sprintf("PurgeUEAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, PuaFlags:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.OcSupportedFeatures, m.OcOlr, m.Load, m.PuaFlags, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// ResetRequest represents the Reset-Request (RR) Diameter command
// Command Code: 322, Application ID: 16777251
type ResetRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	SupportedFeatures           []models_base.Grouped          // Optional
	UserId                      []models_base.UTF8String       // Optional
	ResetId                     []models_base.OctetString      // Optional
	SubscriptionData            *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewResetRequest creates a new RR message
func NewResetRequest() *ResetRequest {
	return &ResetRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   322,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ResetRequest
func (m *ResetRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}

	return nil
}

// Marshal serializes the ResetRequest to bytes using a buffer for optimal performance
func (m *ResetRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, m.DestinationHost, false, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal UserId (repeated)
	for _, v := range m.UserId {
		buf.Write(marshalAVP(1444, v, false, false))
	}

	// Marshal ResetId (repeated)
	for _, v := range m.ResetId {
		buf.Write(marshalAVP(1670, v, false, false))
	}

	// Marshal SubscriptionData (optional)
	if m.SubscriptionData != nil {
		buf.Write(marshalAVP(1400, *m.SubscriptionData, true, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ResetRequest
func (m *ResetRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1444: // User-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserId = append(m.UserId, val.(models_base.UTF8String))
			}
		case 1670: // Reset-ID
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.ResetId = append(m.ResetId, val.(models_base.OctetString))
			}
		case 1400: // Subscription-Data
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.SubscriptionData = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ResetRequest message
func (m *ResetRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ResetRequest
func (m *ResetRequest) String() string {
	return fmt.Sprintf("ResetRequest{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, SupportedFeatures:%v, UserId:%v, ResetId:%v, SubscriptionData:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.SupportedFeatures, m.UserId, m.ResetId, m.SubscriptionData, m.ProxyInfo, m.RouteRecord)
}

// ResetAnswer represents the Reset-Answer (RA) Diameter command
// Command Code: 322, Application ID: 16777251
type ResetAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewResetAnswer creates a new RA message
func NewResetAnswer() *ResetAnswer {
	return &ResetAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   322,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ResetAnswer
func (m *ResetAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the ResetAnswer to bytes using a buffer for optimal performance
func (m *ResetAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ResetAnswer
func (m *ResetAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ResetAnswer message
func (m *ResetAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ResetAnswer
func (m *ResetAnswer) String() string {
	return fmt.Sprintf("ResetAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// NotifyRequest represents the Notify-Request (NR) Diameter command
// Command Code: 323, Application ID: 16777251
type NotifyRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	Drmp                        *models_base.Enumerated        // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             *models_base.DiameterIdentity  // Optional
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	TerminalInformation         *models_base.Grouped           // Optional
	Mip6AgentInfo               *models_base.Grouped           // Optional
	VisitedNetworkIdentifier    *models_base.OctetString       // Optional
	ContextIdentifier           *models_base.Unsigned32        // Optional
	ServiceSelection            *models_base.UTF8String        // Optional
	AlertReason                 *models_base.Enumerated        // Optional
	UeSrvccCapability           *models_base.Enumerated        // Optional
	NorFlags                    *models_base.Unsigned32        // Optional
	HomogeneousSupportImsVoice  *models_base.Enumerated        // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewNotifyRequest creates a new NR message
func NewNotifyRequest() *NotifyRequest {
	return &NotifyRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   323,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in NotifyRequest
func (m *NotifyRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the NotifyRequest to bytes using a buffer for optimal performance
func (m *NotifyRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, false, false))
	}

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, false, true))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal TerminalInformation (optional)
	if m.TerminalInformation != nil {
		buf.Write(marshalAVP(1401, *m.TerminalInformation, true, false))
	}

	// Marshal Mip6AgentInfo (optional)
	if m.Mip6AgentInfo != nil {
		buf.Write(marshalAVP(486, *m.Mip6AgentInfo, true, false))
	}

	// Marshal VisitedNetworkIdentifier (optional)
	if m.VisitedNetworkIdentifier != nil {
		buf.Write(marshalAVP(600, *m.VisitedNetworkIdentifier, true, false))
	}

	// Marshal ContextIdentifier (optional)
	if m.ContextIdentifier != nil {
		buf.Write(marshalAVP(1423, *m.ContextIdentifier, true, false))
	}

	// Marshal ServiceSelection (optional)
	if m.ServiceSelection != nil {
		buf.Write(marshalAVP(493, *m.ServiceSelection, true, false))
	}

	// Marshal AlertReason (optional)
	if m.AlertReason != nil {
		buf.Write(marshalAVP(1434, *m.AlertReason, true, false))
	}

	// Marshal UeSrvccCapability (optional)
	if m.UeSrvccCapability != nil {
		buf.Write(marshalAVP(1615, *m.UeSrvccCapability, true, false))
	}

	// Marshal NorFlags (optional)
	if m.NorFlags != nil {
		buf.Write(marshalAVP(1443, *m.NorFlags, true, false))
	}

	// Marshal HomogeneousSupportImsVoice (optional)
	if m.HomogeneousSupportImsVoice != nil {
		buf.Write(marshalAVP(1493, *m.HomogeneousSupportImsVoice, true, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into NotifyRequest
func (m *NotifyRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 1401: // Terminal-Information
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.TerminalInformation = &v
			}
		case 486: // MIP6-Agent-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.Mip6AgentInfo = &v
			}
		case 600: // Visited-Network-Identifier
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.VisitedNetworkIdentifier = &v
			}
		case 1423: // Context-Identifier
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ContextIdentifier = &v
			}
		case 493: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ServiceSelection = &v
			}
		case 1434: // Alert-Reason
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.AlertReason = &v
			}
		case 1615: // UE-SRVCC-Capability
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.UeSrvccCapability = &v
			}
		case 1443: // NOR-Flags
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.NorFlags = &v
			}
		case 1493: // Homogeneous-Support-of-IMS-Voice-Over-PS-Sessions
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.HomogeneousSupportImsVoice = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the NotifyRequest message
func (m *NotifyRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of NotifyRequest
func (m *NotifyRequest) String() string {
	return fmt.Sprintf("NotifyRequest{SessionId:%v, VendorSpecificApplicationId:%v, Drmp:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, OcSupportedFeatures:%v, SupportedFeatures:%v, TerminalInformation:%v, Mip6AgentInfo:%v, VisitedNetworkIdentifier:%v, ContextIdentifier:%v, ServiceSelection:%v, AlertReason:%v, UeSrvccCapability:%v, NorFlags:%v, HomogeneousSupportImsVoice:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.VendorSpecificApplicationId, m.Drmp, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.OcSupportedFeatures, m.SupportedFeatures, m.TerminalInformation, m.Mip6AgentInfo, m.VisitedNetworkIdentifier, m.ContextIdentifier, m.ServiceSelection, m.AlertReason, m.UeSrvccCapability, m.NorFlags, m.HomogeneousSupportImsVoice, m.ProxyInfo, m.RouteRecord)
}

// NotifyAnswer represents the Notify-Answer (NA) Diameter command
// Command Code: 323, Application ID: 16777251
type NotifyAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *models_base.Grouped           // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *models_base.Grouped           // Optional
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	OcSupportedFeatures         *models_base.Grouped           // Optional
	OcOlr                       *models_base.Grouped           // Optional
	Load                        []models_base.Grouped          // Optional
	SupportedFeatures           []models_base.Grouped          // Optional
	FailedAvp                   *models_base.Grouped           // Optional
	ProxyInfo                   []models_base.Grouped          // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewNotifyAnswer creates a new NA message
func NewNotifyAnswer() *NotifyAnswer {
	return &NotifyAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   323,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in NotifyAnswer
func (m *NotifyAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the NotifyAnswer to bytes using a buffer for optimal performance
func (m *NotifyAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(301, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (optional)
	if m.VendorSpecificApplicationId != nil {
		buf.Write(marshalAVP(260, *m.VendorSpecificApplicationId, false, false))
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (optional)
	if m.ExperimentalResult != nil {
		buf.Write(marshalAVP(297, *m.ExperimentalResult, true, false))
	}

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal OcSupportedFeatures (optional)
	if m.OcSupportedFeatures != nil {
		buf.Write(marshalAVP(621, *m.OcSupportedFeatures, false, false))
	}

	// Marshal OcOlr (optional)
	if m.OcOlr != nil {
		buf.Write(marshalAVP(623, *m.OcOlr, false, false))
	}

	// Marshal Load (repeated)
	for _, v := range m.Load {
		buf.Write(marshalAVP(650, v, false, false))
	}

	// Marshal SupportedFeatures (repeated)
	for _, v := range m.SupportedFeatures {
		buf.Write(marshalAVP(628, v, false, false))
	}

	// Marshal FailedAvp (optional)
	if m.FailedAvp != nil {
		buf.Write(marshalAVP(279, *m.FailedAvp, false, false))
	}

	// Marshal ProxyInfo (repeated)
	for _, v := range m.ProxyInfo {
		buf.Write(marshalAVP(284, v, false, false))
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, false, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into NotifyAnswer
func (m *NotifyAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 301: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case 260: // Vendor-Specific-Application-Id
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.VendorSpecificApplicationId = &v
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.ExperimentalResult = &v
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 621: // OC-Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcSupportedFeatures = &v
			}
		case 623: // OC-OLR
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.OcOlr = &v
			}
		case 650: // Load
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.Load = append(m.Load, val.(models_base.Grouped))
			}
		case 628: // Supported-Features
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.SupportedFeatures = append(m.SupportedFeatures, val.(models_base.Grouped))
			}
		case 279: // Failed-AVP
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				v := val.(models_base.Grouped)
				m.FailedAvp = &v
			}
		case 284: // Proxy-Info
			val, err := models_base.DecodeGrouped(avpValue)
			if err == nil {
				m.ProxyInfo = append(m.ProxyInfo, val.(models_base.Grouped))
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the NotifyAnswer message
func (m *NotifyAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of NotifyAnswer
func (m *NotifyAnswer) String() string {
	return fmt.Sprintf("NotifyAnswer{SessionId:%v, Drmp:%v, VendorSpecificApplicationId:%v, ResultCode:%v, ExperimentalResult:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, SupportedFeatures:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.Drmp, m.VendorSpecificApplicationId, m.ResultCode, m.ExperimentalResult, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.OcSupportedFeatures, m.OcOlr, m.Load, m.SupportedFeatures, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}
