// Code generated by diameter-codegen. DO NOT EDIT.

package s6a

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/hsdfat8/diam-gw/models_base"
)

// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

// Grouped AVP structures

// GERANVector represents the GERAN-Vector grouped AVP (AVP Code 1416)
type GERANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Sres       models_base.OctetString // Required
	Kc         models_base.OctetString // Required
}

// Marshal serializes GERANVector to bytes
func (g *GERANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeITEMNUMBER, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(AVPCodeRAND, g.Rand, true, false, 10415))

	// Marshal Sres (required)
	buf.Write(marshalAVPWithVendor(AVPCodeSRES, g.Sres, true, false, 10415))

	// Marshal Kc (required)
	buf.Write(marshalAVPWithVendor(AVPCodeKC, g.Kc, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into GERANVector
func (g *GERANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeITEMNUMBER: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case AVPCodeRAND: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case AVPCodeSRES: // SRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Sres = val.(models_base.OctetString)
			}
		case AVPCodeKC: // Kc
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Kc = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AMBR represents the AMBR grouped AVP (AVP Code 1435)
type AMBR struct {
	MaxRequestedBandwidthUl  models_base.OctetString  // Required - WARNING: AVP code not defined, DO NOT USE
	MaxRequestedBandwidthDl  models_base.OctetString  // Required - WARNING: AVP code not defined, DO NOT USE
	ExtendedMaxRequestedBwUl *models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ExtendedMaxRequestedBwDl *models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes AMBR to bytes
func (g *AMBR) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Skipping MaxRequestedBandwidthUl - AVP code not defined

	// Skipping MaxRequestedBandwidthDl - AVP code not defined

	// Skipping ExtendedMaxRequestedBwUl - AVP code not defined

	// Skipping ExtendedMaxRequestedBwDl - AVP code not defined

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AMBR
func (g *AMBR) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// VendorSpecificApplicationId represents the Vendor-Specific-Application-Id grouped AVP (AVP Code 260)
type VendorSpecificApplicationId struct {
	VendorId          *models_base.Unsigned32 // Optional
	AuthApplicationId *models_base.Unsigned32 // Optional
	AcctApplicationId *models_base.Unsigned32 // Optional
}

// Marshal serializes VendorSpecificApplicationId to bytes
func (g *VendorSpecificApplicationId) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VendorId (optional)
	if g.VendorId != nil {
		buf.Write(marshalAVP(AVPCodeVENDORID, *g.VendorId, true, false))
	}

	// Marshal AuthApplicationId (optional)
	if g.AuthApplicationId != nil {
		buf.Write(marshalAVP(AVPCodeAUTHAPPLICATIONID, *g.AuthApplicationId, true, false))
	}

	// Marshal AcctApplicationId (optional)
	if g.AcctApplicationId != nil {
		buf.Write(marshalAVP(AVPCodeACCTAPPLICATIONID, *g.AcctApplicationId, true, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into VendorSpecificApplicationId
func (g *VendorSpecificApplicationId) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeVENDORID: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.VendorId = &v
			}
		case AVPCodeAUTHAPPLICATIONID: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AuthApplicationId = &v
			}
		case AVPCodeACCTAPPLICATIONID: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AcctApplicationId = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// RequestedEUTRANAuthenticationInfo represents the Requested-EUTRAN-Authentication-Info grouped AVP (AVP Code 1408)
type RequestedEUTRANAuthenticationInfo struct {
	NumberOfRequestedVectors   *models_base.Unsigned32  // Optional
	ImmediateResponsePreferred *models_base.Unsigned32  // Optional
	ReSynchronizationInfo      *models_base.OctetString // Optional
}

// Marshal serializes RequestedEUTRANAuthenticationInfo to bytes
func (g *RequestedEUTRANAuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal NumberOfRequestedVectors (optional)
	if g.NumberOfRequestedVectors != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeNUMBEROFREQUESTEDVECTORS, *g.NumberOfRequestedVectors, true, false, 10415))
	}

	// Marshal ImmediateResponsePreferred (optional)
	if g.ImmediateResponsePreferred != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeIMMEDIATERESPONSEPREFERRED, *g.ImmediateResponsePreferred, true, false, 10415))
	}

	// Marshal ReSynchronizationInfo (optional)
	if g.ReSynchronizationInfo != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeRESYNCHRONIZATIONINFO, *g.ReSynchronizationInfo, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into RequestedEUTRANAuthenticationInfo
func (g *RequestedEUTRANAuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeNUMBEROFREQUESTEDVECTORS: // Number-Of-Requested-Vectors
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.NumberOfRequestedVectors = &v
			}
		case AVPCodeIMMEDIATERESPONSEPREFERRED: // Immediate-Response-Preferred
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ImmediateResponsePreferred = &v
			}
		case AVPCodeRESYNCHRONIZATIONINFO: // Re-Synchronization-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ReSynchronizationInfo = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// ProxyInfo represents the Proxy-Info grouped AVP (AVP Code 284)
type ProxyInfo struct {
	ProxyHost  models_base.DiameterIdentity // Required
	ProxyState *models_base.OctetString     // Optional
}

// Marshal serializes ProxyInfo to bytes
func (g *ProxyInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ProxyHost (required)
	buf.Write(marshalAVP(AVPCodePROXYHOST, g.ProxyHost, true, false))

	// Marshal ProxyState (optional)
	if g.ProxyState != nil {
		buf.Write(marshalAVP(AVPCodePROXYSTATE, *g.ProxyState, true, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into ProxyInfo
func (g *ProxyInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodePROXYHOST: // Proxy-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.ProxyHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodePROXYSTATE: // Proxy-State
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ProxyState = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// APNConfigurationProfile represents the APN-Configuration-Profile grouped AVP (AVP Code 1429)
type APNConfigurationProfile struct {
	ContextIdentifier    models_base.Unsigned32 // Required
	AllApnConfigIncluded models_base.Enumerated // Required
	ApnConfiguration     []*APNConfiguration    // Optional
}

// Marshal serializes APNConfigurationProfile to bytes
func (g *APNConfigurationProfile) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ContextIdentifier (required)
	buf.Write(marshalAVPWithVendor(AVPCodeCONTEXTIDENTIFIER, g.ContextIdentifier, true, false, 10415))

	// Marshal AllApnConfigIncluded (required)
	buf.Write(marshalAVPWithVendor(AVPCodeALLAPNCONFIGURATIONSINCLUDEDINDICATOR, g.AllApnConfigIncluded, true, false, 10415))

	// Marshal ApnConfiguration (repeated, grouped)
	for _, v := range g.ApnConfiguration {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(AVPCodeAPNCONFIGURATION, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into APNConfigurationProfile
func (g *APNConfigurationProfile) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeCONTEXTIDENTIFIER: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ContextIdentifier = val.(models_base.Unsigned32)
			}
		case AVPCodeALLAPNCONFIGURATIONSINCLUDEDINDICATOR: // All-APN-Configurations-Included-Indicator
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				g.AllApnConfigIncluded = val.(models_base.Enumerated)
			}
		case AVPCodeAPNCONFIGURATION: // APN-Configuration
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &APNConfiguration{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ApnConfiguration = append(g.ApnConfiguration, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// UTRANVector represents the UTRAN-Vector grouped AVP (AVP Code 1415)
type UTRANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Xres       models_base.OctetString // Required
	Autn       models_base.OctetString // Required
	Ck         models_base.OctetString // Required
	Ik         models_base.OctetString // Required
}

// Marshal serializes UTRANVector to bytes
func (g *UTRANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeITEMNUMBER, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(AVPCodeRAND, g.Rand, true, false, 10415))

	// Marshal Xres (required)
	buf.Write(marshalAVPWithVendor(AVPCodeXRES, g.Xres, true, false, 10415))

	// Marshal Autn (required)
	buf.Write(marshalAVPWithVendor(AVPCodeAUTN, g.Autn, true, false, 10415))

	// Marshal Ck (required)
	buf.Write(marshalAVPWithVendor(AVPCodeCONFIDENTIALITYKEY, g.Ck, true, false, 10415))

	// Marshal Ik (required)
	buf.Write(marshalAVPWithVendor(AVPCodeINTEGRITYKEY, g.Ik, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into UTRANVector
func (g *UTRANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeITEMNUMBER: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case AVPCodeRAND: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case AVPCodeXRES: // XRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Xres = val.(models_base.OctetString)
			}
		case AVPCodeAUTN: // AUTN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Autn = val.(models_base.OctetString)
			}
		case AVPCodeCONFIDENTIALITYKEY: // Confidentiality-Key
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Ck = val.(models_base.OctetString)
			}
		case AVPCodeINTEGRITYKEY: // Integrity-Key
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Ik = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AuthenticationInfo represents the Authentication-Info grouped AVP (AVP Code 1413)
type AuthenticationInfo struct {
	EUtranVector []*EUTRANVector // Optional
	UtranVector  []*UTRANVector  // Optional
	GeranVector  []*GERANVector  // Optional
}

// Marshal serializes AuthenticationInfo to bytes
func (g *AuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal EUtranVector (repeated, grouped)
	for _, v := range g.EUtranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(AVPCodeEUTRANVECTOR, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal UtranVector (repeated, grouped)
	for _, v := range g.UtranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(AVPCodeUTRANVECTOR, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal GeranVector (repeated, grouped)
	for _, v := range g.GeranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(AVPCodeGERANVECTOR, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AuthenticationInfo
func (g *AuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeEUTRANVECTOR: // E-UTRAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EUTRANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EUtranVector = append(g.EUtranVector, grouped)
			}
		case AVPCodeUTRANVECTOR: // UTRAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &UTRANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.UtranVector = append(g.UtranVector, grouped)
			}
		case AVPCodeGERANVECTOR: // GERAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &GERANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.GeranVector = append(g.GeranVector, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MIPHomeAgentHost represents the MIP-Home-Agent-Host grouped AVP (AVP Code 348)
type MIPHomeAgentHost struct {
	DestinationRealm models_base.DiameterIdentity // Required
	DestinationHost  models_base.DiameterIdentity // Required
}

// Marshal serializes MIPHomeAgentHost to bytes
func (g *MIPHomeAgentHost) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, g.DestinationRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, g.DestinationHost, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into MIPHomeAgentHost
func (g *MIPHomeAgentHost) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.DestinationHost = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// E2ESequence represents the E2E-Sequence grouped AVP (AVP Code 300)
type E2ESequence struct {
	Avp models_base.OctetString // Required - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes E2ESequence to bytes
func (g *E2ESequence) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Skipping Avp - AVP code not defined

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into E2ESequence
func (g *E2ESequence) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MIP6AgentInfo represents the MIP6-Agent-Info grouped AVP (AVP Code 486)
type MIP6AgentInfo struct {
	MipHomeAgentAddress []models_base.Address    // Optional
	MipHomeAgentHost    *MIPHomeAgentHost        // Optional
	Mip6HomeLinkPrefix  *models_base.OctetString // Optional
}

// Marshal serializes MIP6AgentInfo to bytes
func (g *MIP6AgentInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal MipHomeAgentAddress (repeated)
	for _, v := range g.MipHomeAgentAddress {
		buf.Write(marshalAVP(AVPCodeMIPHOMEAGENTADDRESS, v, true, false))
	}

	// Marshal MipHomeAgentHost (grouped)
	if g.MipHomeAgentHost != nil {
		if groupedData, err := g.MipHomeAgentHost.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeMIPHOMEAGENTHOST, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal Mip6HomeLinkPrefix (optional)
	if g.Mip6HomeLinkPrefix != nil {
		buf.Write(marshalAVP(AVPCodeMIP6HOMELINKPREFIX, *g.Mip6HomeLinkPrefix, true, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into MIP6AgentInfo
func (g *MIP6AgentInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeMIPHOMEAGENTADDRESS: // MIP-Home-Agent-Address
			val, err := models_base.DecodeAddress(avpValue)
			if err == nil {
				g.MipHomeAgentAddress = append(g.MipHomeAgentAddress, val.(models_base.Address))
			}
		case AVPCodeMIPHOMEAGENTHOST: // MIP-Home-Agent-Host
			grouped := &MIPHomeAgentHost{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.MipHomeAgentHost = grouped
			}
		case AVPCodeMIP6HOMELINKPREFIX: // MIP6-Home-Link-Prefix
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Mip6HomeLinkPrefix = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// TerminalInformation represents the Terminal-Information grouped AVP (AVP Code 1401)
type TerminalInformation struct {
	Imei            *models_base.UTF8String  // Optional
	Meid            *models_base.OctetString // Optional
	SoftwareVersion *models_base.UTF8String  // Optional
}

// Marshal serializes TerminalInformation to bytes
func (g *TerminalInformation) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal Imei (optional)
	if g.Imei != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeIMEI, *g.Imei, true, false, 10415))
	}

	// Marshal Meid (optional)
	if g.Meid != nil {
		buf.Write(marshalAVPWithVendor(AVPCode3GPP2MEID, *g.Meid, true, false, 10415))
	}

	// Marshal SoftwareVersion (optional)
	if g.SoftwareVersion != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeSOFTWAREVERSION, *g.SoftwareVersion, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into TerminalInformation
func (g *TerminalInformation) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeIMEI: // IMEI
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.Imei = &v
			}
		case AVPCode3GPP2MEID: // 3GPP2-MEID
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Meid = &v
			}
		case AVPCodeSOFTWAREVERSION: // Software-Version
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.SoftwareVersion = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EUTRANVector represents the E-UTRAN-Vector grouped AVP (AVP Code 1414)
type EUTRANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Xres       models_base.OctetString // Required
	Autn       models_base.OctetString // Required
	Kasme      models_base.OctetString // Required
}

// Marshal serializes EUTRANVector to bytes
func (g *EUTRANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeITEMNUMBER, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(AVPCodeRAND, g.Rand, true, false, 10415))

	// Marshal Xres (required)
	buf.Write(marshalAVPWithVendor(AVPCodeXRES, g.Xres, true, false, 10415))

	// Marshal Autn (required)
	buf.Write(marshalAVPWithVendor(AVPCodeAUTN, g.Autn, true, false, 10415))

	// Marshal Kasme (required)
	buf.Write(marshalAVPWithVendor(AVPCodeKASME, g.Kasme, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EUTRANVector
func (g *EUTRANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeITEMNUMBER: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case AVPCodeRAND: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case AVPCodeXRES: // XRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Xres = val.(models_base.OctetString)
			}
		case AVPCodeAUTN: // AUTN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Autn = val.(models_base.OctetString)
			}
		case AVPCodeKASME: // KASME
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Kasme = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// CSGSubscriptionData represents the CSG-Subscription-Data grouped AVP (AVP Code 1436)
type CSGSubscriptionData struct {
	CsgId            models_base.OctetString  // Required - WARNING: AVP code not defined, DO NOT USE
	ExpirationDate   *models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ServiceSelection []models_base.UTF8String // Optional
	VisitedPlmnId    *models_base.OctetString // Optional
}

// Marshal serializes CSGSubscriptionData to bytes
func (g *CSGSubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Skipping CsgId - AVP code not defined

	// Skipping ExpirationDate - AVP code not defined

	// Marshal ServiceSelection (repeated)
	for _, v := range g.ServiceSelection {
		buf.Write(marshalAVP(AVPCodeSERVICESELECTION, v, true, false))
	}

	// Marshal VisitedPlmnId (optional)
	if g.VisitedPlmnId != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeVISITEDPLMNID, *g.VisitedPlmnId, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into CSGSubscriptionData
func (g *CSGSubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		// case 0: // CSG-Id (AVP code not defined)
		// case 0: // Expiration-Date (AVP code not defined)
		case AVPCodeSERVICESELECTION: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				g.ServiceSelection = append(g.ServiceSelection, val.(models_base.UTF8String))
			}
		case AVPCodeVISITEDPLMNID: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.VisitedPlmnId = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// APNConfiguration represents the APN-Configuration grouped AVP (AVP Code 1430)
type APNConfiguration struct {
	ContextIdentifier           models_base.Unsigned32    // Required
	ServedPartyIpAddress        []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	PdnType                     models_base.OctetString   // Required - WARNING: AVP code not defined, DO NOT USE
	ServiceSelection            models_base.UTF8String    // Required
	EpsSubscribedQosProfile     *EPSSubscribedQoSProfile  // Optional
	VplmnDynamicAddressAllowed  *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	Mip6AgentInfo               *MIP6AgentInfo            // Optional
	VisitedNetworkIdentifier    *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	PdnGwAllocationType         *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ChargingCharacteristics     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	Ambr                        *AMBR                     // Optional
	SpecificApnInfo             []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ApnOiReplacement            *models_base.UTF8String   // Optional
	SiptoPermission             *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	LipaPermission              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	RestorationPriority         *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SiptoLocalNetworkPermission *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	WlanOffloadability          *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	NonIpPdnTypeIndicator       *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	NonIpDataDeliveryMechanism  *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ScefId                      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ScefRealm                   *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	PreferredDataMode           *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	PdnConnectionContinuity     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes APNConfiguration to bytes
func (g *APNConfiguration) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ContextIdentifier (required)
	buf.Write(marshalAVPWithVendor(AVPCodeCONTEXTIDENTIFIER, g.ContextIdentifier, true, false, 10415))

	// Skipping ServedPartyIpAddress - AVP code not defined

	// Skipping PdnType - AVP code not defined

	// Marshal ServiceSelection (required)
	buf.Write(marshalAVP(AVPCodeSERVICESELECTION, g.ServiceSelection, true, false))

	// Marshal EpsSubscribedQosProfile (grouped)
	if g.EpsSubscribedQosProfile != nil {
		if groupedData, err := g.EpsSubscribedQosProfile.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeEPSSUBSCRIBEDQOSPROFILE, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Skipping VplmnDynamicAddressAllowed - AVP code not defined

	// Marshal Mip6AgentInfo (grouped)
	if g.Mip6AgentInfo != nil {
		if groupedData, err := g.Mip6AgentInfo.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeMIP6AGENTINFO, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping VisitedNetworkIdentifier - AVP code not defined

	// Skipping PdnGwAllocationType - AVP code not defined

	// Skipping ChargingCharacteristics - AVP code not defined

	// Marshal Ambr (grouped)
	if g.Ambr != nil {
		if groupedData, err := g.Ambr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeAMBR, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Skipping SpecificApnInfo - AVP code not defined

	// Marshal ApnOiReplacement (optional)
	if g.ApnOiReplacement != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeAPNOIREPLACEMENT, *g.ApnOiReplacement, true, false, 10415))
	}

	// Skipping SiptoPermission - AVP code not defined

	// Skipping LipaPermission - AVP code not defined

	// Skipping RestorationPriority - AVP code not defined

	// Skipping SiptoLocalNetworkPermission - AVP code not defined

	// Skipping WlanOffloadability - AVP code not defined

	// Skipping NonIpPdnTypeIndicator - AVP code not defined

	// Skipping NonIpDataDeliveryMechanism - AVP code not defined

	// Skipping ScefId - AVP code not defined

	// Skipping ScefRealm - AVP code not defined

	// Skipping PreferredDataMode - AVP code not defined

	// Skipping PdnConnectionContinuity - AVP code not defined

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into APNConfiguration
func (g *APNConfiguration) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeCONTEXTIDENTIFIER: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ContextIdentifier = val.(models_base.Unsigned32)
			}
		// case 0: // Served-Party-IP-Address (AVP code not defined)
		// case 0: // PDN-Type (AVP code not defined)
		case AVPCodeSERVICESELECTION: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				g.ServiceSelection = val.(models_base.UTF8String)
			}
		case AVPCodeEPSSUBSCRIBEDQOSPROFILE: // EPS-Subscribed-QoS-Profile
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EPSSubscribedQoSProfile{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EpsSubscribedQosProfile = grouped
			}
		// case 0: // VPLMN-Dynamic-Address-Allowed (AVP code not defined)
		case AVPCodeMIP6AGENTINFO: // MIP6-Agent-Info
			grouped := &MIP6AgentInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Mip6AgentInfo = grouped
			}
		// case 0: // Visited-Network-Identifier (AVP code not defined)
		// case 0: // PDN-GW-Allocation-Type (AVP code not defined)
		// case 0: // 3GPP-Charging-Characteristics (AVP code not defined)
		case AVPCodeAMBR: // AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AMBR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Ambr = grouped
			}
		// case 0: // Specific-APN-Info (AVP code not defined)
		case AVPCodeAPNOIREPLACEMENT: // APN-OI-Replacement
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.ApnOiReplacement = &v
			}
			// case 0: // SIPTO-Permission (AVP code not defined)
			// case 0: // LIPA-Permission (AVP code not defined)
			// case 0: // Restoration-Priority (AVP code not defined)
			// case 0: // SIPTO-Local-Network-Permission (AVP code not defined)
			// case 0: // WLAN-offloadability (AVP code not defined)
			// case 0: // Non-IP-PDN-Type-Indicator (AVP code not defined)
			// case 0: // Non-IP-Data-Delivery-Mechanism (AVP code not defined)
			// case 0: // SCEF-ID (AVP code not defined)
			// case 0: // SCEF-Realm (AVP code not defined)
			// case 0: // Preferred-Data-Mode (AVP code not defined)
			// case 0: // PDN-Connection-Continuity (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// FailedAVP represents the Failed-AVP grouped AVP (AVP Code 279)
type FailedAVP struct {
	AVP []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes FailedAVP to bytes
func (g *FailedAVP) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Skipping AVP - AVP code not defined

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into FailedAVP
func (g *FailedAVP) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EPSSubscribedQoSProfile represents the EPS-Subscribed-QoS-Profile grouped AVP (AVP Code 1431)
type EPSSubscribedQoSProfile struct {
	QosClassIdentifier          models_base.OctetString // Required - WARNING: AVP code not defined, DO NOT USE
	AllocationRetentionPriority models_base.OctetString // Required - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes EPSSubscribedQoSProfile to bytes
func (g *EPSSubscribedQoSProfile) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Skipping QosClassIdentifier - AVP code not defined

	// Skipping AllocationRetentionPriority - AVP code not defined

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EPSSubscribedQoSProfile
func (g *EPSSubscribedQoSProfile) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// SubscriptionData represents the Subscription-Data grouped AVP (AVP Code 1400)
type SubscriptionData struct {
	SubscriberStatus                     *models_base.Enumerated   // Optional
	Msisdn                               *models_base.OctetString  // Optional
	AMsisdn                              *models_base.OctetString  // Optional
	StnSr                                *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	IcsIndicator                         *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	NetworkAccessMode                    *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	OperatorDeterminedBarring            *models_base.Unsigned32   // Optional
	HplmnOdb                             *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	RegionalSubscriptionZoneCode         []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	AccessRestrictionData                *models_base.Unsigned32   // Optional
	ApnOiReplacement                     *models_base.UTF8String   // Optional
	LcsInfo                              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	TeleserviceList                      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	CallBarringInfo                      []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	ChargingCharacteristics              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	Ambr                                 *AMBR                     // Optional
	ApnConfigurationProfile              *APNConfigurationProfile  // Optional
	RatFrequencySelectionPriorityId      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	TraceData                            *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	GprsSubscriptionData                 *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	CsgSubscriptionData                  []*CSGSubscriptionData    // Optional
	RoamingRestricted                    *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SubscribedPeriodicRauTauTimer        *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	MpsPriority                          *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	VplmnLipaAllowed                     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	RelayNodeIndicator                   *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	MdtUserConsent                       *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SubscribedVsrvcc                     *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ProseSubscriptionData                *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	SubscriptionDataFlags                *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	AdjacentAccessRestrictionData        []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	DlBufferingSuggestedPacketCount      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ImsiGroupId                          []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	UeUsageType                          *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	AeseCommunicationPattern             []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	MonitoringEventConfiguration         []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
	EmergencyInfo                        *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	V2xSubscriptionData                  *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	EdrxCycleLength                      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ExternalIdentifier                   *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ActiveTime                           *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	ServiceGapTime                       *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	BroadcastLocationAssistanceDataTypes *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	AerialUeSubscriptionInformation      *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
	CoreNetworkRestrictions              *models_base.OctetString  // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes SubscriptionData to bytes
func (g *SubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal SubscriberStatus (optional)
	if g.SubscriberStatus != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeSUBSCRIBERSTATUS, *g.SubscriberStatus, true, false, 10415))
	}

	// Marshal Msisdn (optional)
	if g.Msisdn != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeMSISDN, *g.Msisdn, true, false, 10415))
	}

	// Marshal AMsisdn (optional)
	if g.AMsisdn != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeAMSISDN, *g.AMsisdn, true, false, 10415))
	}

	// Skipping StnSr - AVP code not defined

	// Skipping IcsIndicator - AVP code not defined

	// Skipping NetworkAccessMode - AVP code not defined

	// Marshal OperatorDeterminedBarring (optional)
	if g.OperatorDeterminedBarring != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeOPERATORDETERMINEDBARRING, *g.OperatorDeterminedBarring, true, false, 10415))
	}

	// Skipping HplmnOdb - AVP code not defined

	// Skipping RegionalSubscriptionZoneCode - AVP code not defined

	// Marshal AccessRestrictionData (optional)
	if g.AccessRestrictionData != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeACCESSRESTRICTIONDATA, *g.AccessRestrictionData, true, false, 10415))
	}

	// Marshal ApnOiReplacement (optional)
	if g.ApnOiReplacement != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeAPNOIREPLACEMENT, *g.ApnOiReplacement, true, false, 10415))
	}

	// Skipping LcsInfo - AVP code not defined

	// Skipping TeleserviceList - AVP code not defined

	// Skipping CallBarringInfo - AVP code not defined

	// Skipping ChargingCharacteristics - AVP code not defined

	// Marshal Ambr (grouped)
	if g.Ambr != nil {
		if groupedData, err := g.Ambr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeAMBR, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal ApnConfigurationProfile (grouped)
	if g.ApnConfigurationProfile != nil {
		if groupedData, err := g.ApnConfigurationProfile.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeAPNCONFIGURATIONPROFILE, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Skipping RatFrequencySelectionPriorityId - AVP code not defined

	// Skipping TraceData - AVP code not defined

	// Skipping GprsSubscriptionData - AVP code not defined

	// Marshal CsgSubscriptionData (repeated, grouped)
	for _, v := range g.CsgSubscriptionData {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(AVPCodeCSGSUBSCRIPTIONDATA, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Skipping RoamingRestricted - AVP code not defined

	// Skipping SubscribedPeriodicRauTauTimer - AVP code not defined

	// Skipping MpsPriority - AVP code not defined

	// Skipping VplmnLipaAllowed - AVP code not defined

	// Skipping RelayNodeIndicator - AVP code not defined

	// Skipping MdtUserConsent - AVP code not defined

	// Skipping SubscribedVsrvcc - AVP code not defined

	// Skipping ProseSubscriptionData - AVP code not defined

	// Skipping SubscriptionDataFlags - AVP code not defined

	// Skipping AdjacentAccessRestrictionData - AVP code not defined

	// Skipping DlBufferingSuggestedPacketCount - AVP code not defined

	// Skipping ImsiGroupId - AVP code not defined

	// Skipping UeUsageType - AVP code not defined

	// Skipping AeseCommunicationPattern - AVP code not defined

	// Skipping MonitoringEventConfiguration - AVP code not defined

	// Skipping EmergencyInfo - AVP code not defined

	// Skipping V2xSubscriptionData - AVP code not defined

	// Skipping EdrxCycleLength - AVP code not defined

	// Skipping ExternalIdentifier - AVP code not defined

	// Skipping ActiveTime - AVP code not defined

	// Skipping ServiceGapTime - AVP code not defined

	// Skipping BroadcastLocationAssistanceDataTypes - AVP code not defined

	// Skipping AerialUeSubscriptionInformation - AVP code not defined

	// Skipping CoreNetworkRestrictions - AVP code not defined

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into SubscriptionData
func (g *SubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSUBSCRIBERSTATUS: // Subscriber-Status
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.SubscriberStatus = &v
			}
		case AVPCodeMSISDN: // MSISDN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Msisdn = &v
			}
		case AVPCodeAMSISDN: // A-MSISDN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.AMsisdn = &v
			}
		// case 0: // STN-SR (AVP code not defined)
		// case 0: // ICS-Indicator (AVP code not defined)
		// case 0: // Network-Access-Mode (AVP code not defined)
		case AVPCodeOPERATORDETERMINEDBARRING: // Operator-Determined-Barring
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.OperatorDeterminedBarring = &v
			}
		// case 0: // HPLMN-ODB (AVP code not defined)
		// case 0: // Regional-Subscription-Zone-Code (AVP code not defined)
		case AVPCodeACCESSRESTRICTIONDATA: // Access-Restriction-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AccessRestrictionData = &v
			}
		case AVPCodeAPNOIREPLACEMENT: // APN-OI-Replacement
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.ApnOiReplacement = &v
			}
		// case 0: // LCS-Info (AVP code not defined)
		// case 0: // Teleservice-List (AVP code not defined)
		// case 0: // Call-Barring-Info (AVP code not defined)
		// case 0: // 3GPP-Charging-Characteristics (AVP code not defined)
		case AVPCodeAMBR: // AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AMBR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Ambr = grouped
			}
		case AVPCodeAPNCONFIGURATIONPROFILE: // APN-Configuration-Profile
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &APNConfigurationProfile{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ApnConfigurationProfile = grouped
			}
		// case 0: // RAT-Frequency-Selection-Priority-ID (AVP code not defined)
		// case 0: // Trace-Data (AVP code not defined)
		// case 0: // GPRS-Subscription-Data (AVP code not defined)
		case AVPCodeCSGSUBSCRIPTIONDATA: // CSG-Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &CSGSubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.CsgSubscriptionData = append(g.CsgSubscriptionData, grouped)
			}
			// case 0: // Roaming-Restricted-Due-To-Unsupported-Feature (AVP code not defined)
			// case 0: // Subscribed-Periodic-RAU-TAU-Timer (AVP code not defined)
			// case 0: // MPS-Priority (AVP code not defined)
			// case 0: // VPLMN-LIPA-Allowed (AVP code not defined)
			// case 0: // Relay-Node-Indicator (AVP code not defined)
			// case 0: // MDT-User-Consent (AVP code not defined)
			// case 0: // Subscribed-VSRVCC (AVP code not defined)
			// case 0: // ProSe-Subscription-Data (AVP code not defined)
			// case 0: // Subscription-Data-Flags (AVP code not defined)
			// case 0: // Adjacent-Access-Restriction-Data (AVP code not defined)
			// case 0: // DL-Buffering-Suggested-Packet-Count (AVP code not defined)
			// case 0: // IMSI-Group-Id (AVP code not defined)
			// case 0: // UE-Usage-Type (AVP code not defined)
			// case 0: // AESE-Communication-Pattern (AVP code not defined)
			// case 0: // Monitoring-Event-Configuration (AVP code not defined)
			// case 0: // Emergency-Info (AVP code not defined)
			// case 0: // V2X-Subscription-Data (AVP code not defined)
			// case 0: // eDRX-Cycle-Length (AVP code not defined)
			// case 0: // External-Identifier (AVP code not defined)
			// case 0: // Active-Time (AVP code not defined)
			// case 0: // Service-Gap-Time (AVP code not defined)
			// case 0: // Broadcast-Location-Assistance-Data-Types (AVP code not defined)
			// case 0: // Aerial-UE-Subscription-Information (AVP code not defined)
			// case 0: // Core-Network-Restrictions (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// ExperimentalResult represents the Experimental-Result grouped AVP (AVP Code 297)
type ExperimentalResult struct {
	VendorId               models_base.Unsigned32 // Required
	ExperimentalResultCode models_base.Unsigned32 // Required
}

// Marshal serializes ExperimentalResult to bytes
func (g *ExperimentalResult) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VendorId (required)
	buf.Write(marshalAVP(AVPCodeVENDORID, g.VendorId, true, false))

	// Marshal ExperimentalResultCode (required)
	buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULTCODE, g.ExperimentalResultCode, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into ExperimentalResult
func (g *ExperimentalResult) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeVENDORID: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.VendorId = val.(models_base.Unsigned32)
			}
		case AVPCodeEXPERIMENTALRESULTCODE: // Experimental-Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ExperimentalResultCode = val.(models_base.Unsigned32)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// RequestedUTRANGERANAuthenticationInfo represents the Requested-UTRAN-GERAN-Authentication-Info grouped AVP (AVP Code 1409)
type RequestedUTRANGERANAuthenticationInfo struct {
	NumberOfRequestedVectors   *models_base.Unsigned32  // Optional
	ImmediateResponsePreferred *models_base.Unsigned32  // Optional
	ReSynchronizationInfo      *models_base.OctetString // Optional
}

// Marshal serializes RequestedUTRANGERANAuthenticationInfo to bytes
func (g *RequestedUTRANGERANAuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal NumberOfRequestedVectors (optional)
	if g.NumberOfRequestedVectors != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeNUMBEROFREQUESTEDVECTORS, *g.NumberOfRequestedVectors, true, false, 10415))
	}

	// Marshal ImmediateResponsePreferred (optional)
	if g.ImmediateResponsePreferred != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeIMMEDIATERESPONSEPREFERRED, *g.ImmediateResponsePreferred, true, false, 10415))
	}

	// Marshal ReSynchronizationInfo (optional)
	if g.ReSynchronizationInfo != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeRESYNCHRONIZATIONINFO, *g.ReSynchronizationInfo, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into RequestedUTRANGERANAuthenticationInfo
func (g *RequestedUTRANGERANAuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeNUMBEROFREQUESTEDVECTORS: // Number-Of-Requested-Vectors
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.NumberOfRequestedVectors = &v
			}
		case AVPCodeIMMEDIATERESPONSEPREFERRED: // Immediate-Response-Preferred
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ImmediateResponsePreferred = &v
			}
		case AVPCodeRESYNCHRONIZATIONINFO: // Re-Synchronization-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ReSynchronizationInfo = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// UpdateLocationRequest represents the Update-Location-Request (ULR) Diameter command
// Command Code: 316, Application ID: 16777251
type UpdateLocationRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	RatType                     models_base.Enumerated         // Required
	UlrFlags                    models_base.Unsigned32         // Required
	VisitedPlmnId               models_base.OctetString        // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	DestinationHost             *models_base.DiameterIdentity  // Optional
	OcSupportedFeatures         *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	TerminalInformation         *TerminalInformation           // Optional
	UeSrvccCapability           *models_base.Enumerated        // Optional
	SgsnNumber                  *models_base.OctetString       // Optional
	HomogeneousSupportImsVoice  *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	GmlcAddress                 *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	ActiveApn                   []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	EquivalentPlmnList          *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	MmeNumberForMtSms           *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	SmsRegisterRequest          *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	SgsMmeIdentity              *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	CoupledNodeDiameterId       *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	AdjacentPlmns               *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedServices           *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewUpdateLocationRequest creates a new ULR message
func NewUpdateLocationRequest() *UpdateLocationRequest {
	return &UpdateLocationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   316,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in UpdateLocationRequest
func (m *UpdateLocationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}
	if m.VisitedPlmnId == "" {
		return fmt.Errorf("required field Visited-PLMN-Id is empty")
	}

	return nil
}

// Marshal serializes the UpdateLocationRequest to bytes using a buffer for optimal performance
func (m *UpdateLocationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(AVPCodeUSERNAME, m.UserName, true, true))

	// Marshal RatType (required)
	buf.Write(marshalAVPWithVendor(AVPCodeRATTYPE, m.RatType, true, false, 10415))

	// Marshal UlrFlags (required)
	buf.Write(marshalAVPWithVendor(AVPCodeULRFLAGS, m.UlrFlags, true, false, 10415))

	// Marshal VisitedPlmnId (required)
	buf.Write(marshalAVPWithVendor(AVPCodeVISITEDPLMNID, m.VisitedPlmnId, true, false, 10415))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, *m.DestinationHost, true, false))
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal TerminalInformation (grouped)
	if m.TerminalInformation != nil {
		if groupedData, err := m.TerminalInformation.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeTERMINALINFORMATION, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal UeSrvccCapability (optional)
	if m.UeSrvccCapability != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeUESRVCCCAPABILITY, *m.UeSrvccCapability, true, false, 10415))
	}

	// Marshal SgsnNumber (optional)
	if m.SgsnNumber != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeSGSNNUMBER, *m.SgsnNumber, true, false, 10415))
	}

	// Skipping HomogeneousSupportImsVoice - AVP code not defined

	// Skipping GmlcAddress - AVP code not defined

	// Skipping ActiveApn - AVP code not defined

	// Skipping EquivalentPlmnList - AVP code not defined

	// Skipping MmeNumberForMtSms - AVP code not defined

	// Skipping SmsRegisterRequest - AVP code not defined

	// Skipping SgsMmeIdentity - AVP code not defined

	// Skipping CoupledNodeDiameterId - AVP code not defined

	// Skipping AdjacentPlmns - AVP code not defined

	// Skipping SupportedServices - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into UpdateLocationRequest
func (m *UpdateLocationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeUSERNAME: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case AVPCodeRATTYPE: // RAT-Type
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.RatType = val.(models_base.Enumerated)
			}
		case AVPCodeULRFLAGS: // ULR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.UlrFlags = val.(models_base.Unsigned32)
			}
		case AVPCodeVISITEDPLMNID: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.VisitedPlmnId = val.(models_base.OctetString)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeTERMINALINFORMATION: // Terminal-Information
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &TerminalInformation{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.TerminalInformation = grouped
			}
		case AVPCodeUESRVCCCAPABILITY: // UE-SRVCC-Capability
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.UeSrvccCapability = &v
			}
		case AVPCodeSGSNNUMBER: // SGSN-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.SgsnNumber = &v
			}
		// case 0: // Homogeneous-Support-of-IMS-Voice-Over-PS-Sessions (AVP code not defined)
		// case 0: // GMLC-Address (AVP code not defined)
		// case 0: // Active-APN (AVP code not defined)
		// case 0: // Equivalent-PLMN-List (AVP code not defined)
		// case 0: // MME-Number-for-MT-SMS (AVP code not defined)
		// case 0: // SMS-Register-Request (AVP code not defined)
		// case 0: // SGs-MME-Identity (AVP code not defined)
		// case 0: // Coupled-Node-Diameter-ID (AVP code not defined)
		// case 0: // Adjacent-PLMNs (AVP code not defined)
		// case 0: // Supported-Services (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the UpdateLocationRequest message
func (m *UpdateLocationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of UpdateLocationRequest
func (m *UpdateLocationRequest) String() string {
	return fmt.Sprintf("UpdateLocationRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, UserName:%v, RatType:%v, UlrFlags:%v, VisitedPlmnId:%v, Drmp:%v, VendorSpecificApplicationId:%v, DestinationHost:%v, OcSupportedFeatures:%v, SupportedFeatures:%v, TerminalInformation:%v, UeSrvccCapability:%v, SgsnNumber:%v, HomogeneousSupportImsVoice:%v, GmlcAddress:%v, ActiveApn:%v, EquivalentPlmnList:%v, MmeNumberForMtSms:%v, SmsRegisterRequest:%v, SgsMmeIdentity:%v, CoupledNodeDiameterId:%v, AdjacentPlmns:%v, SupportedServices:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.UserName, m.RatType, m.UlrFlags, m.VisitedPlmnId, m.Drmp, m.VendorSpecificApplicationId, m.DestinationHost, m.OcSupportedFeatures, m.SupportedFeatures, m.TerminalInformation, m.UeSrvccCapability, m.SgsnNumber, m.HomogeneousSupportImsVoice, m.GmlcAddress, m.ActiveApn, m.EquivalentPlmnList, m.MmeNumberForMtSms, m.SmsRegisterRequest, m.SgsMmeIdentity, m.CoupledNodeDiameterId, m.AdjacentPlmns, m.SupportedServices, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// UpdateLocationAnswer represents the Update-Location-Answer (ULA) Diameter command
// Command Code: 316, Application ID: 16777251
type UpdateLocationAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	ErrorDiagnostic             *models_base.Enumerated        // Optional
	OcSupportedFeatures         *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	OcOlr                       *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Load                        []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	UlaFlags                    *models_base.Unsigned32        // Optional
	SubscriptionData            *SubscriptionData              // Optional
	ResetId                     []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewUpdateLocationAnswer creates a new ULA message
func NewUpdateLocationAnswer() *UpdateLocationAnswer {
	return &UpdateLocationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   316,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in UpdateLocationAnswer
func (m *UpdateLocationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the UpdateLocationAnswer to bytes using a buffer for optimal performance
func (m *UpdateLocationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ErrorDiagnostic (optional)
	if m.ErrorDiagnostic != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeERRORDIAGNOSTIC, *m.ErrorDiagnostic, false, false, 10415))
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Skipping OcOlr - AVP code not defined

	// Skipping Load - AVP code not defined

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal UlaFlags (optional)
	if m.UlaFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeULAFLAGS, *m.UlaFlags, true, false, 10415))
	}

	// Marshal SubscriptionData (grouped)
	if m.SubscriptionData != nil {
		if groupedData, err := m.SubscriptionData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeSUBSCRIPTIONDATA, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Skipping ResetId - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into UpdateLocationAnswer
func (m *UpdateLocationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		case AVPCodeERRORDIAGNOSTIC: // Error-Diagnostic
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.ErrorDiagnostic = &v
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		// case 0: // OC-OLR (AVP code not defined)
		// case 0: // Load (AVP code not defined)
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeULAFLAGS: // ULA-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.UlaFlags = &v
			}
		case AVPCodeSUBSCRIPTIONDATA: // Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &SubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.SubscriptionData = grouped
			}
		// case 0: // Reset-ID (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the UpdateLocationAnswer message
func (m *UpdateLocationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of UpdateLocationAnswer
func (m *UpdateLocationAnswer) String() string {
	return fmt.Sprintf("UpdateLocationAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, ResultCode:%v, ExperimentalResult:%v, ErrorDiagnostic:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, SupportedFeatures:%v, UlaFlags:%v, SubscriptionData:%v, ResetId:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.ResultCode, m.ExperimentalResult, m.ErrorDiagnostic, m.OcSupportedFeatures, m.OcOlr, m.Load, m.SupportedFeatures, m.UlaFlags, m.SubscriptionData, m.ResetId, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// AuthenticationInformationRequest represents the Authentication-Information-Request (AIR) Diameter command
// Command Code: 318, Application ID: 16777251
type AuthenticationInformationRequest struct {
	Header DiameterHeader

	SessionId                             models_base.UTF8String                 // Required
	AuthSessionState                      models_base.Enumerated                 // Required
	OriginHost                            models_base.DiameterIdentity           // Required
	OriginRealm                           models_base.DiameterIdentity           // Required
	DestinationRealm                      models_base.DiameterIdentity           // Required
	UserName                              models_base.UTF8String                 // Required
	VisitedPlmnId                         models_base.OctetString                // Required
	Drmp                                  *models_base.Enumerated                // Optional
	VendorSpecificApplicationId           *VendorSpecificApplicationId           // Optional
	DestinationHost                       *models_base.DiameterIdentity          // Optional
	OcSupportedFeatures                   *models_base.OctetString               // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedFeatures                     []models_base.OctetString              // Optional - WARNING: AVP code not defined, DO NOT USE
	RequestedEutranAuthenticationInfo     *RequestedEUTRANAuthenticationInfo     // Optional
	RequestedUtranGeranAuthenticationInfo *RequestedUTRANGERANAuthenticationInfo // Optional
	AirFlags                              *models_base.Unsigned32                // Optional
	Avp                                   []models_base.OctetString              // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                             []*ProxyInfo                           // Optional
	RouteRecord                           []models_base.DiameterIdentity         // Optional
}

// NewAuthenticationInformationRequest creates a new AIR message
func NewAuthenticationInformationRequest() *AuthenticationInformationRequest {
	return &AuthenticationInformationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   318,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AuthenticationInformationRequest
func (m *AuthenticationInformationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}
	if m.VisitedPlmnId == "" {
		return fmt.Errorf("required field Visited-PLMN-Id is empty")
	}

	return nil
}

// Marshal serializes the AuthenticationInformationRequest to bytes using a buffer for optimal performance
func (m *AuthenticationInformationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(AVPCodeUSERNAME, m.UserName, true, true))

	// Marshal VisitedPlmnId (required)
	buf.Write(marshalAVPWithVendor(AVPCodeVISITEDPLMNID, m.VisitedPlmnId, true, false, 10415))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, *m.DestinationHost, true, false))
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal RequestedEutranAuthenticationInfo (grouped)
	if m.RequestedEutranAuthenticationInfo != nil {
		if groupedData, err := m.RequestedEutranAuthenticationInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeREQUESTEDEUTRANAUTHENTICATIONINFO, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal RequestedUtranGeranAuthenticationInfo (grouped)
	if m.RequestedUtranGeranAuthenticationInfo != nil {
		if groupedData, err := m.RequestedUtranGeranAuthenticationInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeREQUESTEDUTRANGERANAUTHENTICATIONINFO, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal AirFlags (optional)
	if m.AirFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeAIRFLAGS, *m.AirFlags, true, false, 10415))
	}

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AuthenticationInformationRequest
func (m *AuthenticationInformationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeUSERNAME: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case AVPCodeVISITEDPLMNID: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				m.VisitedPlmnId = val.(models_base.OctetString)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeREQUESTEDEUTRANAUTHENTICATIONINFO: // Requested-EUTRAN-Authentication-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &RequestedEUTRANAuthenticationInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.RequestedEutranAuthenticationInfo = grouped
			}
		case AVPCodeREQUESTEDUTRANGERANAUTHENTICATIONINFO: // Requested-UTRAN-GERAN-Authentication-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &RequestedUTRANGERANAuthenticationInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.RequestedUtranGeranAuthenticationInfo = grouped
			}
		case AVPCodeAIRFLAGS: // AIR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.AirFlags = &v
			}
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AuthenticationInformationRequest message
func (m *AuthenticationInformationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AuthenticationInformationRequest
func (m *AuthenticationInformationRequest) String() string {
	return fmt.Sprintf("AuthenticationInformationRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, UserName:%v, VisitedPlmnId:%v, Drmp:%v, VendorSpecificApplicationId:%v, DestinationHost:%v, OcSupportedFeatures:%v, SupportedFeatures:%v, RequestedEutranAuthenticationInfo:%v, RequestedUtranGeranAuthenticationInfo:%v, AirFlags:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.UserName, m.VisitedPlmnId, m.Drmp, m.VendorSpecificApplicationId, m.DestinationHost, m.OcSupportedFeatures, m.SupportedFeatures, m.RequestedEutranAuthenticationInfo, m.RequestedUtranGeranAuthenticationInfo, m.AirFlags, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// AuthenticationInformationAnswer represents the Authentication-Information-Answer (AIA) Diameter command
// Command Code: 318, Application ID: 16777251
type AuthenticationInformationAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	ErrorDiagnostic             *models_base.Enumerated        // Optional
	OcSupportedFeatures         *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	OcOlr                       *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Load                        []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	AuthenticationInfo          *AuthenticationInfo            // Optional
	UeUsageType                 *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewAuthenticationInformationAnswer creates a new AIA message
func NewAuthenticationInformationAnswer() *AuthenticationInformationAnswer {
	return &AuthenticationInformationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   318,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in AuthenticationInformationAnswer
func (m *AuthenticationInformationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the AuthenticationInformationAnswer to bytes using a buffer for optimal performance
func (m *AuthenticationInformationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ErrorDiagnostic (optional)
	if m.ErrorDiagnostic != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeERRORDIAGNOSTIC, *m.ErrorDiagnostic, false, false, 10415))
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Skipping OcOlr - AVP code not defined

	// Skipping Load - AVP code not defined

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal AuthenticationInfo (grouped)
	if m.AuthenticationInfo != nil {
		if groupedData, err := m.AuthenticationInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeAUTHENTICATIONINFO, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Skipping UeUsageType - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into AuthenticationInformationAnswer
func (m *AuthenticationInformationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		case AVPCodeERRORDIAGNOSTIC: // Error-Diagnostic
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.ErrorDiagnostic = &v
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		// case 0: // OC-OLR (AVP code not defined)
		// case 0: // Load (AVP code not defined)
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeAUTHENTICATIONINFO: // Authentication-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AuthenticationInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.AuthenticationInfo = grouped
			}
		// case 0: // UE-Usage-Type (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the AuthenticationInformationAnswer message
func (m *AuthenticationInformationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of AuthenticationInformationAnswer
func (m *AuthenticationInformationAnswer) String() string {
	return fmt.Sprintf("AuthenticationInformationAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, ResultCode:%v, ExperimentalResult:%v, ErrorDiagnostic:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, SupportedFeatures:%v, AuthenticationInfo:%v, UeUsageType:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.ResultCode, m.ExperimentalResult, m.ErrorDiagnostic, m.OcSupportedFeatures, m.OcOlr, m.Load, m.SupportedFeatures, m.AuthenticationInfo, m.UeUsageType, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// CancelLocationRequest represents the Cancel-Location-Request (CLR) Diameter command
// Command Code: 317, Application ID: 16777251
type CancelLocationRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	CancellationType            models_base.Enumerated         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ClrFlags                    *models_base.Unsigned32        // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewCancelLocationRequest creates a new CLR message
func NewCancelLocationRequest() *CancelLocationRequest {
	return &CancelLocationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   317,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in CancelLocationRequest
func (m *CancelLocationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the CancelLocationRequest to bytes using a buffer for optimal performance
func (m *CancelLocationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, m.DestinationHost, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(AVPCodeUSERNAME, m.UserName, true, true))

	// Marshal CancellationType (required)
	buf.Write(marshalAVPWithVendor(AVPCodeCANCELLATIONTYPE, m.CancellationType, true, false, 10415))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal ClrFlags (optional)
	if m.ClrFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeCLRFLAGS, *m.ClrFlags, true, false, 10415))
	}

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CancelLocationRequest
func (m *CancelLocationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeUSERNAME: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case AVPCodeCANCELLATIONTYPE: // Cancellation-Type
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.CancellationType = val.(models_base.Enumerated)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeCLRFLAGS: // CLR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ClrFlags = &v
			}
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CancelLocationRequest message
func (m *CancelLocationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CancelLocationRequest
func (m *CancelLocationRequest) String() string {
	return fmt.Sprintf("CancelLocationRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, CancellationType:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ClrFlags:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.CancellationType, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ClrFlags, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// CancelLocationAnswer represents the Cancel-Location-Answer (CLA) Diameter command
// Command Code: 317, Application ID: 16777251
type CancelLocationAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewCancelLocationAnswer creates a new CLA message
func NewCancelLocationAnswer() *CancelLocationAnswer {
	return &CancelLocationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   317,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in CancelLocationAnswer
func (m *CancelLocationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the CancelLocationAnswer to bytes using a buffer for optimal performance
func (m *CancelLocationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into CancelLocationAnswer
func (m *CancelLocationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the CancelLocationAnswer message
func (m *CancelLocationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of CancelLocationAnswer
func (m *CancelLocationAnswer) String() string {
	return fmt.Sprintf("CancelLocationAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// InsertSubscriberDataRequest represents the Insert-Subscriber-Data-Request (ISDR) Diameter command
// Command Code: 319, Application ID: 16777251
type InsertSubscriberDataRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	SubscriptionData            *SubscriptionData              // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	IdrFlags                    *models_base.Unsigned32        // Optional
	ResetId                     []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewInsertSubscriberDataRequest creates a new ISDR message
func NewInsertSubscriberDataRequest() *InsertSubscriberDataRequest {
	return &InsertSubscriberDataRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   319,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in InsertSubscriberDataRequest
func (m *InsertSubscriberDataRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}
	if m.SubscriptionData == nil {
		return fmt.Errorf("required field Subscription-Data is nil")
	}

	return nil
}

// Marshal serializes the InsertSubscriberDataRequest to bytes using a buffer for optimal performance
func (m *InsertSubscriberDataRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, m.DestinationHost, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(AVPCodeUSERNAME, m.UserName, true, true))

	// Marshal SubscriptionData (grouped)
	if m.SubscriptionData != nil {
		if groupedData, err := m.SubscriptionData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeSUBSCRIPTIONDATA, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal IdrFlags (optional)
	if m.IdrFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeIDRFLAGS, *m.IdrFlags, true, false, 10415))
	}

	// Skipping ResetId - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into InsertSubscriberDataRequest
func (m *InsertSubscriberDataRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeUSERNAME: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case AVPCodeSUBSCRIPTIONDATA: // Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &SubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.SubscriptionData = grouped
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeIDRFLAGS: // IDR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.IdrFlags = &v
			}
		// case 0: // Reset-ID (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the InsertSubscriberDataRequest message
func (m *InsertSubscriberDataRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of InsertSubscriberDataRequest
func (m *InsertSubscriberDataRequest) String() string {
	return fmt.Sprintf("InsertSubscriberDataRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, SubscriptionData:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, IdrFlags:%v, ResetId:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.SubscriptionData, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.IdrFlags, m.ResetId, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// InsertSubscriberDataAnswer represents the Insert-Subscriber-Data-Answer (ISDA) Diameter command
// Command Code: 319, Application ID: 16777251
type InsertSubscriberDataAnswer struct {
	Header DiameterHeader

	SessionId                       models_base.UTF8String         // Required
	AuthSessionState                models_base.Enumerated         // Required
	OriginHost                      models_base.DiameterIdentity   // Required
	OriginRealm                     models_base.DiameterIdentity   // Required
	Drmp                            *models_base.Enumerated        // Optional
	VendorSpecificApplicationId     *VendorSpecificApplicationId   // Optional
	SupportedFeatures               []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ResultCode                      *models_base.Unsigned32        // Optional
	ExperimentalResult              *ExperimentalResult            // Optional
	ImsVoiceOverPsSessionsSupported *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	LastUeActivityTime              *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	RatType                         *models_base.Enumerated        // Optional
	IdaFlags                        *models_base.Unsigned32        // Optional
	EpsUserState                    *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	EpsLocationInformation          *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	LocalTimeZone                   *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedServices               *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	MonitoringEventReport           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	MonitoringEventConfigStatus     []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                             []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                       *FailedAVP                     // Optional
	ProxyInfo                       []*ProxyInfo                   // Optional
	RouteRecord                     []models_base.DiameterIdentity // Optional
}

// NewInsertSubscriberDataAnswer creates a new ISDA message
func NewInsertSubscriberDataAnswer() *InsertSubscriberDataAnswer {
	return &InsertSubscriberDataAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   319,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in InsertSubscriberDataAnswer
func (m *InsertSubscriberDataAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the InsertSubscriberDataAnswer to bytes using a buffer for optimal performance
func (m *InsertSubscriberDataAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping ImsVoiceOverPsSessionsSupported - AVP code not defined

	// Skipping LastUeActivityTime - AVP code not defined

	// Marshal RatType (optional)
	if m.RatType != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeRATTYPE, *m.RatType, true, false, 10415))
	}

	// Marshal IdaFlags (optional)
	if m.IdaFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeIDAFLAGS, *m.IdaFlags, true, false, 10415))
	}

	// Skipping EpsUserState - AVP code not defined

	// Skipping EpsLocationInformation - AVP code not defined

	// Skipping LocalTimeZone - AVP code not defined

	// Skipping SupportedServices - AVP code not defined

	// Skipping MonitoringEventReport - AVP code not defined

	// Skipping MonitoringEventConfigStatus - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into InsertSubscriberDataAnswer
func (m *InsertSubscriberDataAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		// case 0: // IMS-Voice-Over-PS-Sessions-Supported (AVP code not defined)
		// case 0: // Last-UE-Activity-Time (AVP code not defined)
		case AVPCodeRATTYPE: // RAT-Type
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.RatType = &v
			}
		case AVPCodeIDAFLAGS: // IDA-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.IdaFlags = &v
			}
		// case 0: // EPS-User-State (AVP code not defined)
		// case 0: // EPS-Location-Information (AVP code not defined)
		// case 0: // Local-Time-Zone (AVP code not defined)
		// case 0: // Supported-Services (AVP code not defined)
		// case 0: // Monitoring-Event-Report (AVP code not defined)
		// case 0: // Monitoring-Event-Config-Status (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the InsertSubscriberDataAnswer message
func (m *InsertSubscriberDataAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of InsertSubscriberDataAnswer
func (m *InsertSubscriberDataAnswer) String() string {
	return fmt.Sprintf("InsertSubscriberDataAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, ImsVoiceOverPsSessionsSupported:%v, LastUeActivityTime:%v, RatType:%v, IdaFlags:%v, EpsUserState:%v, EpsLocationInformation:%v, LocalTimeZone:%v, SupportedServices:%v, MonitoringEventReport:%v, MonitoringEventConfigStatus:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.ImsVoiceOverPsSessionsSupported, m.LastUeActivityTime, m.RatType, m.IdaFlags, m.EpsUserState, m.EpsLocationInformation, m.LocalTimeZone, m.SupportedServices, m.MonitoringEventReport, m.MonitoringEventConfigStatus, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// DeleteSubscriberDataRequest represents the Delete-Subscriber-Data-Request (DSDR) Diameter command
// Command Code: 320, Application ID: 16777251
type DeleteSubscriberDataRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	DsrFlags                    models_base.Unsigned32         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ScefId                      *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	ContextIdentifier           []models_base.Unsigned32       // Optional
	TraceReference              *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	TsCode                      []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	SsCode                      []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	EdrxRelatedRat              *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	ExternalIdentifier          []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewDeleteSubscriberDataRequest creates a new DSDR message
func NewDeleteSubscriberDataRequest() *DeleteSubscriberDataRequest {
	return &DeleteSubscriberDataRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   320,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in DeleteSubscriberDataRequest
func (m *DeleteSubscriberDataRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the DeleteSubscriberDataRequest to bytes using a buffer for optimal performance
func (m *DeleteSubscriberDataRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, m.DestinationHost, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(AVPCodeUSERNAME, m.UserName, true, true))

	// Marshal DsrFlags (required)
	buf.Write(marshalAVPWithVendor(AVPCodeDSRFLAGS, m.DsrFlags, true, false, 10415))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Skipping ScefId - AVP code not defined

	// Marshal ContextIdentifier (repeated)
	for _, v := range m.ContextIdentifier {
		buf.Write(marshalAVPWithVendor(AVPCodeCONTEXTIDENTIFIER, v, true, false, 10415))
	}

	// Skipping TraceReference - AVP code not defined

	// Skipping TsCode - AVP code not defined

	// Skipping SsCode - AVP code not defined

	// Skipping EdrxRelatedRat - AVP code not defined

	// Skipping ExternalIdentifier - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeleteSubscriberDataRequest
func (m *DeleteSubscriberDataRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeUSERNAME: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case AVPCodeDSRFLAGS: // DSR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.DsrFlags = val.(models_base.Unsigned32)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		// case 0: // SCEF-ID (AVP code not defined)
		case AVPCodeCONTEXTIDENTIFIER: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				m.ContextIdentifier = append(m.ContextIdentifier, val.(models_base.Unsigned32))
			}
		// case 0: // Trace-Reference (AVP code not defined)
		// case 0: // TS-Code (AVP code not defined)
		// case 0: // SS-Code (AVP code not defined)
		// case 0: // eDRX-Related-RAT (AVP code not defined)
		// case 0: // External-Identifier (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeleteSubscriberDataRequest message
func (m *DeleteSubscriberDataRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeleteSubscriberDataRequest
func (m *DeleteSubscriberDataRequest) String() string {
	return fmt.Sprintf("DeleteSubscriberDataRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, UserName:%v, DsrFlags:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ScefId:%v, ContextIdentifier:%v, TraceReference:%v, TsCode:%v, SsCode:%v, EdrxRelatedRat:%v, ExternalIdentifier:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.UserName, m.DsrFlags, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ScefId, m.ContextIdentifier, m.TraceReference, m.TsCode, m.SsCode, m.EdrxRelatedRat, m.ExternalIdentifier, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// DeleteSubscriberDataAnswer represents the Delete-Subscriber-Data-Answer (DSDA) Diameter command
// Command Code: 320, Application ID: 16777251
type DeleteSubscriberDataAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	DsaFlags                    *models_base.Unsigned32        // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewDeleteSubscriberDataAnswer creates a new DSDA message
func NewDeleteSubscriberDataAnswer() *DeleteSubscriberDataAnswer {
	return &DeleteSubscriberDataAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   320,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in DeleteSubscriberDataAnswer
func (m *DeleteSubscriberDataAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the DeleteSubscriberDataAnswer to bytes using a buffer for optimal performance
func (m *DeleteSubscriberDataAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal DsaFlags (optional)
	if m.DsaFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeDSAFLAGS, *m.DsaFlags, true, false, 10415))
	}

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into DeleteSubscriberDataAnswer
func (m *DeleteSubscriberDataAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		case AVPCodeDSAFLAGS: // DSA-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.DsaFlags = &v
			}
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the DeleteSubscriberDataAnswer message
func (m *DeleteSubscriberDataAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of DeleteSubscriberDataAnswer
func (m *DeleteSubscriberDataAnswer) String() string {
	return fmt.Sprintf("DeleteSubscriberDataAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, DsaFlags:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.DsaFlags, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// PurgeUERequest represents the Purge-UE-Request (PUR) Diameter command
// Command Code: 321, Application ID: 16777251
type PurgeUERequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	DestinationHost             *models_base.DiameterIdentity  // Optional
	OcSupportedFeatures         *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	PurFlags                    *models_base.Unsigned32        // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	EpsLocationInformation      *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewPurgeUERequest creates a new PUR message
func NewPurgeUERequest() *PurgeUERequest {
	return &PurgeUERequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   321,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in PurgeUERequest
func (m *PurgeUERequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the PurgeUERequest to bytes using a buffer for optimal performance
func (m *PurgeUERequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(AVPCodeUSERNAME, m.UserName, true, true))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, *m.DestinationHost, true, false))
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Marshal PurFlags (optional)
	if m.PurFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodePURFLAGS, *m.PurFlags, true, false, 10415))
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Skipping EpsLocationInformation - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into PurgeUERequest
func (m *PurgeUERequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeUSERNAME: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		case AVPCodePURFLAGS: // PUR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.PurFlags = &v
			}
		// case 0: // Supported-Features (AVP code not defined)
		// case 0: // EPS-Location-Information (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the PurgeUERequest message
func (m *PurgeUERequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of PurgeUERequest
func (m *PurgeUERequest) String() string {
	return fmt.Sprintf("PurgeUERequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, UserName:%v, Drmp:%v, VendorSpecificApplicationId:%v, DestinationHost:%v, OcSupportedFeatures:%v, PurFlags:%v, SupportedFeatures:%v, EpsLocationInformation:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.UserName, m.Drmp, m.VendorSpecificApplicationId, m.DestinationHost, m.OcSupportedFeatures, m.PurFlags, m.SupportedFeatures, m.EpsLocationInformation, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// PurgeUEAnswer represents the Purge-UE-Answer (PUA) Diameter command
// Command Code: 321, Application ID: 16777251
type PurgeUEAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	OcSupportedFeatures         *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	OcOlr                       *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Load                        []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	PuaFlags                    *models_base.Unsigned32        // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewPurgeUEAnswer creates a new PUA message
func NewPurgeUEAnswer() *PurgeUEAnswer {
	return &PurgeUEAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   321,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in PurgeUEAnswer
func (m *PurgeUEAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the PurgeUEAnswer to bytes using a buffer for optimal performance
func (m *PurgeUEAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Skipping OcOlr - AVP code not defined

	// Skipping Load - AVP code not defined

	// Marshal PuaFlags (optional)
	if m.PuaFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodePUAFLAGS, *m.PuaFlags, true, false, 10415))
	}

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into PurgeUEAnswer
func (m *PurgeUEAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		// case 0: // OC-OLR (AVP code not defined)
		// case 0: // Load (AVP code not defined)
		case AVPCodePUAFLAGS: // PUA-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.PuaFlags = &v
			}
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the PurgeUEAnswer message
func (m *PurgeUEAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of PurgeUEAnswer
func (m *PurgeUEAnswer) String() string {
	return fmt.Sprintf("PurgeUEAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, PuaFlags:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.OcSupportedFeatures, m.OcOlr, m.Load, m.PuaFlags, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// ResetRequest represents the Reset-Request (RR) Diameter command
// Command Code: 322, Application ID: 16777251
type ResetRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationHost             models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	UserId                      []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ResetId                     []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	SubscriptionData            *SubscriptionData              // Optional
	SubscriptionDataDeletion    *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewResetRequest creates a new RR message
func NewResetRequest() *ResetRequest {
	return &ResetRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   322,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ResetRequest
func (m *ResetRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationHost == "" {
		return fmt.Errorf("required field Destination-Host is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}

	return nil
}

// Marshal serializes the ResetRequest to bytes using a buffer for optimal performance
func (m *ResetRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, m.DestinationHost, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Skipping UserId - AVP code not defined

	// Skipping ResetId - AVP code not defined

	// Marshal SubscriptionData (grouped)
	if m.SubscriptionData != nil {
		if groupedData, err := m.SubscriptionData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeSUBSCRIPTIONDATA, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Skipping SubscriptionDataDeletion - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ResetRequest
func (m *ResetRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		// case 0: // User-Id (AVP code not defined)
		// case 0: // Reset-ID (AVP code not defined)
		case AVPCodeSUBSCRIPTIONDATA: // Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &SubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.SubscriptionData = grouped
			}
		// case 0: // Subscription-Data-Deletion (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ResetRequest message
func (m *ResetRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ResetRequest
func (m *ResetRequest) String() string {
	return fmt.Sprintf("ResetRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationHost:%v, DestinationRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, UserId:%v, ResetId:%v, SubscriptionData:%v, SubscriptionDataDeletion:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationHost, m.DestinationRealm, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.UserId, m.ResetId, m.SubscriptionData, m.SubscriptionDataDeletion, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// ResetAnswer represents the Reset-Answer (RA) Diameter command
// Command Code: 322, Application ID: 16777251
type ResetAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewResetAnswer creates a new RA message
func NewResetAnswer() *ResetAnswer {
	return &ResetAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   322,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in ResetAnswer
func (m *ResetAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the ResetAnswer to bytes using a buffer for optimal performance
func (m *ResetAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into ResetAnswer
func (m *ResetAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the ResetAnswer message
func (m *ResetAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of ResetAnswer
func (m *ResetAnswer) String() string {
	return fmt.Sprintf("ResetAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, SupportedFeatures:%v, ResultCode:%v, ExperimentalResult:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.SupportedFeatures, m.ResultCode, m.ExperimentalResult, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// NotifyRequest represents the Notify-Request (NR) Diameter command
// Command Code: 323, Application ID: 16777251
type NotifyRequest struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	DestinationRealm            models_base.DiameterIdentity   // Required
	UserName                    models_base.UTF8String         // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	DestinationHost             *models_base.DiameterIdentity  // Optional
	OcSupportedFeatures         *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	TerminalInformation         *TerminalInformation           // Optional
	Mip6AgentInfo               *MIP6AgentInfo                 // Optional
	VisitedNetworkIdentifier    *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	ContextIdentifier           *models_base.Unsigned32        // Optional
	ServiceSelection            *models_base.UTF8String        // Optional
	AlertReason                 *models_base.Enumerated        // Optional
	UeSrvccCapability           *models_base.Enumerated        // Optional
	NorFlags                    *models_base.Unsigned32        // Optional
	HomogeneousSupportImsVoice  *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	MaximumUeAvailabilityTime   *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	MonitoringEventConfigStatus []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	EmergencyServices           *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewNotifyRequest creates a new NR message
func NewNotifyRequest() *NotifyRequest {
	return &NotifyRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   323,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in NotifyRequest
func (m *NotifyRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the NotifyRequest to bytes using a buffer for optimal performance
func (m *NotifyRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(AVPCodeDESTINATIONREALM, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(AVPCodeUSERNAME, m.UserName, true, true))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(AVPCodeDESTINATIONHOST, *m.DestinationHost, true, false))
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Skipping SupportedFeatures - AVP code not defined

	// Marshal TerminalInformation (grouped)
	if m.TerminalInformation != nil {
		if groupedData, err := m.TerminalInformation.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(AVPCodeTERMINALINFORMATION, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal Mip6AgentInfo (grouped)
	if m.Mip6AgentInfo != nil {
		if groupedData, err := m.Mip6AgentInfo.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeMIP6AGENTINFO, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping VisitedNetworkIdentifier - AVP code not defined

	// Marshal ContextIdentifier (optional)
	if m.ContextIdentifier != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeCONTEXTIDENTIFIER, *m.ContextIdentifier, true, false, 10415))
	}

	// Marshal ServiceSelection (optional)
	if m.ServiceSelection != nil {
		buf.Write(marshalAVP(AVPCodeSERVICESELECTION, *m.ServiceSelection, true, false))
	}

	// Marshal AlertReason (optional)
	if m.AlertReason != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeALERTREASON, *m.AlertReason, true, false, 10415))
	}

	// Marshal UeSrvccCapability (optional)
	if m.UeSrvccCapability != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeUESRVCCCAPABILITY, *m.UeSrvccCapability, true, false, 10415))
	}

	// Marshal NorFlags (optional)
	if m.NorFlags != nil {
		buf.Write(marshalAVPWithVendor(AVPCodeNORFLAGS, *m.NorFlags, true, false, 10415))
	}

	// Skipping HomogeneousSupportImsVoice - AVP code not defined

	// Skipping MaximumUeAvailabilityTime - AVP code not defined

	// Skipping MonitoringEventConfigStatus - AVP code not defined

	// Skipping EmergencyServices - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into NotifyRequest
func (m *NotifyRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDESTINATIONREALM: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeUSERNAME: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case AVPCodeDESTINATIONHOST: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		// case 0: // Supported-Features (AVP code not defined)
		case AVPCodeTERMINALINFORMATION: // Terminal-Information
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &TerminalInformation{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.TerminalInformation = grouped
			}
		case AVPCodeMIP6AGENTINFO: // MIP6-Agent-Info
			grouped := &MIP6AgentInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.Mip6AgentInfo = grouped
			}
		// case 0: // Visited-Network-Identifier (AVP code not defined)
		case AVPCodeCONTEXTIDENTIFIER: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ContextIdentifier = &v
			}
		case AVPCodeSERVICESELECTION: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				m.ServiceSelection = &v
			}
		case AVPCodeALERTREASON: // Alert-Reason
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.AlertReason = &v
			}
		case AVPCodeUESRVCCCAPABILITY: // UE-SRVCC-Capability
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.UeSrvccCapability = &v
			}
		case AVPCodeNORFLAGS: // NOR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.NorFlags = &v
			}
		// case 0: // Homogeneous-Support-of-IMS-Voice-Over-PS-Sessions (AVP code not defined)
		// case 0: // Maximum-UE-Availability-Time (AVP code not defined)
		// case 0: // Monitoring-Event-Config-Status (AVP code not defined)
		// case 0: // Emergency-Services (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the NotifyRequest message
func (m *NotifyRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of NotifyRequest
func (m *NotifyRequest) String() string {
	return fmt.Sprintf("NotifyRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, UserName:%v, Drmp:%v, VendorSpecificApplicationId:%v, DestinationHost:%v, OcSupportedFeatures:%v, SupportedFeatures:%v, TerminalInformation:%v, Mip6AgentInfo:%v, VisitedNetworkIdentifier:%v, ContextIdentifier:%v, ServiceSelection:%v, AlertReason:%v, UeSrvccCapability:%v, NorFlags:%v, HomogeneousSupportImsVoice:%v, MaximumUeAvailabilityTime:%v, MonitoringEventConfigStatus:%v, EmergencyServices:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.UserName, m.Drmp, m.VendorSpecificApplicationId, m.DestinationHost, m.OcSupportedFeatures, m.SupportedFeatures, m.TerminalInformation, m.Mip6AgentInfo, m.VisitedNetworkIdentifier, m.ContextIdentifier, m.ServiceSelection, m.AlertReason, m.UeSrvccCapability, m.NorFlags, m.HomogeneousSupportImsVoice, m.MaximumUeAvailabilityTime, m.MonitoringEventConfigStatus, m.EmergencyServices, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// NotifyAnswer represents the Notify-Answer (NA) Diameter command
// Command Code: 323, Application ID: 16777251
type NotifyAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	Drmp                        *models_base.Enumerated        // Optional
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	OcSupportedFeatures         *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	OcOlr                       *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Load                        []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	SupportedFeatures           []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewNotifyAnswer creates a new NA message
func NewNotifyAnswer() *NotifyAnswer {
	return &NotifyAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   323,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in NotifyAnswer
func (m *NotifyAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the NotifyAnswer to bytes using a buffer for optimal performance
func (m *NotifyAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(AVPCodeSESSIONID, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(AVPCodeAUTHSESSIONSTATE, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(AVPCodeORIGINHOST, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(AVPCodeORIGINREALM, m.OriginRealm, true, false))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(AVPCodeDRMP, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeVENDORSPECIFICAPPLICATIONID, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(AVPCodeRESULTCODE, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeEXPERIMENTALRESULT, models_base.Grouped(groupedData), true, false))
		}
	}

	// Skipping OcSupportedFeatures - AVP code not defined

	// Skipping OcOlr - AVP code not defined

	// Skipping Load - AVP code not defined

	// Skipping SupportedFeatures - AVP code not defined

	// Skipping Avp - AVP code not defined

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(AVPCodeFAILEDAVP, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(AVPCodePROXYINFO, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(AVPCodeROUTERECORD, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into NotifyAnswer
func (m *NotifyAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case AVPCodeSESSIONID: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case AVPCodeAUTHSESSIONSTATE: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case AVPCodeORIGINHOST: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case AVPCodeORIGINREALM: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case AVPCodeDRMP: // DRMP
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.Drmp = &v
			}
		case AVPCodeVENDORSPECIFICAPPLICATIONID: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case AVPCodeRESULTCODE: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case AVPCodeEXPERIMENTALRESULT: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		// case 0: // OC-Supported-Features (AVP code not defined)
		// case 0: // OC-OLR (AVP code not defined)
		// case 0: // Load (AVP code not defined)
		// case 0: // Supported-Features (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case AVPCodeFAILEDAVP: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case AVPCodePROXYINFO: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case AVPCodeROUTERECORD: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the NotifyAnswer message
func (m *NotifyAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of NotifyAnswer
func (m *NotifyAnswer) String() string {
	return fmt.Sprintf("NotifyAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, Drmp:%v, VendorSpecificApplicationId:%v, ResultCode:%v, ExperimentalResult:%v, OcSupportedFeatures:%v, OcOlr:%v, Load:%v, SupportedFeatures:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.Drmp, m.VendorSpecificApplicationId, m.ResultCode, m.ExperimentalResult, m.OcSupportedFeatures, m.OcOlr, m.Load, m.SupportedFeatures, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// marshalAVPWithVendor serializes an AVP with optional vendor ID
func marshalAVPWithVendor(code uint32, data models_base.Type, mandatory, protected bool, vendorID uint32) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Determine if we need vendor ID in header
	hasVendor := vendorID != 0

	// Calculate header size
	headerSize := 8
	if hasVendor {
		headerSize = 12 // With vendor ID
	}

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if hasVendor {
		flags |= 0x80 // V-bit
	}
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Vendor ID (if needed)
	if hasVendor {
		binary.BigEndian.PutUint32(buf[8:12], vendorID)
	}

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// Pointer helper functions for grouped AVP field assignments in tests
func ptrUTF8String(s string) *models_base.UTF8String {
	v := models_base.UTF8String(s)
	return &v
}

func ptrOctetString(b []byte) *models_base.OctetString {
	v := models_base.OctetString(b)
	return &v
}

func ptrUnsigned32(u uint32) *models_base.Unsigned32 {
	v := models_base.Unsigned32(u)
	return &v
}

func ptrUnsigned64(u uint64) *models_base.Unsigned64 {
	v := models_base.Unsigned64(u)
	return &v
}

func ptrEnumerated(e uint32) *models_base.Enumerated {
	v := models_base.Enumerated(e)
	return &v
}

func ptrDiameterIdentity(d string) *models_base.DiameterIdentity {
	v := models_base.DiameterIdentity(d)
	return &v
}

func ptrAddress(a models_base.Address) *models_base.Address {
	return &a
}

func ptrTime(t models_base.Time) *models_base.Time {
	return &t
}

func ptrFloat32(f float32) *models_base.Float32 {
	v := models_base.Float32(f)
	return &v
}

func ptrFloat64(f float64) *models_base.Float64 {
	v := models_base.Float64(f)
	return &v
}
