// Code generated by diameter-codegen. DO NOT EDIT.

package s6a

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/hsdfat8/diam-gw/models_base"
)

// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

// Grouped AVP structures

// AllocationRetentionPriority represents the Allocation-Retention-Priority grouped AVP (AVP Code 1034)
type AllocationRetentionPriority struct {
	PriorityLevel           models_base.Unsigned32 // Required
	PreEmptionCapability    models_base.Enumerated // Required
	PreEmptionVulnerability models_base.Enumerated // Required
}

// Marshal serializes AllocationRetentionPriority to bytes
func (g *AllocationRetentionPriority) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal PriorityLevel (required)
	buf.Write(marshalAVP(1046, g.PriorityLevel, true, false))

	// Marshal PreEmptionCapability (required)
	buf.Write(marshalAVP(1047, g.PreEmptionCapability, true, false))

	// Marshal PreEmptionVulnerability (required)
	buf.Write(marshalAVP(1048, g.PreEmptionVulnerability, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AllocationRetentionPriority
func (g *AllocationRetentionPriority) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1046: // Priority-Level
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.PriorityLevel = val.(models_base.Unsigned32)
			}
		case 1047: // Pre-emption-Capability
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				g.PreEmptionCapability = val.(models_base.Enumerated)
			}
		case 1048: // Pre-emption-Vulnerability
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				g.PreEmptionVulnerability = val.(models_base.Enumerated)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EmergencyInfo represents the Emergency-Info grouped AVP (AVP Code 1687)
type EmergencyInfo struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes EmergencyInfo to bytes
func (g *EmergencyInfo) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into EmergencyInfo
func (g *EmergencyInfo) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// VendorSpecificApplicationId represents the Vendor-Specific-Application-Id grouped AVP (AVP Code 260)
type VendorSpecificApplicationId struct {
	VendorId          *models_base.Unsigned32 // Optional
	AuthApplicationId *models_base.Unsigned32 // Optional
	AcctApplicationId *models_base.Unsigned32 // Optional
}

// Marshal serializes VendorSpecificApplicationId to bytes
func (g *VendorSpecificApplicationId) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VendorId (optional)
	if g.VendorId != nil {
		buf.Write(marshalAVP(266, *g.VendorId, true, false))
	}

	// Marshal AuthApplicationId (optional)
	if g.AuthApplicationId != nil {
		buf.Write(marshalAVP(258, *g.AuthApplicationId, true, false))
	}

	// Marshal AcctApplicationId (optional)
	if g.AcctApplicationId != nil {
		buf.Write(marshalAVP(259, *g.AcctApplicationId, true, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into VendorSpecificApplicationId
func (g *VendorSpecificApplicationId) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.VendorId = &v
			}
		case 258: // Auth-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AuthApplicationId = &v
			}
		case 259: // Acct-Application-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AcctApplicationId = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MTLR represents the MT-LR grouped AVP (AVP Code 1484)
type MTLR struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes MTLR to bytes
func (g *MTLR) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into MTLR
func (g *MTLR) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// SubscriptionData represents the Subscription-Data grouped AVP (AVP Code 1400)
type SubscriptionData struct {
	SubscriberStatus                     *models_base.Enumerated          // Optional
	Msisdn                               *models_base.OctetString         // Optional
	AMsisdn                              *models_base.OctetString         // Optional
	StnSr                                *models_base.OctetString         // Optional
	IcsIndicator                         *models_base.OctetString         // Optional - WARNING: AVP code not defined, DO NOT USE
	NetworkAccessMode                    *models_base.Enumerated          // Optional
	OperatorDeterminedBarring            *models_base.Unsigned32          // Optional
	HplmnOdb                             *models_base.Unsigned32          // Optional
	RegionalSubscriptionZoneCode         []models_base.OctetString        // Optional
	AccessRestrictionData                *models_base.Unsigned32          // Optional
	ApnOiReplacement                     *models_base.UTF8String          // Optional
	LcsInfo                              *LCSInfo                         // Optional
	TeleserviceList                      *TeleserviceList                 // Optional
	CallBarringInfo                      []*CallBarringInfo               // Optional
	ChargingCharacteristics              *models_base.OctetString         // Optional
	Ambr                                 *AMBR                            // Optional
	ApnConfigurationProfile              *APNConfigurationProfile         // Optional
	RatFrequencySelectionPriorityId      *models_base.Unsigned32          // Optional
	TraceData                            *TraceData                       // Optional
	GprsSubscriptionData                 *GPRSSubscriptionData            // Optional
	CsgSubscriptionData                  []*CSGSubscriptionData           // Optional
	RoamingRestricted                    *models_base.Enumerated          // Optional
	SubscribedPeriodicRauTauTimer        *models_base.Unsigned32          // Optional
	MpsPriority                          *models_base.Unsigned32          // Optional
	VplmnLipaAllowed                     *models_base.Enumerated          // Optional
	RelayNodeIndicator                   *models_base.Enumerated          // Optional
	MdtUserConsent                       *models_base.Enumerated          // Optional
	SubscribedVsrvcc                     *models_base.Unsigned32          // Optional
	ProseSubscriptionData                *ProSeSubscriptionData           // Optional
	SubscriptionDataFlags                *models_base.Unsigned32          // Optional
	AdjacentAccessRestrictionData        []*AdjacentAccessRestrictionData // Optional
	DlBufferingSuggestedPacketCount      *models_base.Integer32           // Optional
	ImsiGroupId                          []*IMSIGroupId                   // Optional
	UeUsageType                          *models_base.Unsigned32          // Optional
	AeseCommunicationPattern             []models_base.OctetString        // Optional - WARNING: AVP code not defined, DO NOT USE
	MonitoringEventConfiguration         []*MonitoringEventConfiguration  // Optional
	EmergencyInfo                        *EmergencyInfo                   // Optional
	V2xSubscriptionData                  *V2XSubscriptionData             // Optional
	EdrxCycleLength                      *EDRXCycleLength                 // Optional
	ExternalIdentifier                   *models_base.OctetString         // Optional - WARNING: AVP code not defined, DO NOT USE
	ActiveTime                           *models_base.OctetString         // Optional - WARNING: AVP code not defined, DO NOT USE
	ServiceGapTime                       *models_base.OctetString         // Optional - WARNING: AVP code not defined, DO NOT USE
	BroadcastLocationAssistanceDataTypes *models_base.OctetString         // Optional - WARNING: AVP code not defined, DO NOT USE
	AerialUeSubscriptionInformation      *models_base.OctetString         // Optional - WARNING: AVP code not defined, DO NOT USE
	CoreNetworkRestrictions              *models_base.OctetString         // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes SubscriptionData to bytes
func (g *SubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal SubscriberStatus (optional)
	if g.SubscriberStatus != nil {
		buf.Write(marshalAVPWithVendor(1424, *g.SubscriberStatus, true, false, 10415))
	}

	// Marshal Msisdn (optional)
	if g.Msisdn != nil {
		buf.Write(marshalAVP(701, *g.Msisdn, true, false))
	}

	// Marshal AMsisdn (optional)
	if g.AMsisdn != nil {
		buf.Write(marshalAVP(1643, *g.AMsisdn, true, false))
	}

	// Marshal StnSr (optional)
	if g.StnSr != nil {
		buf.Write(marshalAVPWithVendor(1433, *g.StnSr, true, false, 10415))
	}

	// Marshal IcsIndicator (optional)
	if g.IcsIndicator != nil {
		buf.Write(marshalAVP(0, *g.IcsIndicator, false, false))
	}

	// Marshal NetworkAccessMode (optional)
	if g.NetworkAccessMode != nil {
		buf.Write(marshalAVPWithVendor(1417, *g.NetworkAccessMode, true, false, 10415))
	}

	// Marshal OperatorDeterminedBarring (optional)
	if g.OperatorDeterminedBarring != nil {
		buf.Write(marshalAVPWithVendor(1425, *g.OperatorDeterminedBarring, true, false, 10415))
	}

	// Marshal HplmnOdb (optional)
	if g.HplmnOdb != nil {
		buf.Write(marshalAVPWithVendor(1418, *g.HplmnOdb, true, false, 10415))
	}

	// Marshal RegionalSubscriptionZoneCode (repeated)
	for _, v := range g.RegionalSubscriptionZoneCode {
		buf.Write(marshalAVPWithVendor(1446, v, true, false, 10415))
	}

	// Marshal AccessRestrictionData (optional)
	if g.AccessRestrictionData != nil {
		buf.Write(marshalAVPWithVendor(1426, *g.AccessRestrictionData, true, false, 10415))
	}

	// Marshal ApnOiReplacement (optional)
	if g.ApnOiReplacement != nil {
		buf.Write(marshalAVPWithVendor(1427, *g.ApnOiReplacement, true, false, 10415))
	}

	// Marshal LcsInfo (grouped)
	if g.LcsInfo != nil {
		if groupedData, err := g.LcsInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1473, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal TeleserviceList (grouped)
	if g.TeleserviceList != nil {
		if groupedData, err := g.TeleserviceList.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1486, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal CallBarringInfo (repeated, grouped)
	for _, v := range g.CallBarringInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1461, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal ChargingCharacteristics (optional)
	if g.ChargingCharacteristics != nil {
		buf.Write(marshalAVP(13, *g.ChargingCharacteristics, true, false))
	}

	// Marshal Ambr (grouped)
	if g.Ambr != nil {
		if groupedData, err := g.Ambr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1435, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal ApnConfigurationProfile (grouped)
	if g.ApnConfigurationProfile != nil {
		if groupedData, err := g.ApnConfigurationProfile.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1429, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal RatFrequencySelectionPriorityId (optional)
	if g.RatFrequencySelectionPriorityId != nil {
		buf.Write(marshalAVPWithVendor(1440, *g.RatFrequencySelectionPriorityId, true, false, 10415))
	}

	// Marshal TraceData (grouped)
	if g.TraceData != nil {
		if groupedData, err := g.TraceData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1458, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal GprsSubscriptionData (grouped)
	if g.GprsSubscriptionData != nil {
		if groupedData, err := g.GprsSubscriptionData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1469, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal CsgSubscriptionData (repeated, grouped)
	for _, v := range g.CsgSubscriptionData {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1436, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal RoamingRestricted (optional)
	if g.RoamingRestricted != nil {
		buf.Write(marshalAVPWithVendor(1457, *g.RoamingRestricted, true, false, 10415))
	}

	// Marshal SubscribedPeriodicRauTauTimer (optional)
	if g.SubscribedPeriodicRauTauTimer != nil {
		buf.Write(marshalAVPWithVendor(1619, *g.SubscribedPeriodicRauTauTimer, true, false, 10415))
	}

	// Marshal MpsPriority (optional)
	if g.MpsPriority != nil {
		buf.Write(marshalAVPWithVendor(1616, *g.MpsPriority, true, false, 10415))
	}

	// Marshal VplmnLipaAllowed (optional)
	if g.VplmnLipaAllowed != nil {
		buf.Write(marshalAVPWithVendor(1617, *g.VplmnLipaAllowed, true, false, 10415))
	}

	// Marshal RelayNodeIndicator (optional)
	if g.RelayNodeIndicator != nil {
		buf.Write(marshalAVPWithVendor(1635, *g.RelayNodeIndicator, true, false, 10415))
	}

	// Marshal MdtUserConsent (optional)
	if g.MdtUserConsent != nil {
		buf.Write(marshalAVPWithVendor(1636, *g.MdtUserConsent, true, false, 10415))
	}

	// Marshal SubscribedVsrvcc (optional)
	if g.SubscribedVsrvcc != nil {
		buf.Write(marshalAVPWithVendor(1638, *g.SubscribedVsrvcc, true, false, 10415))
	}

	// Marshal ProseSubscriptionData (grouped)
	if g.ProseSubscriptionData != nil {
		if groupedData, err := g.ProseSubscriptionData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1490, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal SubscriptionDataFlags (optional)
	if g.SubscriptionDataFlags != nil {
		buf.Write(marshalAVPWithVendor(1637, *g.SubscriptionDataFlags, true, false, 10415))
	}

	// Marshal AdjacentAccessRestrictionData (repeated, grouped)
	for _, v := range g.AdjacentAccessRestrictionData {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1673, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal DlBufferingSuggestedPacketCount (optional)
	if g.DlBufferingSuggestedPacketCount != nil {
		buf.Write(marshalAVPWithVendor(1674, *g.DlBufferingSuggestedPacketCount, true, false, 10415))
	}

	// Marshal ImsiGroupId (repeated, grouped)
	for _, v := range g.ImsiGroupId {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1675, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal UeUsageType (optional)
	if g.UeUsageType != nil {
		buf.Write(marshalAVPWithVendor(1680, *g.UeUsageType, true, false, 10415))
	}

	// Marshal AeseCommunicationPattern (repeated)
	for _, v := range g.AeseCommunicationPattern {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal MonitoringEventConfiguration (repeated, grouped)
	for _, v := range g.MonitoringEventConfiguration {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1491, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal EmergencyInfo (grouped)
	if g.EmergencyInfo != nil {
		if groupedData, err := g.EmergencyInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1687, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal V2xSubscriptionData (grouped)
	if g.V2xSubscriptionData != nil {
		if groupedData, err := g.V2xSubscriptionData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1688, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal EdrxCycleLength (grouped)
	if g.EdrxCycleLength != nil {
		if groupedData, err := g.EdrxCycleLength.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1691, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal ExternalIdentifier (optional)
	if g.ExternalIdentifier != nil {
		buf.Write(marshalAVP(0, *g.ExternalIdentifier, false, false))
	}

	// Marshal ActiveTime (optional)
	if g.ActiveTime != nil {
		buf.Write(marshalAVP(0, *g.ActiveTime, false, false))
	}

	// Marshal ServiceGapTime (optional)
	if g.ServiceGapTime != nil {
		buf.Write(marshalAVP(0, *g.ServiceGapTime, false, false))
	}

	// Marshal BroadcastLocationAssistanceDataTypes (optional)
	if g.BroadcastLocationAssistanceDataTypes != nil {
		buf.Write(marshalAVP(0, *g.BroadcastLocationAssistanceDataTypes, false, false))
	}

	// Marshal AerialUeSubscriptionInformation (optional)
	if g.AerialUeSubscriptionInformation != nil {
		buf.Write(marshalAVP(0, *g.AerialUeSubscriptionInformation, false, false))
	}

	// Marshal CoreNetworkRestrictions (optional)
	if g.CoreNetworkRestrictions != nil {
		buf.Write(marshalAVP(0, *g.CoreNetworkRestrictions, false, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into SubscriptionData
func (g *SubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1424: // Subscriber-Status
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.SubscriberStatus = &v
			}
		case 701: // MSISDN
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Msisdn = &v
			}
		case 1643: // A-MSISDN
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.AMsisdn = &v
			}
		case 1433: // STN-SR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.StnSr = &v
			}
		// case 0: // ICS-Indicator (AVP code not defined)
		case 1417: // Network-Access-Mode
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.NetworkAccessMode = &v
			}
		case 1425: // Operator-Determined-Barring
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.OperatorDeterminedBarring = &v
			}
		case 1418: // HPLMN-ODB
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.HplmnOdb = &v
			}
		case 1446: // Regional-Subscription-Zone-Code
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.RegionalSubscriptionZoneCode = append(g.RegionalSubscriptionZoneCode, val.(models_base.OctetString))
			}
		case 1426: // Access-Restriction-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.AccessRestrictionData = &v
			}
		case 1427: // APN-OI-Replacement
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.ApnOiReplacement = &v
			}
		case 1473: // LCS-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &LCSInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.LcsInfo = grouped
			}
		case 1486: // Teleservice-List
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &TeleserviceList{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.TeleserviceList = grouped
			}
		case 1461: // Call-Barring-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &CallBarringInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.CallBarringInfo = append(g.CallBarringInfo, grouped)
			}
		case 13: // 3GPP-Charging-Characteristics
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ChargingCharacteristics = &v
			}
		case 1435: // AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AMBR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Ambr = grouped
			}
		case 1429: // APN-Configuration-Profile
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &APNConfigurationProfile{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ApnConfigurationProfile = grouped
			}
		case 1440: // RAT-Frequency-Selection-Priority-ID
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.RatFrequencySelectionPriorityId = &v
			}
		case 1458: // Trace-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &TraceData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.TraceData = grouped
			}
		case 1469: // GPRS-Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &GPRSSubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.GprsSubscriptionData = grouped
			}
		case 1436: // CSG-Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &CSGSubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.CsgSubscriptionData = append(g.CsgSubscriptionData, grouped)
			}
		case 1457: // Roaming-Restricted-Due-To-Unsupported-Feature
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.RoamingRestricted = &v
			}
		case 1619: // Subscribed-Periodic-RAU-TAU-Timer
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.SubscribedPeriodicRauTauTimer = &v
			}
		case 1616: // MPS-Priority
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.MpsPriority = &v
			}
		case 1617: // VPLMN-LIPA-Allowed
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.VplmnLipaAllowed = &v
			}
		case 1635: // Relay-Node-Indicator
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.RelayNodeIndicator = &v
			}
		case 1636: // MDT-User-Consent
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.MdtUserConsent = &v
			}
		case 1638: // Subscribed-VSRVCC
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.SubscribedVsrvcc = &v
			}
		case 1490: // ProSe-Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &ProSeSubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ProseSubscriptionData = grouped
			}
		case 1637: // Subscription-Data-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.SubscriptionDataFlags = &v
			}
		case 1673: // Adjacent-Access-Restriction-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AdjacentAccessRestrictionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.AdjacentAccessRestrictionData = append(g.AdjacentAccessRestrictionData, grouped)
			}
		case 1674: // DL-Buffering-Suggested-Packet-Count
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeInteger32(avpValue)
			if err == nil {
				v := val.(models_base.Integer32)
				g.DlBufferingSuggestedPacketCount = &v
			}
		case 1675: // IMSI-Group-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &IMSIGroupId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ImsiGroupId = append(g.ImsiGroupId, grouped)
			}
		case 1680: // UE-Usage-Type
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.UeUsageType = &v
			}
		// case 0: // AESE-Communication-Pattern (AVP code not defined)
		case 1491: // Monitoring-Event-Configuration
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &MonitoringEventConfiguration{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.MonitoringEventConfiguration = append(g.MonitoringEventConfiguration, grouped)
			}
		case 1687: // Emergency-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EmergencyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EmergencyInfo = grouped
			}
		case 1688: // V2X-Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &V2XSubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.V2xSubscriptionData = grouped
			}
		case 1691: // eDRX-Cycle-Length
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EDRXCycleLength{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EdrxCycleLength = grouped
			}
			// case 0: // External-Identifier (AVP code not defined)
			// case 0: // Active-Time (AVP code not defined)
			// case 0: // Service-Gap-Time (AVP code not defined)
			// case 0: // Broadcast-Location-Assistance-Data-Types (AVP code not defined)
			// case 0: // Aerial-UE-Subscription-Information (AVP code not defined)
			// case 0: // Core-Network-Restrictions (AVP code not defined)
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MIPHomeAgentHost represents the MIP-Home-Agent-Host grouped AVP (AVP Code 348)
type MIPHomeAgentHost struct {
	DestinationRealm models_base.DiameterIdentity // Required
	DestinationHost  models_base.DiameterIdentity // Required
}

// Marshal serializes MIPHomeAgentHost to bytes
func (g *MIPHomeAgentHost) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, g.DestinationRealm, true, false))

	// Marshal DestinationHost (required)
	buf.Write(marshalAVP(293, g.DestinationHost, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into MIPHomeAgentHost
func (g *MIPHomeAgentHost) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.DestinationHost = val.(models_base.DiameterIdentity)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// ExperimentalResult represents the Experimental-Result grouped AVP (AVP Code 297)
type ExperimentalResult struct {
	VendorId               models_base.Unsigned32 // Required
	ExperimentalResultCode models_base.Unsigned32 // Required
}

// Marshal serializes ExperimentalResult to bytes
func (g *ExperimentalResult) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VendorId (required)
	buf.Write(marshalAVP(266, g.VendorId, true, false))

	// Marshal ExperimentalResultCode (required)
	buf.Write(marshalAVP(298, g.ExperimentalResultCode, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into ExperimentalResult
func (g *ExperimentalResult) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 266: // Vendor-Id
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.VendorId = val.(models_base.Unsigned32)
			}
		case 298: // Experimental-Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ExperimentalResultCode = val.(models_base.Unsigned32)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// E2ESequence represents the E2E-Sequence grouped AVP (AVP Code 300)
type E2ESequence struct {
	Avp models_base.OctetString // Required - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes E2ESequence to bytes
func (g *E2ESequence) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal Avp (required)
	buf.Write(marshalAVP(0, g.Avp, false, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into E2ESequence
func (g *E2ESequence) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MIP6AgentInfo represents the MIP6-Agent-Info grouped AVP (AVP Code 486)
type MIP6AgentInfo struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes MIP6AgentInfo to bytes
func (g *MIP6AgentInfo) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into MIP6AgentInfo
func (g *MIP6AgentInfo) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// LCSPrivacyException represents the LCS-PrivacyException grouped AVP (AVP Code 1475)
type LCSPrivacyException struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes LCSPrivacyException to bytes
func (g *LCSPrivacyException) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into LCSPrivacyException
func (g *LCSPrivacyException) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// LCSInfo represents the LCS-Info grouped AVP (AVP Code 1473)
type LCSInfo struct {
	LcsPrivacyException []*LCSPrivacyException // Optional
	MoLr                *MOLR                  // Optional
	MtLr                []*MTLR                // Optional
}

// Marshal serializes LCSInfo to bytes
func (g *LCSInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal LcsPrivacyException (repeated, grouped)
	for _, v := range g.LcsPrivacyException {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1475, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal MoLr (grouped)
	if g.MoLr != nil {
		if groupedData, err := g.MoLr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1485, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal MtLr (repeated, grouped)
	for _, v := range g.MtLr {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1484, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into LCSInfo
func (g *LCSInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1475: // LCS-PrivacyException
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &LCSPrivacyException{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.LcsPrivacyException = append(g.LcsPrivacyException, grouped)
			}
		case 1485: // MO-LR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &MOLR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.MoLr = grouped
			}
		case 1484: // MT-LR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &MTLR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.MtLr = append(g.MtLr, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// APNConfigurationProfile represents the APN-Configuration-Profile grouped AVP (AVP Code 1429)
type APNConfigurationProfile struct {
	ContextIdentifier                     models_base.Unsigned32 // Required
	AllApnConfigurationsIncludedIndicator models_base.Enumerated // Required
	ApnConfiguration                      []*APNConfiguration    // Optional
}

// Marshal serializes APNConfigurationProfile to bytes
func (g *APNConfigurationProfile) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ContextIdentifier (required)
	buf.Write(marshalAVPWithVendor(1423, g.ContextIdentifier, true, false, 10415))

	// Marshal AllApnConfigurationsIncludedIndicator (required)
	buf.Write(marshalAVPWithVendor(1428, g.AllApnConfigurationsIncludedIndicator, true, false, 10415))

	// Marshal ApnConfiguration (repeated, grouped)
	for _, v := range g.ApnConfiguration {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1430, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into APNConfigurationProfile
func (g *APNConfigurationProfile) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1423: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ContextIdentifier = val.(models_base.Unsigned32)
			}
		case 1428: // All-APN-Configurations-Included-Indicator
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				g.AllApnConfigurationsIncludedIndicator = val.(models_base.Enumerated)
			}
		case 1430: // APN-Configuration
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &APNConfiguration{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.ApnConfiguration = append(g.ApnConfiguration, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EDRXCycleLength represents the eDRX-Cycle-Length grouped AVP (AVP Code 1691)
type EDRXCycleLength struct {
	EdrxCycleLengthValue []models_base.OctetString // Optional
}

// Marshal serializes EDRXCycleLength to bytes
func (g *EDRXCycleLength) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal EdrxCycleLengthValue (repeated)
	for _, v := range g.EdrxCycleLengthValue {
		buf.Write(marshalAVPWithVendor(1692, v, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EDRXCycleLength
func (g *EDRXCycleLength) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1692: // eDRX-Cycle-Length-Value
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.EdrxCycleLengthValue = append(g.EdrxCycleLengthValue, val.(models_base.OctetString))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AuthenticationInfo represents the Authentication-Info grouped AVP (AVP Code 1413)
type AuthenticationInfo struct {
	EUtranVector []*EUTRANVector // Optional
	UtranVector  []*UTRANVector  // Optional
	GeranVector  []*GERANVector  // Optional
}

// Marshal serializes AuthenticationInfo to bytes
func (g *AuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal EUtranVector (repeated, grouped)
	for _, v := range g.EUtranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1414, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal UtranVector (repeated, grouped)
	for _, v := range g.UtranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1415, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	// Marshal GeranVector (repeated, grouped)
	for _, v := range g.GeranVector {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1416, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AuthenticationInfo
func (g *AuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1414: // E-UTRAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EUTRANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EUtranVector = append(g.EUtranVector, grouped)
			}
		case 1415: // UTRAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &UTRANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.UtranVector = append(g.UtranVector, grouped)
			}
		case 1416: // GERAN-Vector
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &GERANVector{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.GeranVector = append(g.GeranVector, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EUTRANVector represents the E-UTRAN-Vector grouped AVP (AVP Code 1414)
type EUTRANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Xres       models_base.OctetString // Required
	Autn       models_base.OctetString // Required
	Kasme      models_base.OctetString // Required
}

// Marshal serializes EUTRANVector to bytes
func (g *EUTRANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(1419, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(1447, g.Rand, true, false, 10415))

	// Marshal Xres (required)
	buf.Write(marshalAVPWithVendor(1448, g.Xres, true, false, 10415))

	// Marshal Autn (required)
	buf.Write(marshalAVPWithVendor(1449, g.Autn, true, false, 10415))

	// Marshal Kasme (required)
	buf.Write(marshalAVPWithVendor(1450, g.Kasme, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EUTRANVector
func (g *EUTRANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1419: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case 1447: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case 1448: // XRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Xres = val.(models_base.OctetString)
			}
		case 1449: // AUTN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Autn = val.(models_base.OctetString)
			}
		case 1450: // KASME
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Kasme = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// APNConfiguration represents the APN-Configuration grouped AVP (AVP Code 1430)
type APNConfiguration struct {
	ContextIdentifier           models_base.Unsigned32        // Required
	PdnType                     *models_base.Enumerated       // Optional
	ServiceSelection            models_base.UTF8String        // Required
	EpsSubscribedQosProfile     *EPSSubscribedQoSProfile      // Optional
	VplmnDynamicAddressAllowed  *models_base.Enumerated       // Optional
	Mip6AgentInfo               *MIP6AgentInfo                // Optional
	PdnGwAllocationType         *models_base.Enumerated       // Optional
	Ambr                        *AMBR                         // Optional
	VisitedNetworkIdentifier    *models_base.OctetString      // Optional
	SpecificApnInfo             *SpecificAPNInfo              // Optional
	SiptoPermission             *models_base.Enumerated       // Optional
	LipaPermission              *models_base.Enumerated       // Optional
	RestorationPriority         *models_base.Enumerated       // Optional
	SiptoLocalNetworkPermission *models_base.Enumerated       // Optional
	WlanOffloadability          *models_base.Enumerated       // Optional
	NonIpPdnTypeIndicator       *models_base.Enumerated       // Optional
	NonIpDataDeliveryMechanism  *models_base.Unsigned32       // Optional
	ScefId                      *models_base.OctetString      // Optional
	ScefRealm                   *models_base.DiameterIdentity // Optional
	PreferredDataMode           *models_base.Unsigned32       // Optional
	PdnConnectionContinuity     *models_base.Unsigned32       // Optional
}

// Marshal serializes APNConfiguration to bytes
func (g *APNConfiguration) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ContextIdentifier (required)
	buf.Write(marshalAVPWithVendor(1423, g.ContextIdentifier, true, false, 10415))

	// Marshal PdnType (optional)
	if g.PdnType != nil {
		buf.Write(marshalAVPWithVendor(1456, *g.PdnType, true, false, 10415))
	}

	// Marshal ServiceSelection (required)
	buf.Write(marshalAVP(493, g.ServiceSelection, false, false))

	// Marshal EpsSubscribedQosProfile (grouped)
	if g.EpsSubscribedQosProfile != nil {
		if groupedData, err := g.EpsSubscribedQosProfile.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1431, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal VplmnDynamicAddressAllowed (optional)
	if g.VplmnDynamicAddressAllowed != nil {
		buf.Write(marshalAVPWithVendor(1432, *g.VplmnDynamicAddressAllowed, true, false, 10415))
	}

	// Marshal Mip6AgentInfo (grouped)
	if g.Mip6AgentInfo != nil {
		if groupedData, err := g.Mip6AgentInfo.Marshal(); err == nil {
			buf.Write(marshalAVP(486, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal PdnGwAllocationType (optional)
	if g.PdnGwAllocationType != nil {
		buf.Write(marshalAVPWithVendor(1438, *g.PdnGwAllocationType, true, false, 10415))
	}

	// Marshal Ambr (grouped)
	if g.Ambr != nil {
		if groupedData, err := g.Ambr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1435, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal VisitedNetworkIdentifier (optional)
	if g.VisitedNetworkIdentifier != nil {
		buf.Write(marshalAVP(600, *g.VisitedNetworkIdentifier, true, false))
	}

	// Marshal SpecificApnInfo (grouped)
	if g.SpecificApnInfo != nil {
		if groupedData, err := g.SpecificApnInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1472, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal SiptoPermission (optional)
	if g.SiptoPermission != nil {
		buf.Write(marshalAVPWithVendor(1622, *g.SiptoPermission, true, false, 10415))
	}

	// Marshal LipaPermission (optional)
	if g.LipaPermission != nil {
		buf.Write(marshalAVPWithVendor(1618, *g.LipaPermission, true, false, 10415))
	}

	// Marshal RestorationPriority (optional)
	if g.RestorationPriority != nil {
		buf.Write(marshalAVPWithVendor(1663, *g.RestorationPriority, true, false, 10415))
	}

	// Marshal SiptoLocalNetworkPermission (optional)
	if g.SiptoLocalNetworkPermission != nil {
		buf.Write(marshalAVPWithVendor(1666, *g.SiptoLocalNetworkPermission, true, false, 10415))
	}

	// Marshal WlanOffloadability (optional)
	if g.WlanOffloadability != nil {
		buf.Write(marshalAVPWithVendor(1667, *g.WlanOffloadability, true, false, 10415))
	}

	// Marshal NonIpPdnTypeIndicator (optional)
	if g.NonIpPdnTypeIndicator != nil {
		buf.Write(marshalAVPWithVendor(1681, *g.NonIpPdnTypeIndicator, true, false, 10415))
	}

	// Marshal NonIpDataDeliveryMechanism (optional)
	if g.NonIpDataDeliveryMechanism != nil {
		buf.Write(marshalAVPWithVendor(1682, *g.NonIpDataDeliveryMechanism, true, false, 10415))
	}

	// Marshal ScefId (optional)
	if g.ScefId != nil {
		buf.Write(marshalAVPWithVendor(1608, *g.ScefId, true, false, 10415))
	}

	// Marshal ScefRealm (optional)
	if g.ScefRealm != nil {
		buf.Write(marshalAVPWithVendor(1684, *g.ScefRealm, true, false, 10415))
	}

	// Marshal PreferredDataMode (optional)
	if g.PreferredDataMode != nil {
		buf.Write(marshalAVPWithVendor(1686, *g.PreferredDataMode, true, false, 10415))
	}

	// Marshal PdnConnectionContinuity (optional)
	if g.PdnConnectionContinuity != nil {
		buf.Write(marshalAVPWithVendor(1690, *g.PdnConnectionContinuity, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into APNConfiguration
func (g *APNConfiguration) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1423: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ContextIdentifier = val.(models_base.Unsigned32)
			}
		case 1456: // PDN-Type
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.PdnType = &v
			}
		case 493: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				g.ServiceSelection = val.(models_base.UTF8String)
			}
		case 1431: // EPS-Subscribed-QoS-Profile
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &EPSSubscribedQoSProfile{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.EpsSubscribedQosProfile = grouped
			}
		case 1432: // VPLMN-Dynamic-Address-Allowed
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.VplmnDynamicAddressAllowed = &v
			}
		case 486: // MIP6-Agent-Info
			grouped := &MIP6AgentInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Mip6AgentInfo = grouped
			}
		case 1438: // PDN-GW-Allocation-Type
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.PdnGwAllocationType = &v
			}
		case 1435: // AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AMBR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Ambr = grouped
			}
		case 600: // Visited-Network-Identifier
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.VisitedNetworkIdentifier = &v
			}
		case 1472: // Specific-APN-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &SpecificAPNInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.SpecificApnInfo = grouped
			}
		case 1622: // SIPTO-Permission
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.SiptoPermission = &v
			}
		case 1618: // LIPA-Permission
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.LipaPermission = &v
			}
		case 1663: // Restoration-Priority
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.RestorationPriority = &v
			}
		case 1666: // SIPTO-Local-Network-Permission
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.SiptoLocalNetworkPermission = &v
			}
		case 1667: // WLAN-offloadability
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.WlanOffloadability = &v
			}
		case 1681: // Non-IP-PDN-Type-Indicator
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.NonIpPdnTypeIndicator = &v
			}
		case 1682: // Non-IP-Data-Delivery-Mechanism
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.NonIpDataDeliveryMechanism = &v
			}
		case 1608: // SCEF-ID
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ScefId = &v
			}
		case 1684: // SCEF-Realm
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				g.ScefRealm = &v
			}
		case 1686: // Preferred-Data-Mode
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.PreferredDataMode = &v
			}
		case 1690: // PDN-Connection-Continuity
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.PdnConnectionContinuity = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// ProSeSubscriptionData represents the ProSe-Subscription-Data grouped AVP (AVP Code 1490)
type ProSeSubscriptionData struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes ProSeSubscriptionData to bytes
func (g *ProSeSubscriptionData) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into ProSeSubscriptionData
func (g *ProSeSubscriptionData) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// AdjacentAccessRestrictionData represents the Adjacent-Access-Restriction-Data grouped AVP (AVP Code 1673)
type AdjacentAccessRestrictionData struct {
	VisitedPlmnId         models_base.OctetString // Required
	AccessRestrictionData models_base.Unsigned32  // Required
}

// Marshal serializes AdjacentAccessRestrictionData to bytes
func (g *AdjacentAccessRestrictionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VisitedPlmnId (required)
	buf.Write(marshalAVPWithVendor(1407, g.VisitedPlmnId, true, false, 10415))

	// Marshal AccessRestrictionData (required)
	buf.Write(marshalAVPWithVendor(1426, g.AccessRestrictionData, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AdjacentAccessRestrictionData
func (g *AdjacentAccessRestrictionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1407: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.VisitedPlmnId = val.(models_base.OctetString)
			}
		case 1426: // Access-Restriction-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.AccessRestrictionData = val.(models_base.Unsigned32)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AMBR represents the AMBR grouped AVP (AVP Code 1435)
type AMBR struct {
	MaxRequestedBandwidthUl  models_base.Unsigned32  // Required
	MaxRequestedBandwidthDl  models_base.Unsigned32  // Required
	ExtendedMaxRequestedBwUl *models_base.Unsigned32 // Optional
	ExtendedMaxRequestedBwDl *models_base.Unsigned32 // Optional
}

// Marshal serializes AMBR to bytes
func (g *AMBR) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal MaxRequestedBandwidthUl (required)
	buf.Write(marshalAVP(516, g.MaxRequestedBandwidthUl, true, false))

	// Marshal MaxRequestedBandwidthDl (required)
	buf.Write(marshalAVP(515, g.MaxRequestedBandwidthDl, true, false))

	// Marshal ExtendedMaxRequestedBwUl (optional)
	if g.ExtendedMaxRequestedBwUl != nil {
		buf.Write(marshalAVPWithVendor(1466, *g.ExtendedMaxRequestedBwUl, true, false, 10415))
	}

	// Marshal ExtendedMaxRequestedBwDl (optional)
	if g.ExtendedMaxRequestedBwDl != nil {
		buf.Write(marshalAVPWithVendor(1467, *g.ExtendedMaxRequestedBwDl, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AMBR
func (g *AMBR) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 516: // Max-Requested-Bandwidth-UL
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.MaxRequestedBandwidthUl = val.(models_base.Unsigned32)
			}
		case 515: // Max-Requested-Bandwidth-DL
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.MaxRequestedBandwidthDl = val.(models_base.Unsigned32)
			}
		case 1466: // Extended-Max-Requested-BW-UL
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ExtendedMaxRequestedBwUl = &v
			}
		case 1467: // Extended-Max-Requested-BW-DL
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ExtendedMaxRequestedBwDl = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EPSSubscribedQoSProfile represents the EPS-Subscribed-QoS-Profile grouped AVP (AVP Code 1431)
type EPSSubscribedQoSProfile struct {
	QosClassIdentifier          models_base.Enumerated       // Required
	AllocationRetentionPriority *AllocationRetentionPriority // Optional
}

// Marshal serializes EPSSubscribedQoSProfile to bytes
func (g *EPSSubscribedQoSProfile) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal QosClassIdentifier (required)
	buf.Write(marshalAVP(1028, g.QosClassIdentifier, true, false))

	// Marshal AllocationRetentionPriority (grouped)
	if g.AllocationRetentionPriority != nil {
		if groupedData, err := g.AllocationRetentionPriority.Marshal(); err == nil {
			buf.Write(marshalAVP(1034, models_base.Grouped(groupedData), true, false))
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EPSSubscribedQoSProfile
func (g *EPSSubscribedQoSProfile) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1028: // QoS-Class-Identifier
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				g.QosClassIdentifier = val.(models_base.Enumerated)
			}
		case 1034: // Allocation-Retention-Priority
			grouped := &AllocationRetentionPriority{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.AllocationRetentionPriority = grouped
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// V2XSubscriptionData represents the V2X-Subscription-Data grouped AVP (AVP Code 1688)
type V2XSubscriptionData struct {
	V2xPermission *models_base.Unsigned32 // Optional
	UePc5Ambr     *models_base.Unsigned32 // Optional
}

// Marshal serializes V2XSubscriptionData to bytes
func (g *V2XSubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal V2xPermission (optional)
	if g.V2xPermission != nil {
		buf.Write(marshalAVPWithVendor(1689, *g.V2xPermission, true, false, 10415))
	}

	// Marshal UePc5Ambr (optional)
	if g.UePc5Ambr != nil {
		buf.Write(marshalAVPWithVendor(1693, *g.UePc5Ambr, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into V2XSubscriptionData
func (g *V2XSubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1689: // V2X-Permission
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.V2xPermission = &v
			}
		case 1693: // UE-PC5-AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.UePc5Ambr = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// CSGSubscriptionData represents the CSG-Subscription-Data grouped AVP (AVP Code 1436)
type CSGSubscriptionData struct {
	CsgId          models_base.Unsigned32 // Required
	ExpirationDate models_base.Time       // Required
}

// Marshal serializes CSGSubscriptionData to bytes
func (g *CSGSubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal CsgId (required)
	buf.Write(marshalAVPWithVendor(1437, g.CsgId, true, false, 10415))

	// Marshal ExpirationDate (required)
	buf.Write(marshalAVPWithVendor(1439, g.ExpirationDate, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into CSGSubscriptionData
func (g *CSGSubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1437: // CSG-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.CsgId = val.(models_base.Unsigned32)
			}
		case 1439: // Expiration-Date
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeTime(avpValue)
			if err == nil {
				g.ExpirationDate = val.(models_base.Time)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// GERANVector represents the GERAN-Vector grouped AVP (AVP Code 1416)
type GERANVector struct {
	ItemNumber *models_base.Unsigned32 // Optional
	Rand       models_base.OctetString // Required
	Sres       models_base.OctetString // Required
	Kc         models_base.OctetString // Required
}

// Marshal serializes GERANVector to bytes
func (g *GERANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(1419, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(1447, g.Rand, true, false, 10415))

	// Marshal Sres (required)
	buf.Write(marshalAVPWithVendor(1454, g.Sres, true, false, 10415))

	// Marshal Kc (required)
	buf.Write(marshalAVPWithVendor(1453, g.Kc, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into GERANVector
func (g *GERANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1419: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case 1447: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case 1454: // SRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Sres = val.(models_base.OctetString)
			}
		case 1453: // Kc
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Kc = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// FailedAVP represents the Failed-AVP grouped AVP (AVP Code 279)
type FailedAVP struct {
	Avp []models_base.OctetString // Optional - WARNING: AVP code not defined, DO NOT USE
}

// Marshal serializes FailedAVP to bytes
func (g *FailedAVP) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal Avp (repeated)
	for _, v := range g.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into FailedAVP
func (g *FailedAVP) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		_ = avpDataLen // avpValue not needed when no fields are defined

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// TeleserviceList represents the Teleservice-List grouped AVP (AVP Code 1486)
type TeleserviceList struct {
	TsCode []models_base.OctetString // Optional
}

// Marshal serializes TeleserviceList to bytes
func (g *TeleserviceList) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal TsCode (repeated)
	for _, v := range g.TsCode {
		buf.Write(marshalAVPWithVendor(1489, v, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into TeleserviceList
func (g *TeleserviceList) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1489: // TS-Code
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.TsCode = append(g.TsCode, val.(models_base.OctetString))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// VPLMNCSGSubscriptionData represents the VPLMN-CSG-Subscription-Data grouped AVP (AVP Code 1642)
type VPLMNCSGSubscriptionData struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes VPLMNCSGSubscriptionData to bytes
func (g *VPLMNCSGSubscriptionData) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into VPLMNCSGSubscriptionData
func (g *VPLMNCSGSubscriptionData) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// EPSLocationInformation represents the EPS-Location-Information grouped AVP (AVP Code 1496)
type EPSLocationInformation struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes EPSLocationInformation to bytes
func (g *EPSLocationInformation) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into EPSLocationInformation
func (g *EPSLocationInformation) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// RequestedEUTRANAuthenticationInfo represents the Requested-EUTRAN-Authentication-Info grouped AVP (AVP Code 1408)
type RequestedEUTRANAuthenticationInfo struct {
	NumberOfRequestedVectors   *models_base.Unsigned32  // Optional
	ImmediateResponsePreferred *models_base.Enumerated  // Optional
	ReSynchronizationInfo      *models_base.OctetString // Optional
}

// Marshal serializes RequestedEUTRANAuthenticationInfo to bytes
func (g *RequestedEUTRANAuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal NumberOfRequestedVectors (optional)
	if g.NumberOfRequestedVectors != nil {
		buf.Write(marshalAVPWithVendor(1410, *g.NumberOfRequestedVectors, true, false, 10415))
	}

	// Marshal ImmediateResponsePreferred (optional)
	if g.ImmediateResponsePreferred != nil {
		buf.Write(marshalAVPWithVendor(1412, *g.ImmediateResponsePreferred, true, false, 10415))
	}

	// Marshal ReSynchronizationInfo (optional)
	if g.ReSynchronizationInfo != nil {
		buf.Write(marshalAVPWithVendor(1411, *g.ReSynchronizationInfo, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into RequestedEUTRANAuthenticationInfo
func (g *RequestedEUTRANAuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1410: // Number-Of-Requested-Vectors
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.NumberOfRequestedVectors = &v
			}
		case 1412: // Immediate-Response-Preferred
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.ImmediateResponsePreferred = &v
			}
		case 1411: // Re-Synchronization-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ReSynchronizationInfo = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EPSUserState represents the EPS-User-State grouped AVP (AVP Code 1495)
type EPSUserState struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes EPSUserState to bytes
func (g *EPSUserState) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into EPSUserState
func (g *EPSUserState) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// CallBarringInfo represents the Call-Barring-Info grouped AVP (AVP Code 1461)
type CallBarringInfo struct {
	SsCode   models_base.OctetString  // Required
	SsStatus *models_base.OctetString // Optional
}

// Marshal serializes CallBarringInfo to bytes
func (g *CallBarringInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal SsCode (required)
	buf.Write(marshalAVPWithVendor(1476, g.SsCode, true, false, 10415))

	// Marshal SsStatus (optional)
	if g.SsStatus != nil {
		buf.Write(marshalAVPWithVendor(1477, *g.SsStatus, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into CallBarringInfo
func (g *CallBarringInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1476: // SS-Code
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.SsCode = val.(models_base.OctetString)
			}
		case 1477: // SS-Status
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.SsStatus = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MonitoringEventConfiguration represents the Monitoring-Event-Configuration grouped AVP (AVP Code 1491)
type MonitoringEventConfiguration struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes MonitoringEventConfiguration to bytes
func (g *MonitoringEventConfiguration) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into MonitoringEventConfiguration
func (g *MonitoringEventConfiguration) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// SpecificAPNInfo represents the Specific-APN-Info grouped AVP (AVP Code 1472)
type SpecificAPNInfo struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes SpecificAPNInfo to bytes
func (g *SpecificAPNInfo) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into SpecificAPNInfo
func (g *SpecificAPNInfo) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// SupportedServices represents the Supported-Services grouped AVP (AVP Code 3143)
type SupportedServices struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes SupportedServices to bytes
func (g *SupportedServices) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into SupportedServices
func (g *SupportedServices) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// TerminalInformation represents the Terminal-Information grouped AVP (AVP Code 1401)
type TerminalInformation struct {
	Imei            *models_base.UTF8String  // Optional
	Meid            *models_base.OctetString // Optional
	SoftwareVersion *models_base.UTF8String  // Optional
}

// Marshal serializes TerminalInformation to bytes
func (g *TerminalInformation) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal Imei (optional)
	if g.Imei != nil {
		buf.Write(marshalAVPWithVendor(1402, *g.Imei, true, false, 10415))
	}

	// Marshal Meid (optional)
	if g.Meid != nil {
		buf.Write(marshalAVPWithVendor(1471, *g.Meid, true, false, 10415))
	}

	// Marshal SoftwareVersion (optional)
	if g.SoftwareVersion != nil {
		buf.Write(marshalAVPWithVendor(1403, *g.SoftwareVersion, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into TerminalInformation
func (g *TerminalInformation) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1402: // IMEI
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.Imei = &v
			}
		case 1471: // 3GPP2-MEID
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.Meid = &v
			}
		case 1403: // Software-Version
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.SoftwareVersion = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// ProxyInfo represents the Proxy-Info grouped AVP (AVP Code 284)
type ProxyInfo struct {
	ProxyHost  models_base.DiameterIdentity // Required
	ProxyState models_base.OctetString      // Required
}

// Marshal serializes ProxyInfo to bytes
func (g *ProxyInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ProxyHost (required)
	buf.Write(marshalAVP(280, g.ProxyHost, true, false))

	// Marshal ProxyState (required)
	buf.Write(marshalAVP(33, g.ProxyState, true, false))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into ProxyInfo
func (g *ProxyInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 280: // Proxy-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				g.ProxyHost = val.(models_base.DiameterIdentity)
			}
		case 33: // Proxy-State
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.ProxyState = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// ActiveAPN represents the Active-APN grouped AVP (AVP Code 1612)
type ActiveAPN struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes ActiveAPN to bytes
func (g *ActiveAPN) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into ActiveAPN
func (g *ActiveAPN) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// GPRSSubscriptionData represents the GPRS-Subscription-Data grouped AVP (AVP Code 1469)
type GPRSSubscriptionData struct {
	CompleteDataListIncludedIndicator *models_base.Enumerated // Optional
	PdpContext                        []*PDPContext           // Optional
}

// Marshal serializes GPRSSubscriptionData to bytes
func (g *GPRSSubscriptionData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal CompleteDataListIncludedIndicator (optional)
	if g.CompleteDataListIncludedIndicator != nil {
		buf.Write(marshalAVPWithVendor(1468, *g.CompleteDataListIncludedIndicator, true, false, 10415))
	}

	// Marshal PdpContext (repeated, grouped)
	for _, v := range g.PdpContext {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVPWithVendor(1469, models_base.Grouped(groupedData), true, false, 10415))
			}
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into GPRSSubscriptionData
func (g *GPRSSubscriptionData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1468: // Complete-Data-List-Included-Indicator
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.CompleteDataListIncludedIndicator = &v
			}
		case 1469: // PDP-Context
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &PDPContext{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.PdpContext = append(g.PdpContext, grouped)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// RequestedUTRANGERANAuthenticationInfo represents the Requested-UTRAN-GERAN-Authentication-Info grouped AVP (AVP Code 1409)
type RequestedUTRANGERANAuthenticationInfo struct {
	NumberOfRequestedVectors   *models_base.Unsigned32  // Optional
	ImmediateResponsePreferred *models_base.Enumerated  // Optional
	ReSynchronizationInfo      *models_base.OctetString // Optional
}

// Marshal serializes RequestedUTRANGERANAuthenticationInfo to bytes
func (g *RequestedUTRANGERANAuthenticationInfo) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal NumberOfRequestedVectors (optional)
	if g.NumberOfRequestedVectors != nil {
		buf.Write(marshalAVPWithVendor(1410, *g.NumberOfRequestedVectors, true, false, 10415))
	}

	// Marshal ImmediateResponsePreferred (optional)
	if g.ImmediateResponsePreferred != nil {
		buf.Write(marshalAVPWithVendor(1412, *g.ImmediateResponsePreferred, true, false, 10415))
	}

	// Marshal ReSynchronizationInfo (optional)
	if g.ReSynchronizationInfo != nil {
		buf.Write(marshalAVPWithVendor(1411, *g.ReSynchronizationInfo, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into RequestedUTRANGERANAuthenticationInfo
func (g *RequestedUTRANGERANAuthenticationInfo) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1410: // Number-Of-Requested-Vectors
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.NumberOfRequestedVectors = &v
			}
		case 1412: // Immediate-Response-Preferred
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				g.ImmediateResponsePreferred = &v
			}
		case 1411: // Re-Synchronization-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ReSynchronizationInfo = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// MOLR represents the MO-LR grouped AVP (AVP Code 1485)
type MOLR struct {
	// No fields defined - using raw data
	Data []byte
}

// Marshal serializes MOLR to bytes
func (g *MOLR) Marshal() ([]byte, error) {
	return g.Data, nil
}

// Unmarshal deserializes bytes into MOLR
func (g *MOLR) Unmarshal(data []byte) error {
	g.Data = make([]byte, len(data))
	copy(g.Data, data)
	return nil
}

// PDPContext represents the PDP-Context grouped AVP (AVP Code 1469)
type PDPContext struct {
	ContextIdentifier           models_base.Unsigned32       // Required
	PdpType                     *models_base.OctetString     // Optional - WARNING: AVP code not defined, DO NOT USE
	ServiceSelection            *models_base.UTF8String      // Optional
	AllocationRetentionPriority *AllocationRetentionPriority // Optional
	Ambr                        *AMBR                        // Optional
	ExtPdpType                  *models_base.OctetString     // Optional
}

// Marshal serializes PDPContext to bytes
func (g *PDPContext) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ContextIdentifier (required)
	buf.Write(marshalAVPWithVendor(1423, g.ContextIdentifier, true, false, 10415))

	// Marshal PdpType (optional)
	if g.PdpType != nil {
		buf.Write(marshalAVP(0, *g.PdpType, false, false))
	}

	// Marshal ServiceSelection (optional)
	if g.ServiceSelection != nil {
		buf.Write(marshalAVP(493, *g.ServiceSelection, false, false))
	}

	// Marshal AllocationRetentionPriority (grouped)
	if g.AllocationRetentionPriority != nil {
		if groupedData, err := g.AllocationRetentionPriority.Marshal(); err == nil {
			buf.Write(marshalAVP(1034, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal Ambr (grouped)
	if g.Ambr != nil {
		if groupedData, err := g.Ambr.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1435, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal ExtPdpType (optional)
	if g.ExtPdpType != nil {
		buf.Write(marshalAVPWithVendor(1620, *g.ExtPdpType, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into PDPContext
func (g *PDPContext) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1423: // Context-Identifier
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.ContextIdentifier = val.(models_base.Unsigned32)
			}
		// case 0: // PDP-Type (AVP code not defined)
		case 493: // Service-Selection
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				v := val.(models_base.UTF8String)
				g.ServiceSelection = &v
			}
		case 1034: // Allocation-Retention-Priority
			grouped := &AllocationRetentionPriority{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.AllocationRetentionPriority = grouped
			}
		case 1435: // AMBR
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &AMBR{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				g.Ambr = grouped
			}
		case 1620: // Ext-PDP-Type
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.ExtPdpType = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// IMSIGroupId represents the IMSI-Group-Id grouped AVP (AVP Code 1675)
type IMSIGroupId struct {
	GroupServiceId models_base.Unsigned32   // Required
	GroupPlmnId    models_base.OctetString  // Required
	LocalGroupId   *models_base.OctetString // Optional
}

// Marshal serializes IMSIGroupId to bytes
func (g *IMSIGroupId) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal GroupServiceId (required)
	buf.Write(marshalAVPWithVendor(1676, g.GroupServiceId, true, false, 10415))

	// Marshal GroupPlmnId (required)
	buf.Write(marshalAVPWithVendor(1677, g.GroupPlmnId, true, false, 10415))

	// Marshal LocalGroupId (optional)
	if g.LocalGroupId != nil {
		buf.Write(marshalAVPWithVendor(1678, *g.LocalGroupId, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into IMSIGroupId
func (g *IMSIGroupId) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1676: // Group-Service-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				g.GroupServiceId = val.(models_base.Unsigned32)
			}
		case 1677: // Group-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.GroupPlmnId = val.(models_base.OctetString)
			}
		case 1678: // Local-Group-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.LocalGroupId = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AdjacentPLMNs represents the Adjacent-PLMNs grouped AVP (AVP Code 1672)
type AdjacentPLMNs struct {
	VisitedPlmnId []models_base.OctetString // Optional
}

// Marshal serializes AdjacentPLMNs to bytes
func (g *AdjacentPLMNs) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VisitedPlmnId (repeated)
	for _, v := range g.VisitedPlmnId {
		buf.Write(marshalAVPWithVendor(1407, v, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into AdjacentPLMNs
func (g *AdjacentPLMNs) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1407: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.VisitedPlmnId = append(g.VisitedPlmnId, val.(models_base.OctetString))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// UTRANVector represents the UTRAN-Vector grouped AVP (AVP Code 1415)
type UTRANVector struct {
	ItemNumber         *models_base.Unsigned32 // Optional
	Rand               models_base.OctetString // Required
	Xres               models_base.OctetString // Required
	Autn               models_base.OctetString // Required
	ConfidentialityKey models_base.OctetString // Required
	IntegrityKey       models_base.OctetString // Required
}

// Marshal serializes UTRANVector to bytes
func (g *UTRANVector) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal ItemNumber (optional)
	if g.ItemNumber != nil {
		buf.Write(marshalAVPWithVendor(1419, *g.ItemNumber, true, false, 10415))
	}

	// Marshal Rand (required)
	buf.Write(marshalAVPWithVendor(1447, g.Rand, true, false, 10415))

	// Marshal Xres (required)
	buf.Write(marshalAVPWithVendor(1448, g.Xres, true, false, 10415))

	// Marshal Autn (required)
	buf.Write(marshalAVPWithVendor(1449, g.Autn, true, false, 10415))

	// Marshal ConfidentialityKey (required)
	buf.Write(marshalAVPWithVendor(1455, g.ConfidentialityKey, true, false, 10415))

	// Marshal IntegrityKey (required)
	buf.Write(marshalAVPWithVendor(28, g.IntegrityKey, true, false, 10415))

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into UTRANVector
func (g *UTRANVector) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1419: // Item-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				g.ItemNumber = &v
			}
		case 1447: // RAND
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Rand = val.(models_base.OctetString)
			}
		case 1448: // XRES
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Xres = val.(models_base.OctetString)
			}
		case 1449: // AUTN
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.Autn = val.(models_base.OctetString)
			}
		case 1455: // Confidentiality-Key
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.ConfidentialityKey = val.(models_base.OctetString)
			}
		case 28: // Integrity-Key
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.IntegrityKey = val.(models_base.OctetString)
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// TraceData represents the Trace-Data grouped AVP (AVP Code 1458)
type TraceData struct {
	TraceReference        models_base.OctetString  // Required
	TraceDepth            models_base.Enumerated   // Required
	TraceNeTypeList       *models_base.OctetString // Optional
	TraceInterfaceList    *models_base.OctetString // Optional
	TraceEventList        *models_base.OctetString // Optional
	OmcId                 *models_base.OctetString // Optional
	TraceCollectionEntity *models_base.OctetString // Optional
}

// Marshal serializes TraceData to bytes
func (g *TraceData) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal TraceReference (required)
	buf.Write(marshalAVPWithVendor(1459, g.TraceReference, true, false, 10415))

	// Marshal TraceDepth (required)
	buf.Write(marshalAVPWithVendor(1462, g.TraceDepth, true, false, 10415))

	// Marshal TraceNeTypeList (optional)
	if g.TraceNeTypeList != nil {
		buf.Write(marshalAVPWithVendor(1463, *g.TraceNeTypeList, true, false, 10415))
	}

	// Marshal TraceInterfaceList (optional)
	if g.TraceInterfaceList != nil {
		buf.Write(marshalAVPWithVendor(1464, *g.TraceInterfaceList, true, false, 10415))
	}

	// Marshal TraceEventList (optional)
	if g.TraceEventList != nil {
		buf.Write(marshalAVPWithVendor(1465, *g.TraceEventList, true, false, 10415))
	}

	// Marshal OmcId (optional)
	if g.OmcId != nil {
		buf.Write(marshalAVPWithVendor(1466, *g.OmcId, true, false, 10415))
	}

	// Marshal TraceCollectionEntity (optional)
	if g.TraceCollectionEntity != nil {
		buf.Write(marshalAVPWithVendor(1452, *g.TraceCollectionEntity, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into TraceData
func (g *TraceData) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1459: // Trace-Reference
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.TraceReference = val.(models_base.OctetString)
			}
		case 1462: // Trace-Depth
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				g.TraceDepth = val.(models_base.Enumerated)
			}
		case 1463: // Trace-NE-Type-List
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.TraceNeTypeList = &v
			}
		case 1464: // Trace-Interface-List
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.TraceInterfaceList = &v
			}
		case 1465: // Trace-Event-List
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.TraceEventList = &v
			}
		case 1466: // OMC-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.OmcId = &v
			}
		case 1452: // Trace-Collection-Entity
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				g.TraceCollectionEntity = &v
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// EquivalentPLMNList represents the Equivalent-PLMN-List grouped AVP (AVP Code 1465)
type EquivalentPLMNList struct {
	VisitedPlmnId []models_base.OctetString // Optional
}

// Marshal serializes EquivalentPLMNList to bytes
func (g *EquivalentPLMNList) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// Marshal VisitedPlmnId (repeated)
	for _, v := range g.VisitedPlmnId {
		buf.Write(marshalAVPWithVendor(1407, v, true, false, 10415))
	}

	return buf.Bytes(), nil
}

// Unmarshal deserializes bytes into EquivalentPLMNList
func (g *EquivalentPLMNList) Unmarshal(data []byte) error {
	// Parse AVPs in the grouped data
	avpData := data
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 1407: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				g.VisitedPlmnId = append(g.VisitedPlmnId, val.(models_base.OctetString))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// AVP Codes
const (
	AVPCodeAUTN                                       uint32 = 1449
	AVPCodeHOMOGENEOUSSUPPORTOFIMSVOICEOVERPSSESSIONS uint32 = 1493
	AVPCodeGMLCADDRESS                                uint32 = 1474
	AVPCodeIDAFLAGS                                   uint32 = 1441
	AVPCodeMPSPRIORITY                                uint32 = 1616
	AVPCodeLOCALTIMEZONE                              uint32 = 1649
	AVPCodeSUPPORTEDSERVICES                          uint32 = 3143
	AVPCodeCOMPLETEDATALISTINCLUDEDINDICATOR          uint32 = 1468
	AVPCodeAUTHGRACEPERIOD                            uint32 = 276
	AVPCodeORIGINHOST                                 uint32 = 264
	AVPCodeREDIRECTHOSTUSAGE                          uint32 = 261
	AVPCodeTERMINALINFORMATION                        uint32 = 1401
	AVPCodeCONTEXTIDENTIFIER                          uint32 = 1423
	AVPCodeMDTUSERCONSENT                             uint32 = 1636
	AVPCodeMEASUREMENTPERIODUMTS                      uint32 = 1656
	AVPCodePROXYINFO                                  uint32 = 284
	AVPCodeTERMINATIONCAUSE                           uint32 = 295
	AVPCodeSESSIONBINDING                             uint32 = 270
	AVPCode3GPPCHARGINGCHARACTERISTICS                uint32 = 13
	AVPCodeSMSREGISTERREQUEST                         uint32 = 1648
	AVPCodeAMSISDN                                    uint32 = 1643
	AVPCodeSRES                                       uint32 = 1454
	AVPCodeACTIVEAPN                                  uint32 = 1612
	AVPCodeAUTHORIZATIONLIFETIME                      uint32 = 291
	AVPCodeREDIRECTHOST                               uint32 = 292
	AVPCodeEXPERIMENTALRESULTCODE                     uint32 = 298
	AVPCodeRATFREQUENCYSELECTIONPRIORITYID            uint32 = 1440
	AVPCodeGPRSSUBSCRIPTIONDATA                       uint32 = 1469
	AVPCodeMIP6HOMELINKPREFIX                         uint32 = 125
	AVPCodeDESTINATIONHOST                            uint32 = 293
	AVPCodeIMSVOICEOVERPSSESSIONSSUPPORTED            uint32 = 1492
	AVPCodeVPLMNLIPAALLOWED                           uint32 = 1617
	AVPCodeDSRFLAGS                                   uint32 = 1421
	AVPCodeTRACEEVENTLIST                             uint32 = 1465
	AVPCodeREDIRECTMAXCACHETIME                       uint32 = 262
	AVPCodeHOSTIPADDRESS                              uint32 = 257
	AVPCodeSESSIONSERVERFAILOVER                      uint32 = 271
	AVPCodeMSISDN                                     uint32 = 701
	AVPCodeEXTENDEDMAXREQUESTEDBWDL                   uint32 = 1467
	AVPCodeVISITEDNETWORKIDENTIFIER                   uint32 = 600
	AVPCodeREQUESTEDUTRANGERANAUTHENTICATIONINFO      uint32 = 1409
	AVPCodePREEMPTIONCAPABILITY                       uint32 = 1047
	AVPCodeMOLR                                       uint32 = 1485
	AVPCodePREFERREDDATAMODE                          uint32 = 1686
	AVPCodeSCEFID                                     uint32 = 1608
	AVPCodeUEUSAGETYPE                                uint32 = 1680
	AVPCodePDPCONTEXT                                 uint32 = 1469
	AVPCodeACCOUNTINGREALTIMEREQUIRED                 uint32 = 483
	AVPCodeSESSIONTIMEOUT                             uint32 = 27
	AVPCodeAPNOIREPLACEMENT                           uint32 = 1427
	AVPCodeIMSIGROUPID                                uint32 = 1675
	AVPCodeADJACENTPLMNS                              uint32 = 1672
	AVPCodeVISITEDPLMNID                              uint32 = 1407
	AVPCodeTSCODE                                     uint32 = 1489
	AVPCodeSOFTWAREVERSION                            uint32 = 1403
	AVPCodeSIPTOLOCALNETWORKPERMISSION                uint32 = 1666
	AVPCodeUTRANVECTOR                                uint32 = 1415
	AVPCodeTIMEZONE                                   uint32 = 1643
	AVPCodeTRACEREFERENCE                             uint32 = 1459
	AVPCodeTRACEDEPTH                                 uint32 = 1462
	AVPCodePURFLAGS                                   uint32 = 1635
	AVPCodeMAXREQUESTEDBANDWIDTHUL                    uint32 = 516
	AVPCodeROUTERECORD                                uint32 = 282
	AVPCodeQOSSUBSCRIBED                              uint32 = 1404
	AVPCodeQOSCLASSIDENTIFIER                         uint32 = 1028
	AVPCodeTRACEDATA                                  uint32 = 1458
	AVPCodeEQUIVALENTPLMNLIST                         uint32 = 1465
	AVPCodeUSERNAME                                   uint32 = 1
	AVPCodeXRES                                       uint32 = 1448
	AVPCodeEXTENDEDMAXREQUESTEDBWUL                   uint32 = 1466
	AVPCodeUESRVCCCAPABILITY                          uint32 = 1615
	AVPCodeRESYNCHRONIZATIONINFO                      uint32 = 1411
	AVPCodeREGIONALSUBSCRIPTIONZONECODE               uint32 = 1446
	AVPCodeAUTHAPPLICATIONID                          uint32 = 258
	AVPCodeACCTAPPLICATIONID                          uint32 = 259
	AVPCodeACCOUNTINGSUBSESSIONID                     uint32 = 287
	AVPCodePRODUCTNAME                                uint32 = 269
	AVPCodeAUTHREQUESTTYPE                            uint32 = 274
	AVPCodeRAND                                       uint32 = 1447
	AVPCodeSIPTOPERMISSION                            uint32 = 1622
	AVPCodeERRORREPORTINGHOST                         uint32 = 294
	AVPCodeTRACECOLLECTIONENTITY                      uint32 = 1452
	AVPCodeALLOCATIONRETENTIONPRIORITY                uint32 = 1034
	AVPCodeEMERGENCYINFO                              uint32 = 1687
	AVPCodeSUBSCRIBEDPERIODICRAUTAUTIMER              uint32 = 1619
	AVPCodeSERVICESELECTION                           uint32 = 493
	AVPCodeMEASUREMENTPERIODLTE                       uint32 = 1655
	AVPCodeLASTUEACTIVITYTIME                         uint32 = 1494
	AVPCodeVENDORSPECIFICAPPLICATIONID                uint32 = 260
	AVPCodeORIGINSTATEID                              uint32 = 278
	AVPCodeALLAPNCONFIGURATIONSINCLUDEDINDICATOR      uint32 = 1428
	AVPCodeSSCODE                                     uint32 = 1476
	AVPCodeCANCELLATIONTYPE                           uint32 = 1420
	AVPCodeDAYLIGHTSAVINGTIME                         uint32 = 1654
	AVPCodeGROUPSERVICEID                             uint32 = 1676
	AVPCodeOMCID                                      uint32 = 1466
	AVPCodeSESSIONID                                  uint32 = 263
	AVPCodePREEMPTIONVULNERABILITY                    uint32 = 1048
	AVPCodeMTLR                                       uint32 = 1484
	AVPCodeSUBSCRIPTIONDATA                           uint32 = 1400
	AVPCodeSUBSCRIBERSTATUS                           uint32 = 1424
	AVPCodeLIPAPERMISSION                             uint32 = 1618
	AVPCodeVENDORID                                   uint32 = 266
	AVPCodeMIPHOMEAGENTHOST                           uint32 = 348
	AVPCodeRESULTCODE                                 uint32 = 268
	AVPCodeEXPERIMENTALRESULT                         uint32 = 297
	AVPCodeSUBSCRIPTIONDATAFLAGS                      uint32 = 1637
	AVPCodeOPERATORDETERMINEDBARRING                  uint32 = 1425
	AVPCodeNUMBEROFREQUESTEDVECTORS                   uint32 = 1410
	AVPCodePROXYHOST                                  uint32 = 280
	AVPCodeE2ESEQUENCE                                uint32 = 300
	AVPCodeEVENTTIMESTAMP                             uint32 = 55
	AVPCodeMIP6AGENTINFO                              uint32 = 486
	AVPCodeDISCONNECTCAUSE                            uint32 = 273
	AVPCodeNETWORKACCESSMODE                          uint32 = 1417
	AVPCodeUVAFLAGS                                   uint32 = 1641
	AVPCodeDLBUFFERINGSUGGESTEDPACKETCOUNT            uint32 = 1674
	AVPCodeUVRFLAGS                                   uint32 = 1640
	AVPCodeLCSPRIVACYEXCEPTION                        uint32 = 1475
	AVPCodeSSSTATUS                                   uint32 = 1477
	AVPCodeLCSINFO                                    uint32 = 1473
	AVPCodeAIRFLAGS                                   uint32 = 1679
	AVPCodeAPNCONFIGURATIONPROFILE                    uint32 = 1429
	AVPCodeCLASS                                      uint32 = 25
	AVPCodeACCTINTERIMINTERVAL                        uint32 = 85
	AVPCodeEDRXCYCLELENGTH                            uint32 = 1691
	AVPCodeEDRXCYCLELENGTHVALUE                       uint32 = 1692
	AVPCodeERRORDIAGNOSTIC                            uint32 = 1614
	AVPCodeKASME                                      uint32 = 1450
	AVPCodeAUTHENTICATIONINFO                         uint32 = 1413
	AVPCodeAUTHSESSIONSTATE                           uint32 = 277
	AVPCodeSGSMMEIDENTITY                             uint32 = 1665
	AVPCodeTRACEINTERFACELIST                         uint32 = 1464
	AVPCodeEUTRANVECTOR                               uint32 = 1414
	AVPCodeNORFLAGS                                   uint32 = 1443
	AVPCodeAPNCONFIGURATION                           uint32 = 1430
	AVPCodePDNTYPE                                    uint32 = 1456
	AVPCodeMMENUMBERFORMTSMS                          uint32 = 1645
	AVPCodeDESTINATIONREALM                           uint32 = 283
	AVPCode3GPP2MEID                                  uint32 = 1471
	AVPCodePROSESUBSCRIPTIONDATA                      uint32 = 1490
	AVPCodeADJACENTACCESSRESTRICTIONDATA              uint32 = 1673
	AVPCodeAMBR                                       uint32 = 1435
	AVPCodeIDRFLAGS                                   uint32 = 1488
	AVPCodePUAFLAGS                                   uint32 = 1442
	AVPCodePROXYSTATE                                 uint32 = 33
	AVPCodeEPSSUBSCRIBEDQOSPROFILE                    uint32 = 1431
	AVPCodeITEMNUMBER                                 uint32 = 1419
	AVPCodeMAXREQUESTEDBANDWIDTHDL                    uint32 = 515
	AVPCodeNONIPDATADELIVERYMECHANISM                 uint32 = 1682
	AVPCodeRESETID                                    uint32 = 1651
	AVPCodeV2XSUBSCRIPTIONDATA                        uint32 = 1688
	AVPCodeINBANDSECURITYID                           uint32 = 299
	AVPCodeCSGSUBSCRIPTIONDATA                        uint32 = 1436
	AVPCodeCLRFLAGS                                   uint32 = 1638
	AVPCodeGROUPPLMNID                                uint32 = 1677
	AVPCodeSUPPORTEDVENDORID                          uint32 = 265
	AVPCodeFIRMWAREREVISION                           uint32 = 267
	AVPCodeACCTSESSIONID                              uint32 = 44
	AVPCodeGERANVECTOR                                uint32 = 1416
	AVPCodeNONIPPDNTYPEINDICATOR                      uint32 = 1681
	AVPCodeTRACENETYPELIST                            uint32 = 1463
	AVPCodeFAILEDAVP                                  uint32 = 279
	AVPCodeVPLMNDYNAMICADDRESSALLOWED                 uint32 = 1432
	AVPCodeSGSNNUMBER                                 uint32 = 1488
	AVPCodeRATTYPE                                    uint32 = 1032
	AVPCodeROAMINGRESTRICTEDDUETOUNSUPPORTEDFEATURE   uint32 = 1457
	AVPCodeULRFLAGS                                   uint32 = 1405
	AVPCodeSUBSCRIBEDVSRVCC                           uint32 = 1638
	AVPCodeIMEI                                       uint32 = 1402
	AVPCodeUSERID                                     uint32 = 1444
	AVPCodeEXPIRATIONDATE                             uint32 = 1439
	AVPCodePRIORITYLEVEL                              uint32 = 1046
	AVPCodeCOUPLEDNODEDIAMETERID                      uint32 = 1666
	AVPCodeCSGID                                      uint32 = 1437
	AVPCodeHPLMNODB                                   uint32 = 1418
	AVPCodeORIGINREALM                                uint32 = 296
	AVPCodeEQUIPMENTSTATUS                            uint32 = 1445
	AVPCodeCONFIDENTIALITYKEY                         uint32 = 1455
	AVPCodeULAFLAGS                                   uint32 = 1406
	AVPCodeCOLLECTIONPERIODRRMUMTS                    uint32 = 1658
	AVPCodeRELAYNODEINDICATOR                         uint32 = 1635
	AVPCodeMIPHOMEAGENTADDRESS                        uint32 = 334
	AVPCodeREAUTHREQUESTTYPE                          uint32 = 285
	AVPCodeACCTMULTISESSIONID                         uint32 = 50
	AVPCodeTELESERVICELIST                            uint32 = 1486
	AVPCodeVPLMNCSGSUBSCRIPTIONDATA                   uint32 = 1642
	AVPCodeCOLLECTIONPERIODRRMLTE                     uint32 = 1657
	AVPCodeEXTPDPTYPE                                 uint32 = 1620
	AVPCodeWLANOFFLOADABILITY                         uint32 = 1667
	AVPCodeIMMEDIATERESPONSEPREFERRED                 uint32 = 1412
	AVPCodeACCESSRESTRICTIONDATA                      uint32 = 1426
	AVPCodeLOCALGROUPID                               uint32 = 1678
	AVPCodeUEPC5AMBR                                  uint32 = 1693
	AVPCodeRESTORATIONPRIORITY                        uint32 = 1663
	AVPCodeEPSLOCATIONINFORMATION                     uint32 = 1496
	AVPCodeSTNSR                                      uint32 = 1433
	AVPCodeV2XPERMISSION                              uint32 = 1689
	AVPCodeMULTIROUNDTIMEOUT                          uint32 = 272
	AVPCodeACCOUNTINGRECORDTYPE                       uint32 = 480
	AVPCodeDSAFLAGS                                   uint32 = 1422
	AVPCodeREQUESTEDEUTRANAUTHENTICATIONINFO          uint32 = 1408
	AVPCodeEPSUSERSTATE                               uint32 = 1495
	AVPCodeINTEGRITYKEY                               uint32 = 28
	AVPCodeKC                                         uint32 = 1453
	AVPCodeSCEFREALM                                  uint32 = 1684
	AVPCodeERRORMESSAGE                               uint32 = 281
	AVPCodeACCOUNTINGRECORDNUMBER                     uint32 = 485
	AVPCodeCALLBARRINGINFO                            uint32 = 1461
	AVPCodePDNCONNECTIONCONTINUITY                    uint32 = 1690
	AVPCodeMONITORINGEVENTCONFIGURATION               uint32 = 1491
	AVPCodeSPECIFICAPNINFO                            uint32 = 1472
	AVPCodePDNGWALLOCATIONTYPE                        uint32 = 1438
)

// Command Codes
const (
	CommandCodeUPDATELOCATIONREQUEST uint32 = 316
	CommandCodeUPDATELOCATIONANSWER  uint32 = 316
)

// UpdateLocationRequest represents the Update-Location-Request (ULR) Diameter command
// Command Code: 316, Application ID: 16777251
type UpdateLocationRequest struct {
	Header DiameterHeader

	SessionId                             models_base.UTF8String                 // Required
	AuthSessionState                      models_base.Enumerated                 // Required
	OriginHost                            models_base.DiameterIdentity           // Required
	OriginRealm                           models_base.DiameterIdentity           // Required
	DestinationRealm                      models_base.DiameterIdentity           // Required
	UserName                              models_base.UTF8String                 // Required
	Drmp                                  *models_base.OctetString               // Optional - WARNING: AVP code not defined, DO NOT USE
	VendorSpecificApplicationId           *VendorSpecificApplicationId           // Optional
	DestinationHost                       *models_base.DiameterIdentity          // Optional
	SupportedFeatures                     *models_base.OctetString               // Optional - WARNING: AVP code not defined, DO NOT USE
	TerminalInformation                   *TerminalInformation                   // Optional
	RatType                               *models_base.Enumerated                // Optional
	UlrFlags                              *models_base.Unsigned32                // Optional
	VisitedPlmnId                         *models_base.OctetString               // Optional
	SgsnNumber                            *models_base.OctetString               // Optional
	RequestedEutranAuthenticationInfo     *RequestedEUTRANAuthenticationInfo     // Optional
	RequestedUtranGeranAuthenticationInfo *RequestedUTRANGERANAuthenticationInfo // Optional
	Avp                                   []models_base.OctetString              // Optional - WARNING: AVP code not defined, DO NOT USE
	ProxyInfo                             []*ProxyInfo                           // Optional
	RouteRecord                           []models_base.DiameterIdentity         // Optional
}

// NewUpdateLocationRequest creates a new ULR message
func NewUpdateLocationRequest() *UpdateLocationRequest {
	return &UpdateLocationRequest{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   316,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   true,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in UpdateLocationRequest
func (m *UpdateLocationRequest) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}
	if m.DestinationRealm == "" {
		return fmt.Errorf("required field Destination-Realm is empty")
	}
	if m.UserName == "" {
		return fmt.Errorf("required field User-Name is empty")
	}

	return nil
}

// Marshal serializes the UpdateLocationRequest to bytes using a buffer for optimal performance
func (m *UpdateLocationRequest) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal DestinationRealm (required)
	buf.Write(marshalAVP(283, m.DestinationRealm, true, false))

	// Marshal UserName (required)
	buf.Write(marshalAVP(1, m.UserName, true, true))

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(0, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(260, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal DestinationHost (optional)
	if m.DestinationHost != nil {
		buf.Write(marshalAVP(293, *m.DestinationHost, true, false))
	}

	// Marshal SupportedFeatures (optional)
	if m.SupportedFeatures != nil {
		buf.Write(marshalAVP(0, *m.SupportedFeatures, false, false))
	}

	// Marshal TerminalInformation (grouped)
	if m.TerminalInformation != nil {
		if groupedData, err := m.TerminalInformation.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1401, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal RatType (optional)
	if m.RatType != nil {
		buf.Write(marshalAVP(1032, *m.RatType, true, false))
	}

	// Marshal UlrFlags (optional)
	if m.UlrFlags != nil {
		buf.Write(marshalAVPWithVendor(1405, *m.UlrFlags, true, false, 10415))
	}

	// Marshal VisitedPlmnId (optional)
	if m.VisitedPlmnId != nil {
		buf.Write(marshalAVPWithVendor(1407, *m.VisitedPlmnId, true, false, 10415))
	}

	// Marshal SgsnNumber (optional)
	if m.SgsnNumber != nil {
		buf.Write(marshalAVPWithVendor(1488, *m.SgsnNumber, true, false, 10415))
	}

	// Marshal RequestedEutranAuthenticationInfo (grouped)
	if m.RequestedEutranAuthenticationInfo != nil {
		if groupedData, err := m.RequestedEutranAuthenticationInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1408, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal RequestedUtranGeranAuthenticationInfo (grouped)
	if m.RequestedUtranGeranAuthenticationInfo != nil {
		if groupedData, err := m.RequestedUtranGeranAuthenticationInfo.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1409, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into UpdateLocationRequest
func (m *UpdateLocationRequest) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 283: // Destination-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.DestinationRealm = val.(models_base.DiameterIdentity)
			}
		case 1: // User-Name
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.UserName = val.(models_base.UTF8String)
			}
		// case 0: // DRMP (AVP code not defined)
		case 260: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case 293: // Destination-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				v := val.(models_base.DiameterIdentity)
				m.DestinationHost = &v
			}
		// case 0: // Supported-Features (AVP code not defined)
		case 1401: // Terminal-Information
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &TerminalInformation{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.TerminalInformation = grouped
			}
		case 1032: // RAT-Type
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				v := val.(models_base.Enumerated)
				m.RatType = &v
			}
		case 1405: // ULR-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.UlrFlags = &v
			}
		case 1407: // Visited-PLMN-Id
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.VisitedPlmnId = &v
			}
		case 1488: // SGSN-Number
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeOctetString(avpValue)
			if err == nil {
				v := val.(models_base.OctetString)
				m.SgsnNumber = &v
			}
		case 1408: // Requested-EUTRAN-Authentication-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &RequestedEUTRANAuthenticationInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.RequestedEutranAuthenticationInfo = grouped
			}
		case 1409: // Requested-UTRAN-GERAN-Authentication-Info
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &RequestedUTRANGERANAuthenticationInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.RequestedUtranGeranAuthenticationInfo = grouped
			}
		// case 0: // AVP (AVP code not defined)
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the UpdateLocationRequest message
func (m *UpdateLocationRequest) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of UpdateLocationRequest
func (m *UpdateLocationRequest) String() string {
	return fmt.Sprintf("UpdateLocationRequest{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, DestinationRealm:%v, UserName:%v, Drmp:%v, VendorSpecificApplicationId:%v, DestinationHost:%v, SupportedFeatures:%v, TerminalInformation:%v, RatType:%v, UlrFlags:%v, VisitedPlmnId:%v, SgsnNumber:%v, RequestedEutranAuthenticationInfo:%v, RequestedUtranGeranAuthenticationInfo:%v, Avp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.DestinationRealm, m.UserName, m.Drmp, m.VendorSpecificApplicationId, m.DestinationHost, m.SupportedFeatures, m.TerminalInformation, m.RatType, m.UlrFlags, m.VisitedPlmnId, m.SgsnNumber, m.RequestedEutranAuthenticationInfo, m.RequestedUtranGeranAuthenticationInfo, m.Avp, m.ProxyInfo, m.RouteRecord)
}

// UpdateLocationAnswer represents the Update-Location-Answer (ULA) Diameter command
// Command Code: 316, Application ID: 16777251
type UpdateLocationAnswer struct {
	Header DiameterHeader

	SessionId                   models_base.UTF8String         // Required
	AuthSessionState            models_base.Enumerated         // Required
	OriginHost                  models_base.DiameterIdentity   // Required
	OriginRealm                 models_base.DiameterIdentity   // Required
	ResultCode                  *models_base.Unsigned32        // Optional
	ExperimentalResult          *ExperimentalResult            // Optional
	Drmp                        *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	VendorSpecificApplicationId *VendorSpecificApplicationId   // Optional
	UlaFlags                    *models_base.Unsigned32        // Optional
	SubscriptionData            *SubscriptionData              // Optional
	SupportedFeatures           *models_base.OctetString       // Optional - WARNING: AVP code not defined, DO NOT USE
	Avp                         []models_base.OctetString      // Optional - WARNING: AVP code not defined, DO NOT USE
	FailedAvp                   *FailedAVP                     // Optional
	ProxyInfo                   []*ProxyInfo                   // Optional
	RouteRecord                 []models_base.DiameterIdentity // Optional
}

// NewUpdateLocationAnswer creates a new ULA message
func NewUpdateLocationAnswer() *UpdateLocationAnswer {
	return &UpdateLocationAnswer{
		Header: DiameterHeader{
			Version:       1,
			CommandCode:   316,
			ApplicationID: 16777251,
			Flags: CommandFlags{
				Request:   false,
				Proxiable: true,
			},
		},
	}
}

// Validate checks if all required fields are set in UpdateLocationAnswer
func (m *UpdateLocationAnswer) Validate() error {
	// Validate required fields
	if m.SessionId == "" {
		return fmt.Errorf("required field Session-Id is empty")
	}
	if m.OriginHost == "" {
		return fmt.Errorf("required field Origin-Host is empty")
	}
	if m.OriginRealm == "" {
		return fmt.Errorf("required field Origin-Realm is empty")
	}

	return nil
}

// Marshal serializes the UpdateLocationAnswer to bytes using a buffer for optimal performance
func (m *UpdateLocationAnswer) Marshal() ([]byte, error) {
	// Validate required fields before marshaling
	if err := m.Validate(); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Use a buffer to avoid multiple allocations
	var buf bytes.Buffer
	buf.Grow(256) // Pre-allocate reasonable size

	// Reserve space for header (we'll write it at the end)
	headerPlaceholder := make([]byte, 20)
	buf.Write(headerPlaceholder)

	// Marshal AVPs directly to buffer
	// Marshal SessionId (required)
	buf.Write(marshalAVP(263, m.SessionId, true, false))

	// Marshal AuthSessionState (required)
	buf.Write(marshalAVP(277, m.AuthSessionState, true, false))

	// Marshal OriginHost (required)
	buf.Write(marshalAVP(264, m.OriginHost, true, false))

	// Marshal OriginRealm (required)
	buf.Write(marshalAVP(296, m.OriginRealm, true, false))

	// Marshal ResultCode (optional)
	if m.ResultCode != nil {
		buf.Write(marshalAVP(268, *m.ResultCode, true, false))
	}

	// Marshal ExperimentalResult (grouped)
	if m.ExperimentalResult != nil {
		if groupedData, err := m.ExperimentalResult.Marshal(); err == nil {
			buf.Write(marshalAVP(297, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal Drmp (optional)
	if m.Drmp != nil {
		buf.Write(marshalAVP(0, *m.Drmp, false, false))
	}

	// Marshal VendorSpecificApplicationId (grouped)
	if m.VendorSpecificApplicationId != nil {
		if groupedData, err := m.VendorSpecificApplicationId.Marshal(); err == nil {
			buf.Write(marshalAVP(260, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal UlaFlags (optional)
	if m.UlaFlags != nil {
		buf.Write(marshalAVPWithVendor(1406, *m.UlaFlags, true, false, 10415))
	}

	// Marshal SubscriptionData (grouped)
	if m.SubscriptionData != nil {
		if groupedData, err := m.SubscriptionData.Marshal(); err == nil {
			buf.Write(marshalAVPWithVendor(1400, models_base.Grouped(groupedData), true, false, 10415))
		}
	}

	// Marshal SupportedFeatures (optional)
	if m.SupportedFeatures != nil {
		buf.Write(marshalAVP(0, *m.SupportedFeatures, false, false))
	}

	// Marshal Avp (repeated)
	for _, v := range m.Avp {
		buf.Write(marshalAVP(0, v, false, false))
	}

	// Marshal FailedAvp (grouped)
	if m.FailedAvp != nil {
		if groupedData, err := m.FailedAvp.Marshal(); err == nil {
			buf.Write(marshalAVP(279, models_base.Grouped(groupedData), true, false))
		}
	}

	// Marshal ProxyInfo (repeated, grouped)
	for _, v := range m.ProxyInfo {
		if v != nil {
			if groupedData, err := v.Marshal(); err == nil {
				buf.Write(marshalAVP(284, models_base.Grouped(groupedData), true, false))
			}
		}
	}

	// Marshal RouteRecord (repeated)
	for _, v := range m.RouteRecord {
		buf.Write(marshalAVP(282, v, true, false))
	}

	// Get the final message
	result := buf.Bytes()

	// Update message length and write header
	m.Header.Length = uint32(len(result))
	header := marshalHeader(&m.Header)
	copy(result[:20], header)

	return result, nil
}

// Unmarshal deserializes bytes into UpdateLocationAnswer
func (m *UpdateLocationAnswer) Unmarshal(data []byte) error {
	if len(data) < 20 {
		return fmt.Errorf("data too short for Diameter header")
	}

	// Unmarshal header
	header, err := unmarshalHeader(data[:20])
	if err != nil {
		return err
	}
	m.Header = *header

	// Unmarshal AVPs
	avpData := data[20:]
	for len(avpData) > 0 {
		if len(avpData) < 8 {
			break // Not enough data for AVP header
		}

		// Parse AVP header
		avpCode := binary.BigEndian.Uint32(avpData[0:4])
		avpFlags := avpData[4]
		avpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})

		if int(avpLength) > len(avpData) {
			return fmt.Errorf("AVP length exceeds remaining data")
		}

		// Extract AVP data
		headerSize := 8
		var vendorID uint32
		if avpFlags&0x80 != 0 { // V-bit set
			if len(avpData) < 12 {
				return fmt.Errorf("AVP data too short for vendor ID")
			}
			vendorID = binary.BigEndian.Uint32(avpData[8:12])
			headerSize = 12
		}
		avpDataLen := int(avpLength) - headerSize
		if avpDataLen < 0 {
			return fmt.Errorf("invalid AVP data length")
		}
		avpValue := avpData[headerSize : headerSize+avpDataLen]

		// Parse AVP based on code and vendor ID
		switch avpCode {
		case 263: // Session-Id
			val, err := models_base.DecodeUTF8String(avpValue)
			if err == nil {
				m.SessionId = val.(models_base.UTF8String)
			}
		case 277: // Auth-Session-State
			val, err := models_base.DecodeEnumerated(avpValue)
			if err == nil {
				m.AuthSessionState = val.(models_base.Enumerated)
			}
		case 264: // Origin-Host
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginHost = val.(models_base.DiameterIdentity)
			}
		case 296: // Origin-Realm
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.OriginRealm = val.(models_base.DiameterIdentity)
			}
		case 268: // Result-Code
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.ResultCode = &v
			}
		case 297: // Experimental-Result
			grouped := &ExperimentalResult{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ExperimentalResult = grouped
			}
		// case 0: // DRMP (AVP code not defined)
		case 260: // Vendor-Specific-Application-Id
			grouped := &VendorSpecificApplicationId{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.VendorSpecificApplicationId = grouped
			}
		case 1406: // ULA-Flags
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			val, err := models_base.DecodeUnsigned32(avpValue)
			if err == nil {
				v := val.(models_base.Unsigned32)
				m.UlaFlags = &v
			}
		case 1400: // Subscription-Data
			if vendorID != 10415 {
				break // Vendor ID mismatch
			}
			grouped := &SubscriptionData{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.SubscriptionData = grouped
			}
		// case 0: // Supported-Features (AVP code not defined)
		// case 0: // AVP (AVP code not defined)
		case 279: // Failed-AVP
			grouped := &FailedAVP{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.FailedAvp = grouped
			}
		case 284: // Proxy-Info
			grouped := &ProxyInfo{}
			if err := grouped.Unmarshal(avpValue); err == nil {
				m.ProxyInfo = append(m.ProxyInfo, grouped)
			}
		case 282: // Route-Record
			val, err := models_base.DecodeDiameterIdentity(avpValue)
			if err == nil {
				m.RouteRecord = append(m.RouteRecord, val.(models_base.DiameterIdentity))
			}
		}

		// Move to next AVP (with padding)
		paddedLength := int(avpLength)
		if paddedLength%4 != 0 {
			paddedLength += 4 - (paddedLength % 4)
		}
		if paddedLength > len(avpData) {
			break
		}
		avpData = avpData[paddedLength:]
	}

	return nil
}

// Len returns the total length of the UpdateLocationAnswer message
func (m *UpdateLocationAnswer) Len() int {
	data, _ := m.Marshal()
	return len(data)
}

// String returns a string representation of UpdateLocationAnswer
func (m *UpdateLocationAnswer) String() string {
	return fmt.Sprintf("UpdateLocationAnswer{SessionId:%v, AuthSessionState:%v, OriginHost:%v, OriginRealm:%v, ResultCode:%v, ExperimentalResult:%v, Drmp:%v, VendorSpecificApplicationId:%v, UlaFlags:%v, SubscriptionData:%v, SupportedFeatures:%v, Avp:%v, FailedAvp:%v, ProxyInfo:%v, RouteRecord:%v}", m.SessionId, m.AuthSessionState, m.OriginHost, m.OriginRealm, m.ResultCode, m.ExperimentalResult, m.Drmp, m.VendorSpecificApplicationId, m.UlaFlags, m.SubscriptionData, m.SupportedFeatures, m.Avp, m.FailedAvp, m.ProxyInfo, m.RouteRecord)
}

// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// marshalAVPWithVendor serializes an AVP with optional vendor ID
func marshalAVPWithVendor(code uint32, data models_base.Type, mandatory, protected bool, vendorID uint32) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Determine if we need vendor ID in header
	hasVendor := vendorID != 0

	// Calculate header size
	headerSize := 8
	if hasVendor {
		headerSize = 12 // With vendor ID
	}

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if hasVendor {
		flags |= 0x80 // V-bit
	}
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Vendor ID (if needed)
	if hasVendor {
		binary.BigEndian.PutUint32(buf[8:12], vendorID)
	}

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// Pointer helper functions for grouped AVP field assignments in tests
func ptrUTF8String(s string) *models_base.UTF8String {
	v := models_base.UTF8String(s)
	return &v
}

func ptrOctetString(b []byte) *models_base.OctetString {
	v := models_base.OctetString(b)
	return &v
}

func ptrUnsigned32(u uint32) *models_base.Unsigned32 {
	v := models_base.Unsigned32(u)
	return &v
}

func ptrUnsigned64(u uint64) *models_base.Unsigned64 {
	v := models_base.Unsigned64(u)
	return &v
}

func ptrEnumerated(e uint32) *models_base.Enumerated {
	v := models_base.Enumerated(e)
	return &v
}

func ptrDiameterIdentity(d string) *models_base.DiameterIdentity {
	v := models_base.DiameterIdentity(d)
	return &v
}

func ptrAddress(a models_base.Address) *models_base.Address {
	return &a
}

func ptrTime(t models_base.Time) *models_base.Time {
	return &t
}

func ptrFloat32(f float32) *models_base.Float32 {
	v := models_base.Float32(f)
	return &v
}

func ptrFloat64(f float64) *models_base.Float64 {
	v := models_base.Float64(f)
	return &v
}
