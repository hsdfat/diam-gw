package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
)

// Generator generates Go code from parsed proto definitions
type Generator struct {
	Parser      *ProtoParser
	PackageName string
}

// NewGenerator creates a new code generator
func NewGenerator(parser *ProtoParser, packageName string) *Generator {
	return &Generator{
		Parser:      parser,
		PackageName: packageName,
	}
}

// GenerateToFile generates Go code and writes to a file
func (g *Generator) GenerateToFile(outputFile string) error {
	code, err := g.Generate()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(outputFile, []byte(code), 0644)
	}

	return os.WriteFile(outputFile, formatted, 0644)
}

// GenerateTestFile generates a test file with pcap writing capabilities
func (g *Generator) GenerateTestFile(testFile string) error {
	code, err := g.GenerateTest()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(testFile, []byte(code), 0644)
	}

	return os.WriteFile(testFile, formatted, 0644)
}

// Generate generates Go code from parsed definitions
func (g *Generator) Generate() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"encoding/binary\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/hsdfat8/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")

	// Generate type definitions
	g.generateTypeDefinitions(&buf)

	// Generate AVP constants
	buf.WriteString("// AVP Codes\n")
	buf.WriteString("const (\n")
	for name, avp := range g.Parser.AVPs {
		constName := toConstantCase(name)
		buf.WriteString(fmt.Sprintf("\tAVPCode%s uint32 = %d\n", constName, avp.Code))
	}
	buf.WriteString(")\n\n")

	// Generate command codes
	buf.WriteString("// Command Codes\n")
	buf.WriteString("const (\n")
	for _, cmd := range g.Parser.Commands {
		constName := toConstantCase(cmd.Name)
		buf.WriteString(fmt.Sprintf("\tCommandCode%s uint32 = %d\n", constName, cmd.Code))
	}
	buf.WriteString(")\n\n")

	// Generate command structs
	for _, cmd := range g.Parser.Commands {
		if err := g.generateCommandStruct(&buf, cmd); err != nil {
			return "", err
		}
	}

	// Generate helper functions
	g.generateHelperFunctions(&buf)

	return buf.String(), nil
}

// generateCommandStruct generates a struct for a command
func (g *Generator) generateCommandStruct(buf *bytes.Buffer, cmd *CommandDefinition) error {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))

	// Write struct comment
	buf.WriteString(fmt.Sprintf("// %s represents the %s (%s) Diameter command\n", structName, cmd.Name, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("// Command Code: %d, Application ID: %d\n", cmd.Code, cmd.ApplicationID))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// Write header field
	buf.WriteString("\tHeader DiameterHeader\n\n")

	// Write AVP fields
	for _, field := range cmd.Fields {
		goType := g.getGoType(field)
		comment := ""
		if field.Required {
			comment = " // Required"
		} else {
			comment = " // Optional"
		}
		buf.WriteString(fmt.Sprintf("\t%s %s%s\n", field.FieldName, goType, comment))
	}

	buf.WriteString("}\n\n")

	// Generate constructor
	g.generateConstructor(buf, cmd, structName)

	// Generate Validate method
	g.generateValidate(buf, cmd, structName)

	// Generate Marshal method
	g.generateMarshal(buf, cmd, structName)

	// Generate Unmarshal method
	g.generateUnmarshal(buf, cmd, structName)

	// Generate Len method
	g.generateLen(buf, cmd, structName)

	// Generate String method
	g.generateString(buf, cmd, structName)

	return nil
}

// getGoType returns the Go type for a field
func (g *Generator) getGoType(field *AVPField) string {
	baseType := g.getBaseGoType(field.AVP.TypeName)

	if field.Repeated {
		return "[]" + baseType
	}

	if !field.Required {
		return "*" + baseType
	}

	return baseType
}

// getBaseGoType returns the base Go type for an AVP type
func (g *Generator) getBaseGoType(typeName string) string {
	switch typeName {
	case "Unsigned32":
		return "models_base.Unsigned32"
	case "Unsigned64":
		return "models_base.Unsigned64"
	case "Integer32":
		return "models_base.Integer32"
	case "Integer64":
		return "models_base.Integer64"
	case "Float32":
		return "models_base.Float32"
	case "Float64":
		return "models_base.Float64"
	case "OctetString":
		return "models_base.OctetString"
	case "UTF8String":
		return "models_base.UTF8String"
	case "DiameterIdentity":
		return "models_base.DiameterIdentity"
	case "DiameterURI":
		return "models_base.DiameterURI"
	case "Enumerated":
		return "models_base.Enumerated"
	case "Address":
		return "models_base.Address"
	case "Time":
		return "models_base.Time"
	case "IPFilterRule":
		return "models_base.IPFilterRule"
	case "QoSFilterRule":
		return "models_base.QoSFilterRule"
	case "Grouped":
		return "models_base.Grouped"
	default:
		return "models_base.OctetString" // fallback
	}
}

// generateConstructor generates a constructor function
func (g *Generator) generateConstructor(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// New%s creates a new %s message\n", structName, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("func New%s() *%s {\n", structName, structName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{\n", structName))
	buf.WriteString("\t\tHeader: DiameterHeader{\n")
	buf.WriteString("\t\t\tVersion:       1,\n")
	buf.WriteString(fmt.Sprintf("\t\t\tCommandCode:   %d,\n", cmd.Code))
	buf.WriteString(fmt.Sprintf("\t\t\tApplicationID: %d,\n", cmd.ApplicationID))
	buf.WriteString("\t\t\tFlags: CommandFlags{\n")
	buf.WriteString(fmt.Sprintf("\t\t\t\tRequest:   %v,\n", cmd.Request))
	buf.WriteString(fmt.Sprintf("\t\t\t\tProxiable: %v,\n", cmd.Proxiable))
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")
}

// generateValidate generates the Validate method
func (g *Generator) generateValidate(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Validate checks if all required fields are set in %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Validate() error {\n", structName))

	hasRequiredFields := false
	for _, field := range cmd.Fields {
		if field.Required && !field.Repeated {
			hasRequiredFields = true
			break
		}
	}

	if !hasRequiredFields {
		buf.WriteString("\t// No required fields to validate\n")
		buf.WriteString("\treturn nil\n")
		buf.WriteString("}\n\n")
		return
	}

	buf.WriteString("\t// Validate required fields\n")

	for _, field := range cmd.Fields {
		if field.Required && !field.Repeated {
			fieldName := field.FieldName
			avpName := field.AVP.Name

			// Check based on type
			switch field.AVP.TypeName {
			case "UTF8String", "DiameterIdentity", "DiameterURI", "OctetString":
				buf.WriteString(fmt.Sprintf("\tif m.%s == \"\" {\n", fieldName))
				buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"required field %s is empty\")\n", avpName))
				buf.WriteString("\t}\n")
			case "Unsigned32", "Unsigned64", "Integer32", "Integer64", "Enumerated":
				// For numeric types, we can't really validate zero vs unset for required non-pointer fields
				// They're always initialized to zero, so we skip validation
				// This is a limitation of using non-pointer types for required fields
			default:
				// For other types, we can at least check they're not nil if they were pointers
				// But since required fields are not pointers, we skip
			}
		} else if field.Required && field.Repeated {
			fieldName := field.FieldName
			avpName := field.AVP.Name
			buf.WriteString(fmt.Sprintf("\tif len(m.%s) == 0 {\n", fieldName))
			buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"required repeated field %s is empty\")\n", avpName))
			buf.WriteString("\t}\n")
		}
	}

	buf.WriteString("\n\treturn nil\n")
	buf.WriteString("}\n\n")
}

// generateMarshal generates the Marshal method
func (g *Generator) generateMarshal(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Marshal serializes the %s to bytes using a buffer for optimal performance\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Marshal() ([]byte, error) {\n", structName))
	buf.WriteString("\t// Validate required fields before marshaling\n")
	buf.WriteString("\tif err := m.Validate(); err != nil {\n")
	buf.WriteString("\t\treturn nil, fmt.Errorf(\"validation failed: %w\", err)\n")
	buf.WriteString("\t}\n\n")
	buf.WriteString("\t// Use a buffer to avoid multiple allocations\n")
	buf.WriteString("\tvar buf bytes.Buffer\n")
	buf.WriteString("\tbuf.Grow(256) // Pre-allocate reasonable size\n\n")

	buf.WriteString("\t// Reserve space for header (we'll write it at the end)\n")
	buf.WriteString("\theaderPlaceholder := make([]byte, 20)\n")
	buf.WriteString("\tbuf.Write(headerPlaceholder)\n\n")

	buf.WriteString("\t// Marshal AVPs directly to buffer\n")

	for _, field := range cmd.Fields {
		g.generateFieldMarshalToBuffer(buf, field)
	}

	buf.WriteString("\n\t// Get the final message\n")
	buf.WriteString("\tresult := buf.Bytes()\n\n")

	buf.WriteString("\t// Update message length and write header\n")
	buf.WriteString("\tm.Header.Length = uint32(len(result))\n")
	buf.WriteString("\theader := marshalHeader(&m.Header)\n")
	buf.WriteString("\tcopy(result[:20], header)\n\n")

	buf.WriteString("\treturn result, nil\n")
	buf.WriteString("}\n\n")
}

// generateFieldMarshalToBuffer generates marshaling code that writes directly to buffer
func (g *Generator) generateFieldMarshalToBuffer(buf *bytes.Buffer, field *AVPField) {
	fieldName := field.FieldName

	if field.Repeated {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tfor _, v := range m.%s {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%d, v, %v, %v))\n",
			field.AVP.Code, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else if !field.Required {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (optional)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tif m.%s != nil {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%d, *m.%s, %v, %v))\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (required)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tbuf.Write(marshalAVP(%d, m.%s, %v, %v))\n\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
	}
}

// generateFieldMarshal generates marshaling code for a field (legacy, kept for compatibility)
func (g *Generator) generateFieldMarshal(buf *bytes.Buffer, field *AVPField) {
	fieldName := field.FieldName

	if field.Repeated {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tfor _, v := range m.%s {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVP(%d, v, %v, %v))\n",
			field.AVP.Code, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else if !field.Required {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (optional)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tif m.%s != nil {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVP(%d, *m.%s, %v, %v))\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (required)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tavps = append(avps, marshalAVP(%d, m.%s, %v, %v))\n\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
	}
}

// generateUnmarshal generates the Unmarshal method
func (g *Generator) generateUnmarshal(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Unmarshal deserializes bytes into %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Unmarshal(data []byte) error {\n", structName))
	buf.WriteString("\tif len(data) < 20 {\n")
	buf.WriteString("\t\treturn fmt.Errorf(\"data too short for Diameter header\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Unmarshal header\n")
	buf.WriteString("\theader, err := unmarshalHeader(data[:20])\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tm.Header = *header\n\n")

	buf.WriteString("\t// Unmarshal AVPs\n")
	buf.WriteString("\tavpData := data[20:]\n")
	buf.WriteString("\tfor len(avpData) > 0 {\n")
	buf.WriteString("\t\tif len(avpData) < 8 {\n")
	buf.WriteString("\t\t\tbreak // Not enough data for AVP header\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Parse AVP header\n")
	buf.WriteString("\t\tavpCode := binary.BigEndian.Uint32(avpData[0:4])\n")
	buf.WriteString("\t\tavpFlags := avpData[4]\n")
	buf.WriteString("\t\tavpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})\n\n")

	buf.WriteString("\t\tif int(avpLength) > len(avpData) {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"AVP length exceeds remaining data\")\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Extract AVP data\n")
	buf.WriteString("\t\theaderSize := 8\n")
	buf.WriteString("\t\tif avpFlags&0x80 != 0 { // V-bit set\n")
	buf.WriteString("\t\t\theaderSize = 12\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpDataLen := int(avpLength) - headerSize\n")
	buf.WriteString("\t\tif avpDataLen < 0 {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"invalid AVP data length\")\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpValue := avpData[headerSize : headerSize+avpDataLen]\n\n")

	buf.WriteString("\t\t// Parse AVP based on code\n")
	buf.WriteString("\t\tswitch avpCode {\n")

	for _, field := range cmd.Fields {
		buf.WriteString(fmt.Sprintf("\t\tcase %d: // %s\n", field.AVP.Code, field.AVP.Name))
		decoder := g.getDecoder(field.AVP.TypeName)
		if field.Repeated {
			buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
			buf.WriteString("\t\t\tif err == nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = append(m.%s, val.(%s))\n",
				field.FieldName, field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
			buf.WriteString("\t\t\t}\n")
		} else if !field.Required {
			buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
			buf.WriteString("\t\t\tif err == nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tv := val.(%s)\n", g.getBaseGoType(field.AVP.TypeName)))
			buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = &v\n", field.FieldName))
			buf.WriteString("\t\t\t}\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
			buf.WriteString("\t\t\tif err == nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = val.(%s)\n",
				field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
			buf.WriteString("\t\t\t}\n")
		}
	}

	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Move to next AVP (with padding)\n")
	buf.WriteString("\t\tpaddedLength := int(avpLength)\n")
	buf.WriteString("\t\tif paddedLength%4 != 0 {\n")
	buf.WriteString("\t\t\tpaddedLength += 4 - (paddedLength % 4)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tif paddedLength > len(avpData) {\n")
	buf.WriteString("\t\t\tbreak\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpData = avpData[paddedLength:]\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n\n")
}

// getDecoder returns the decoder function name for a type
func (g *Generator) getDecoder(typeName string) string {
	switch typeName {
	case "Unsigned32":
		return "models_base.DecodeUnsigned32"
	case "Unsigned64":
		return "models_base.DecodeUnsigned64"
	case "Integer32":
		return "models_base.DecodeInteger32"
	case "Integer64":
		return "models_base.DecodeInteger64"
	case "Float32":
		return "models_base.DecodeFloat32"
	case "Float64":
		return "models_base.DecodeFloat64"
	case "OctetString":
		return "models_base.DecodeOctetString"
	case "UTF8String":
		return "models_base.DecodeUTF8String"
	case "DiameterIdentity":
		return "models_base.DecodeDiameterIdentity"
	case "DiameterURI":
		return "models_base.DecodeDiameterURI"
	case "Enumerated":
		return "models_base.DecodeEnumerated"
	case "Address":
		return "models_base.DecodeAddress"
	case "Time":
		return "models_base.DecodeTime"
	case "IPFilterRule":
		return "models_base.DecodeIPFilterRule"
	case "QoSFilterRule":
		return "models_base.DecodeQoSFilterRule"
	case "Grouped":
		return "models_base.DecodeGrouped"
	default:
		return "models_base.DecodeOctetString"
	}
}

// generateLen generates the Len method
func (g *Generator) generateLen(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Len returns the total length of the %s message\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Len() int {\n", structName))
	buf.WriteString("\tdata, _ := m.Marshal()\n")
	buf.WriteString("\treturn len(data)\n")
	buf.WriteString("}\n\n")
}

// generateString generates the String method
func (g *Generator) generateString(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// String returns a string representation of %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) String() string {\n", structName))
	buf.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(\"%s{", structName))

	for i, field := range cmd.Fields {
		if i > 0 {
			buf.WriteString(", ")
		}
		buf.WriteString(fmt.Sprintf("%s:%%v", field.FieldName))
	}
	buf.WriteString("}\"")

	for i, field := range cmd.Fields {
		if i == 0 {
			buf.WriteString(", m.")
		} else {
			buf.WriteString(", m.")
		}
		buf.WriteString(field.FieldName)
	}

	buf.WriteString(")\n")
	buf.WriteString("}\n\n")
}

// generateTypeDefinitions generates type definitions for DiameterHeader and CommandFlags
func (g *Generator) generateTypeDefinitions(buf *bytes.Buffer) {
	buf.WriteString(`// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

`)
}

// generateHelperFunctions generates common helper functions
func (g *Generator) generateHelperFunctions(buf *bytes.Buffer) {
	helperTemplate := `
// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}
`
	buf.WriteString(helperTemplate)
}

// toConstantCase converts a name to CONSTANT_CASE
func toConstantCase(s string) string {
	// Replace dashes with underscores
	s = strings.ReplaceAll(s, "-", "")

	// Insert underscores before uppercase letters
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, r)
		} else {
			result = append(result, r)
		}
	}

	return strings.ToUpper(string(result))
}

// GenerateTest generates test code with pcap writing capabilities
func (g *Generator) GenerateTest() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"net\"\n")
	buf.WriteString("\t\"os\"\n")
	buf.WriteString("\t\"path/filepath\"\n")
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString("\t\"time\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/google/gopacket\"\n")
	buf.WriteString("\t\"github.com/google/gopacket/layers\"\n")
	buf.WriteString("\t\"github.com/google/gopacket/pcapgo\"\n")
	buf.WriteString("\t\"github.com/hsdfat8/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")
	buf.WriteString("// keepPcapFiles determines if pcap files should be kept after tests\n")
	buf.WriteString("// Set KEEP_PCAP=1 environment variable to keep the files\n")
	buf.WriteString("var keepPcapFiles = os.Getenv(\"KEEP_PCAP\") == \"1\"\n\n")

	// Generate pcap helper functions
	g.generatePcapHelpers(&buf)

	// Generate test functions for each command
	for _, cmd := range g.Parser.Commands {
		g.generateCommandTest(&buf, cmd)
	}

	return buf.String(), nil
}

// generatePcapHelpers generates helper functions for writing pcap files
func (g *Generator) generatePcapHelpers(buf *bytes.Buffer) {
	buf.WriteString(`// writeDiameterToPcap writes a Diameter message to a pcap file with proper network layers
func writeDiameterToPcap(filename string, diameterData []byte, srcIP, dstIP net.IP, port int) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	// Create packet layers
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(port),
		DstPort: layers.TCPPort(3868), // Diameter default port
		Seq:     1000,
		Ack:     0,
		SYN:     false,
		ACK:     true,
		PSH:     true,
		Window:  65535,
	}

	// Set TCP options for better compatibility
	tcp.Options = []layers.TCPOption{
		{
			OptionType:   layers.TCPOptionKindMSS,
			OptionLength: 4,
			OptionData:   []byte{0x05, 0xb4}, // MSS = 1460
		},
		{
			OptionType: layers.TCPOptionKindNop,
		},
		{
			OptionType:   layers.TCPOptionKindWindowScale,
			OptionLength: 3,
			OptionData:   []byte{0x07}, // Window scale = 7
		},
	}

	// Calculate TCP checksum
	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize the packet
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	// Create payload (Diameter data)
	payload := gopacket.Payload(diameterData)

	// Serialize all layers
	err = gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet to pcap file
	ci := gopacket.CaptureInfo{
		Timestamp:     time.Now(),
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	err = w.WritePacket(ci, packetBuf.Bytes())
	if err != nil {
		return err
	}

	return nil
}

// writePacketToPcap writes a single packet to an existing pcap writer
func writePacketToPcap(w *pcapgo.Writer, diameterData []byte, srcIP, dstIP net.IP, srcPort, dstPort int, seq, ack uint32, timestamp time.Time) error {
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(dstPort),
		Seq:     seq,
		Ack:     ack,
		SYN:     ack == 0 && seq == 1000, // Only for SYN packet
		ACK:     ack > 0,                 // ACK if we have acknowledgment number
		PSH:     true,                    // Push flag for data packets
		Window:  65535,
	}

	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	payload := gopacket.Payload(diameterData)

	err := gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet
	ci := gopacket.CaptureInfo{
		Timestamp:     timestamp,
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	return w.WritePacket(ci, packetBuf.Bytes())
}

`)
}

// generateCommandTest generates a test function for a command that writes to pcap
func (g *Generator) generateCommandTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))
	testFuncName := fmt.Sprintf("Test%sToPcap", structName)
	pcapFileName := fmt.Sprintf("test_%s.pcap", strings.ToLower(strings.ReplaceAll(cmd.Abbreviation, "-", "_")))

	buf.WriteString(fmt.Sprintf("// %s tests writing a %s message to a pcap file\n", testFuncName, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testFuncName))
	buf.WriteString("\t// Create testdata directory if it doesn't exist\n")
	buf.WriteString("\tif err := os.MkdirAll(\"testdata\", 0755); err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to create testdata directory: %v\", err)\n")
	buf.WriteString("\t}\n\n")
	buf.WriteString("\t// Create a pcap file in testdata folder\n")
	buf.WriteString(fmt.Sprintf("\tpcapFile := filepath.Join(\"testdata\", \"%s\")\n", pcapFileName))
	buf.WriteString("\tif !keepPcapFiles {\n")
	buf.WriteString("\t\tdefer os.Remove(pcapFile) // Clean up after test\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\t// Create and configure a %s message\n", cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("\tmsg := New%s()\n\n", structName))

	// Generate field assignments for required fields
	cmdName := cmd.Name
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignment(buf, field, &cmdName)
		}
	}

	buf.WriteString("\t// Set header identifiers\n")
	buf.WriteString("\tmsg.Header.HopByHopID = 0x12345678\n")
	buf.WriteString("\tmsg.Header.EndToEndID = 0x87654321\n\n")

	buf.WriteString("\t// Marshal the Diameter message\n")
	buf.WriteString("\tdiameterData, err := msg.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\tt.Fatalf(\"Failed to marshal %s: %%v\", err)\n", cmd.Abbreviation))
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Write to pcap file\n")
	buf.WriteString("\terr = writeDiameterToPcap(pcapFile, diameterData, net.ParseIP(\"192.168.1.100\"), net.ParseIP(\"192.168.1.1\"), 3868)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to write pcap file: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Verify file was created\n")
	buf.WriteString("\tfileInfo, err := os.Stat(pcapFile)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Pcap file was not created: %v\", err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif fileInfo.Size() == 0 {\n")
	buf.WriteString("\t\tt.Fatal(\"Pcap file is empty\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\tt.Logf(\"Successfully created pcap file: %%s (%%d bytes)\", pcapFile, fileInfo.Size())\n"))
	buf.WriteString("\tt.Logf(\"You can open this file in Wireshark to view the Diameter message\")\n")
	buf.WriteString("}\n\n")
}

// generateTestFieldAssignment generates code to assign test values to a field
func (g *Generator) generateTestFieldAssignment(buf *bytes.Buffer, field *AVPField, cmdName *string) {
	fieldName := field.FieldName
	isRepeated := field.Repeated

	switch field.AVP.TypeName {
	case "DiameterIdentity":
		value := "\"client.example.com\""
		if strings.Contains(strings.ToLower(*cmdName), "answer") {
			value = "\"server.example.com\""
		} else if strings.Contains(fieldName, "Destination") {
			value = "\"server.example.com\""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = []models_base.DiameterIdentity{models_base.DiameterIdentity(%s)}\n", fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = models_base.DiameterIdentity(%s)\n", fieldName, value))
		}
	case "UTF8String":
		value := "\"test\""
		if fieldName == "SessionId" || strings.Contains(fieldName, "Session") {
			value = "\"client.example.com;1234567890;1\""
		} else if strings.Contains(fieldName, "Product") {
			value = "\"TestProduct/1.0\""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = []models_base.UTF8String{models_base.UTF8String(%s)}\n", fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = models_base.UTF8String(%s)\n", fieldName, value))
		}
	case "Address":
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = []models_base.Address{\n", fieldName))
		} else {
			// Single address - this shouldn't happen for required fields, but handle it
			buf.WriteString(fmt.Sprintf("\tmsg.%s = []models_base.Address{\n", fieldName))
		}
		buf.WriteString("\t\tmodels_base.Address(net.ParseIP(\"192.168.1.100\")),\n")
		buf.WriteString("\t}\n")
	case "Unsigned32":
		var value string
		var comment string
		if fieldName == "ResultCode" || strings.Contains(fieldName, "Result") {
			value = "2001"
			comment = " // DIAMETER_SUCCESS"
		} else if fieldName == "VendorId" || strings.Contains(fieldName, "Vendor") {
			value = "10415"
			comment = " // 3GPP"
		} else {
			value = "1"
			comment = ""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = []models_base.Unsigned32{models_base.Unsigned32(%s)}%s\n", fieldName, value, comment))
		} else {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = models_base.Unsigned32(%s)%s\n", fieldName, value, comment))
		}
	case "Enumerated":
		value := "1"
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = []models_base.Enumerated{models_base.Enumerated(%s)}\n", fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("\tmsg.%s = models_base.Enumerated(%s)\n", fieldName, value))
		}
	case "Grouped":
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\t// msg.%s (Grouped) needs to be set manually\n", fieldName))
		} else {
			buf.WriteString(fmt.Sprintf("\t// msg.%s (Grouped) needs to be set manually\n", fieldName))
		}
	default:
		// For other types, add a comment
		buf.WriteString(fmt.Sprintf("\t// msg.%s needs to be set manually (type: %s)\n", fieldName, field.AVP.TypeName))
	}
}
