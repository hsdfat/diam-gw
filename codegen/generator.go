package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
)

// Generator generates Go code from parsed proto definitions
type Generator struct {
	Parser      *ProtoParser
	PackageName string
}

// NewGenerator creates a new code generator
func NewGenerator(parser *ProtoParser, packageName string) *Generator {
	return &Generator{
		Parser:      parser,
		PackageName: packageName,
	}
}

// GenerateToFile generates Go code and writes to a file
func (g *Generator) GenerateToFile(outputFile string) error {
	code, err := g.Generate()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(outputFile, []byte(code), 0644)
	}

	return os.WriteFile(outputFile, formatted, 0644)
}

// Generate generates Go code from parsed definitions
func (g *Generator) Generate() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString(fmt.Sprintf("// Code generated by diameter-codegen. DO NOT EDIT.\n\n"))
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"encoding/binary\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/hsdfat8/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")

	// Generate type definitions
	g.generateTypeDefinitions(&buf)

	// Generate AVP constants
	buf.WriteString("// AVP Codes\n")
	buf.WriteString("const (\n")
	for name, avp := range g.Parser.AVPs {
		constName := toConstantCase(name)
		buf.WriteString(fmt.Sprintf("\tAVPCode%s uint32 = %d\n", constName, avp.Code))
	}
	buf.WriteString(")\n\n")

	// Generate command codes
	buf.WriteString("// Command Codes\n")
	buf.WriteString("const (\n")
	for _, cmd := range g.Parser.Commands {
		constName := toConstantCase(cmd.Name)
		buf.WriteString(fmt.Sprintf("\tCommandCode%s uint32 = %d\n", constName, cmd.Code))
	}
	buf.WriteString(")\n\n")

	// Generate command structs
	for _, cmd := range g.Parser.Commands {
		if err := g.generateCommandStruct(&buf, cmd); err != nil {
			return "", err
		}
	}

	// Generate helper functions
	g.generateHelperFunctions(&buf)

	return buf.String(), nil
}

// generateCommandStruct generates a struct for a command
func (g *Generator) generateCommandStruct(buf *bytes.Buffer, cmd *CommandDefinition) error {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))

	// Write struct comment
	buf.WriteString(fmt.Sprintf("// %s represents the %s (%s) Diameter command\n", structName, cmd.Name, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("// Command Code: %d, Application ID: %d\n", cmd.Code, cmd.ApplicationID))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// Write header field
	buf.WriteString("\tHeader DiameterHeader\n\n")

	// Write AVP fields
	for _, field := range cmd.Fields {
		goType := g.getGoType(field)
		comment := ""
		if field.Required {
			comment = " // Required"
		} else {
			comment = " // Optional"
		}
		buf.WriteString(fmt.Sprintf("\t%s %s%s\n", field.FieldName, goType, comment))
	}

	buf.WriteString("}\n\n")

	// Generate constructor
	g.generateConstructor(buf, cmd, structName)

	// Generate Marshal method
	g.generateMarshal(buf, cmd, structName)

	// Generate Unmarshal method
	g.generateUnmarshal(buf, cmd, structName)

	// Generate Len method
	g.generateLen(buf, cmd, structName)

	// Generate String method
	g.generateString(buf, cmd, structName)

	return nil
}

// getGoType returns the Go type for a field
func (g *Generator) getGoType(field *AVPField) string {
	baseType := g.getBaseGoType(field.AVP.TypeName)

	if field.Repeated {
		return "[]" + baseType
	}

	if !field.Required {
		return "*" + baseType
	}

	return baseType
}

// getBaseGoType returns the base Go type for an AVP type
func (g *Generator) getBaseGoType(typeName string) string {
	switch typeName {
	case "Unsigned32":
		return "models_base.Unsigned32"
	case "Unsigned64":
		return "models_base.Unsigned64"
	case "Integer32":
		return "models_base.Integer32"
	case "Integer64":
		return "models_base.Integer64"
	case "Float32":
		return "models_base.Float32"
	case "Float64":
		return "models_base.Float64"
	case "OctetString":
		return "models_base.OctetString"
	case "UTF8String":
		return "models_base.UTF8String"
	case "DiameterIdentity":
		return "models_base.DiameterIdentity"
	case "DiameterURI":
		return "models_base.DiameterURI"
	case "Enumerated":
		return "models_base.Enumerated"
	case "Address":
		return "models_base.Address"
	case "Time":
		return "models_base.Time"
	case "IPFilterRule":
		return "models_base.IPFilterRule"
	case "QoSFilterRule":
		return "models_base.QoSFilterRule"
	case "Grouped":
		return "models_base.Grouped"
	default:
		return "models_base.OctetString" // fallback
	}
}

// generateConstructor generates a constructor function
func (g *Generator) generateConstructor(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// New%s creates a new %s message\n", structName, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("func New%s() *%s {\n", structName, structName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{\n", structName))
	buf.WriteString("\t\tHeader: DiameterHeader{\n")
	buf.WriteString("\t\t\tVersion:       1,\n")
	buf.WriteString(fmt.Sprintf("\t\t\tCommandCode:   %d,\n", cmd.Code))
	buf.WriteString(fmt.Sprintf("\t\t\tApplicationID: %d,\n", cmd.ApplicationID))
	buf.WriteString("\t\t\tFlags: CommandFlags{\n")
	buf.WriteString(fmt.Sprintf("\t\t\t\tRequest:   %v,\n", cmd.Request))
	buf.WriteString(fmt.Sprintf("\t\t\t\tProxiable: %v,\n", cmd.Proxiable))
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")
}

// generateMarshal generates the Marshal method
func (g *Generator) generateMarshal(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Marshal serializes the %s to bytes using a buffer for optimal performance\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Marshal() ([]byte, error) {\n", structName))
	buf.WriteString("\t// Use a buffer to avoid multiple allocations\n")
	buf.WriteString("\tvar buf bytes.Buffer\n")
	buf.WriteString("\tbuf.Grow(256) // Pre-allocate reasonable size\n\n")

	buf.WriteString("\t// Reserve space for header (we'll write it at the end)\n")
	buf.WriteString("\theaderPlaceholder := make([]byte, 20)\n")
	buf.WriteString("\tbuf.Write(headerPlaceholder)\n\n")

	buf.WriteString("\t// Marshal AVPs directly to buffer\n")

	for _, field := range cmd.Fields {
		g.generateFieldMarshalToBuffer(buf, field)
	}

	buf.WriteString("\n\t// Get the final message\n")
	buf.WriteString("\tresult := buf.Bytes()\n\n")

	buf.WriteString("\t// Update message length and write header\n")
	buf.WriteString("\tm.Header.Length = uint32(len(result))\n")
	buf.WriteString("\theader := marshalHeader(&m.Header)\n")
	buf.WriteString("\tcopy(result[:20], header)\n\n")

	buf.WriteString("\treturn result, nil\n")
	buf.WriteString("}\n\n")
}

// generateFieldMarshalToBuffer generates marshaling code that writes directly to buffer
func (g *Generator) generateFieldMarshalToBuffer(buf *bytes.Buffer, field *AVPField) {
	fieldName := field.FieldName

	if field.Repeated {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tfor _, v := range m.%s {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%d, v, %v, %v))\n",
			field.AVP.Code, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else if !field.Required {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (optional)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tif m.%s != nil {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%d, *m.%s, %v, %v))\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (required)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tbuf.Write(marshalAVP(%d, m.%s, %v, %v))\n\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
	}
}

// generateFieldMarshal generates marshaling code for a field (legacy, kept for compatibility)
func (g *Generator) generateFieldMarshal(buf *bytes.Buffer, field *AVPField) {
	fieldName := field.FieldName

	if field.Repeated {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tfor _, v := range m.%s {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVP(%d, v, %v, %v))\n",
			field.AVP.Code, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else if !field.Required {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (optional)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tif m.%s != nil {\n", fieldName))
		buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVP(%d, *m.%s, %v, %v))\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
		buf.WriteString("\t}\n\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (required)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tavps = append(avps, marshalAVP(%d, m.%s, %v, %v))\n\n",
			field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
	}
}

// generateUnmarshal generates the Unmarshal method
func (g *Generator) generateUnmarshal(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Unmarshal deserializes bytes into %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Unmarshal(data []byte) error {\n", structName))
	buf.WriteString("\tif len(data) < 20 {\n")
	buf.WriteString("\t\treturn fmt.Errorf(\"data too short for Diameter header\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Unmarshal header\n")
	buf.WriteString("\theader, err := unmarshalHeader(data[:20])\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tm.Header = *header\n\n")

	buf.WriteString("\t// Unmarshal AVPs\n")
	buf.WriteString("\tavpData := data[20:]\n")
	buf.WriteString("\tfor len(avpData) > 0 {\n")
	buf.WriteString("\t\tif len(avpData) < 8 {\n")
	buf.WriteString("\t\t\tbreak // Not enough data for AVP header\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Parse AVP header\n")
	buf.WriteString("\t\tavpCode := binary.BigEndian.Uint32(avpData[0:4])\n")
	buf.WriteString("\t\tavpFlags := avpData[4]\n")
	buf.WriteString("\t\tavpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})\n\n")

	buf.WriteString("\t\tif int(avpLength) > len(avpData) {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"AVP length exceeds remaining data\")\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Extract AVP data\n")
	buf.WriteString("\t\theaderSize := 8\n")
	buf.WriteString("\t\tif avpFlags&0x80 != 0 { // V-bit set\n")
	buf.WriteString("\t\t\theaderSize = 12\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpDataLen := int(avpLength) - headerSize\n")
	buf.WriteString("\t\tif avpDataLen < 0 {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"invalid AVP data length\")\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpValue := avpData[headerSize : headerSize+avpDataLen]\n\n")

	buf.WriteString("\t\t// Parse AVP based on code\n")
	buf.WriteString("\t\tswitch avpCode {\n")

	for _, field := range cmd.Fields {
		buf.WriteString(fmt.Sprintf("\t\tcase %d: // %s\n", field.AVP.Code, field.AVP.Name))
		decoder := g.getDecoder(field.AVP.TypeName)
		if field.Repeated {
			buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
			buf.WriteString("\t\t\tif err == nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = append(m.%s, val.(%s))\n",
				field.FieldName, field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
			buf.WriteString("\t\t\t}\n")
		} else if !field.Required {
			buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
			buf.WriteString("\t\t\tif err == nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tv := val.(%s)\n", g.getBaseGoType(field.AVP.TypeName)))
			buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = &v\n", field.FieldName))
			buf.WriteString("\t\t\t}\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
			buf.WriteString("\t\t\tif err == nil {\n")
			buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = val.(%s)\n",
				field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
			buf.WriteString("\t\t\t}\n")
		}
	}

	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Move to next AVP (with padding)\n")
	buf.WriteString("\t\tpaddedLength := int(avpLength)\n")
	buf.WriteString("\t\tif paddedLength%4 != 0 {\n")
	buf.WriteString("\t\t\tpaddedLength += 4 - (paddedLength % 4)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tif paddedLength > len(avpData) {\n")
	buf.WriteString("\t\t\tbreak\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpData = avpData[paddedLength:]\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n\n")
}

// getDecoder returns the decoder function name for a type
func (g *Generator) getDecoder(typeName string) string {
	switch typeName {
	case "Unsigned32":
		return "models_base.DecodeUnsigned32"
	case "Unsigned64":
		return "models_base.DecodeUnsigned64"
	case "Integer32":
		return "models_base.DecodeInteger32"
	case "Integer64":
		return "models_base.DecodeInteger64"
	case "Float32":
		return "models_base.DecodeFloat32"
	case "Float64":
		return "models_base.DecodeFloat64"
	case "OctetString":
		return "models_base.DecodeOctetString"
	case "UTF8String":
		return "models_base.DecodeUTF8String"
	case "DiameterIdentity":
		return "models_base.DecodeDiameterIdentity"
	case "DiameterURI":
		return "models_base.DecodeDiameterURI"
	case "Enumerated":
		return "models_base.DecodeEnumerated"
	case "Address":
		return "models_base.DecodeAddress"
	case "Time":
		return "models_base.DecodeTime"
	case "IPFilterRule":
		return "models_base.DecodeIPFilterRule"
	case "QoSFilterRule":
		return "models_base.DecodeQoSFilterRule"
	case "Grouped":
		return "models_base.DecodeGrouped"
	default:
		return "models_base.DecodeOctetString"
	}
}

// generateLen generates the Len method
func (g *Generator) generateLen(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Len returns the total length of the %s message\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Len() int {\n", structName))
	buf.WriteString("\tdata, _ := m.Marshal()\n")
	buf.WriteString("\treturn len(data)\n")
	buf.WriteString("}\n\n")
}

// generateString generates the String method
func (g *Generator) generateString(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// String returns a string representation of %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) String() string {\n", structName))
	buf.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(\"%s{", structName))

	for i, field := range cmd.Fields {
		if i > 0 {
			buf.WriteString(", ")
		}
		buf.WriteString(fmt.Sprintf("%s:%%v", field.FieldName))
	}
	buf.WriteString("}\"")

	for i, field := range cmd.Fields {
		if i == 0 {
			buf.WriteString(", m.")
		} else {
			buf.WriteString(", m.")
		}
		buf.WriteString(field.FieldName)
	}

	buf.WriteString(")\n")
	buf.WriteString("}\n\n")
}

// generateTypeDefinitions generates type definitions for DiameterHeader and CommandFlags
func (g *Generator) generateTypeDefinitions(buf *bytes.Buffer) {
	buf.WriteString(`// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

`)
}

// generateHelperFunctions generates common helper functions
func (g *Generator) generateHelperFunctions(buf *bytes.Buffer) {
	helperTemplate := `
// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}
`
	buf.WriteString(helperTemplate)
}

// toConstantCase converts a name to CONSTANT_CASE
func toConstantCase(s string) string {
	// Replace dashes with underscores
	s = strings.ReplaceAll(s, "-", "")

	// Insert underscores before uppercase letters
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, r)
		} else {
			result = append(result, r)
		}
	}

	return strings.ToUpper(string(result))
}
