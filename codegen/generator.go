package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"
)

// Generator generates Go code from parsed proto definitions
type Generator struct {
	Parser      *ProtoParser
	PackageName string
}

// NewGenerator creates a new code generator
func NewGenerator(parser *ProtoParser, packageName string) *Generator {
	return &Generator{
		Parser:      parser,
		PackageName: packageName,
	}
}

// GenerateToFile generates Go code and writes to a file
func (g *Generator) GenerateToFile(outputFile string) error {
	code, err := g.Generate()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(outputFile, []byte(code), 0644)
	}

	return os.WriteFile(outputFile, formatted, 0644)
}

// GenerateConstantsFile generates a constants file with AVP codes, enums, and protocol constants
func (g *Generator) GenerateConstantsFile(outputFile string) error {
	code, err := g.GenerateConstants()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(outputFile, []byte(code), 0644)
	}

	return os.WriteFile(outputFile, formatted, 0644)
}

// GenerateTestFile generates a test file with pcap writing capabilities
func (g *Generator) GenerateTestFile(testFile string) error {
	code, err := g.GenerateTest()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(testFile, []byte(code), 0644)
	}

	return os.WriteFile(testFile, formatted, 0644)
}

// GenerateUnitTestFile generates a unit test file with validation and roundtrip tests
func (g *Generator) GenerateUnitTestFile(testFile string) error {
	code, err := g.GenerateUnitTests()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(testFile, []byte(code), 0644)
	}

	return os.WriteFile(testFile, formatted, 0644)
}

// GeneratePcapTestFile generates a PCAP test file for network packet generation
func (g *Generator) GeneratePcapTestFile(testFile string) error {
	code, err := g.GeneratePcapTests()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(testFile, []byte(code), 0644)
	}

	return os.WriteFile(testFile, formatted, 0644)
}

// GenerateBenchmarkTestFile generates a benchmark test file
func (g *Generator) GenerateBenchmarkTestFile(testFile string) error {
	code, err := g.GenerateBenchmarkTests()
	if err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		// If formatting fails, write the unformatted code for debugging
		return os.WriteFile(testFile, []byte(code), 0644)
	}

	return os.WriteFile(testFile, formatted, 0644)
}

// Generate generates Go code from parsed definitions
func (g *Generator) Generate() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"encoding/binary\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/hsdfat/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")

	// Generate type definitions
	g.generateTypeDefinitions(&buf)

	// Generate Grouped AVP structs
	buf.WriteString("// Grouped AVP structures\n\n")
	// Sort AVP names for consistent output
	sortedAVPNames := make([]string, 0, len(g.Parser.AVPs))
	for name := range g.Parser.AVPs {
		sortedAVPNames = append(sortedAVPNames, name)
	}
	sort.Strings(sortedAVPNames)
	for _, name := range sortedAVPNames {
		avp := g.Parser.AVPs[name]
		if avp.TypeName == "Grouped" {
			structName := toCamelCase(strings.ReplaceAll(name, "-", "_"))
			buf.WriteString(fmt.Sprintf("// %s represents the %s grouped AVP (AVP Code %d)\n", structName, name, avp.Code))
			buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

			// Generate fields from grouped definition
			if len(avp.GroupedFields) > 0 {
				for _, field := range avp.GroupedFields {
					goType := g.getGoType(field)
					comment := ""
					if field.AVP.Code == 0 {
						// AVP not defined - add warning
						if field.Required {
							comment = " // Required - WARNING: AVP code not defined, DO NOT USE"
						} else {
							comment = " // Optional - WARNING: AVP code not defined, DO NOT USE"
						}
					} else {
						if field.Required {
							comment = " // Required"
						} else {
							comment = " // Optional"
						}
					}
					buf.WriteString(fmt.Sprintf("\t%s %s%s\n", field.FieldName, goType, comment))
				}
			} else {
				buf.WriteString("\t// No fields defined - using raw data\n")
				buf.WriteString("\tData []byte\n")
			}

			buf.WriteString("}\n\n")

			// Generate Marshal method
			g.generateGroupedMarshal(&buf, structName, avp)

			// Generate Unmarshal method
			g.generateGroupedUnmarshal(&buf, structName, avp)
		}
	}

	// Note: AVP and Command constants are now generated in a separate constants.go file
	// via GenerateConstantsFile() method

	// Generate command structs
	for _, cmd := range g.Parser.Commands {
		if err := g.generateCommandStruct(&buf, cmd); err != nil {
			return "", err
		}
	}

	// Generate helper functions
	g.generateHelperFunctions(&buf)

	return buf.String(), nil
}

// GenerateConstants generates a constants file with AVP codes, enums, and protocol constants
func (g *Generator) GenerateConstants() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Generate protocol-level constants
	if len(g.Parser.Consts) > 0 {
		buf.WriteString("// Protocol Constants\n")
		buf.WriteString("const (\n")
		// Sort constant names for consistent output
		constNames := make([]string, 0, len(g.Parser.Consts))
		for name := range g.Parser.Consts {
			constNames = append(constNames, name)
		}
		sort.Strings(constNames)
		for _, name := range constNames {
			value := g.Parser.Consts[name]
			buf.WriteString(fmt.Sprintf("\t%s = %d\n", name, value))
		}
		buf.WriteString(")\n\n")
	}

	// Generate AVP Code constants
	buf.WriteString("// AVP Codes\n")
	buf.WriteString("const (\n")

	// Sort AVP names for consistent output
	avpNames := make([]string, 0, len(g.Parser.AVPs))
	for name := range g.Parser.AVPs {
		avpNames = append(avpNames, name)
	}
	sort.Strings(avpNames)

	for _, name := range avpNames {
		avp := g.Parser.AVPs[name]
		constName := toConstantCase(name)
		buf.WriteString(fmt.Sprintf("\tAVPCode%s uint32 = %d\n", constName, avp.Code))
	}
	buf.WriteString(")\n\n")

	// Generate Vendor ID constants (if any vendor-specific AVPs exist)
	vendorIDs := make(map[uint32]bool)
	for _, avp := range g.Parser.AVPs {
		if avp.VendorID != 0 {
			vendorIDs[avp.VendorID] = true
		}
	}
	if len(vendorIDs) > 0 {
		buf.WriteString("// Vendor IDs\n")
		buf.WriteString("const (\n")
		// Sort vendor IDs for consistent output
		sortedVendorIDs := make([]uint32, 0, len(vendorIDs))
		for vendorID := range vendorIDs {
			sortedVendorIDs = append(sortedVendorIDs, vendorID)
		}
		sort.Slice(sortedVendorIDs, func(i, j int) bool {
			return sortedVendorIDs[i] < sortedVendorIDs[j]
		})
		for _, vendorID := range sortedVendorIDs {
			buf.WriteString(fmt.Sprintf("\tVendorID%d uint32 = %d\n", vendorID, vendorID))
		}
		buf.WriteString(")\n\n")
	}

	// Generate Command Code constants
	if len(g.Parser.Commands) > 0 {
		buf.WriteString("// Command Codes\n")
		buf.WriteString("const (\n")
		// Sort commands by name for consistent output
		sortedCommands := make([]*CommandDefinition, len(g.Parser.Commands))
		copy(sortedCommands, g.Parser.Commands)
		sort.Slice(sortedCommands, func(i, j int) bool {
			return sortedCommands[i].Name < sortedCommands[j].Name
		})
		for _, cmd := range sortedCommands {
			constName := toConstantCase(cmd.Name)
			buf.WriteString(fmt.Sprintf("\tCommandCode%s uint32 = %d\n", constName, cmd.Code))
		}
		buf.WriteString(")\n\n")
	}

	// Generate Enum type definitions
	// Sort enum names for consistent output
	sortedEnumNames := make([]string, 0, len(g.Parser.Enums))
	for enumName := range g.Parser.Enums {
		sortedEnumNames = append(sortedEnumNames, enumName)
	}
	sort.Strings(sortedEnumNames)
	for _, enumName := range sortedEnumNames {
		enum := g.Parser.Enums[enumName]
		typeName := toCamelCase(enumName)
		buf.WriteString(fmt.Sprintf("// %s represents the %s enumerated type\n", typeName, enumName))
		buf.WriteString(fmt.Sprintf("type %s uint32\n\n", typeName))

		// Generate enum constants
		buf.WriteString(fmt.Sprintf("// %s values\n", enumName))
		buf.WriteString("const (\n")
		// Sort enum values for consistent output
		sortedValueNames := make([]string, 0, len(enum.Values))
		for valueName := range enum.Values {
			sortedValueNames = append(sortedValueNames, valueName)
		}
		sort.Strings(sortedValueNames)
		for _, valueName := range sortedValueNames {
			value := enum.Values[valueName]
			constName := typeName + "_" + valueName
			buf.WriteString(fmt.Sprintf("\t%s %s = %d\n", constName, typeName, value))
		}
		buf.WriteString(")\n\n")
	}

	return buf.String(), nil
}

// generateCommandStruct generates a struct for a command
func (g *Generator) generateCommandStruct(buf *bytes.Buffer, cmd *CommandDefinition) error {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))

	// Write struct comment
	buf.WriteString(fmt.Sprintf("// %s represents the %s (%s) Diameter command\n", structName, cmd.Name, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("// Command Code: %d, Application ID: %d\n", cmd.Code, cmd.ApplicationID))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// Write header field
	buf.WriteString("\tHeader DiameterHeader\n\n")

	// Write AVP fields
	for _, field := range cmd.Fields {
		goType := g.getGoType(field)
		comment := ""
		if field.AVP.Code == 0 {
			// AVP not defined - add warning
			if field.Required {
				comment = " // Required - WARNING: AVP code not defined, DO NOT USE"
			} else {
				comment = " // Optional - WARNING: AVP code not defined, DO NOT USE"
			}
		} else {
			if field.Required {
				comment = " // Required"
			} else {
				comment = " // Optional"
			}
		}
		buf.WriteString(fmt.Sprintf("\t%s %s%s\n", field.FieldName, goType, comment))
	}

	buf.WriteString("}\n\n")

	// Generate constructor
	g.generateConstructor(buf, cmd, structName)

	// Generate Validate method
	g.generateValidate(buf, cmd, structName)

	// Generate Marshal method
	g.generateMarshal(buf, cmd, structName)

	// Generate Unmarshal method
	g.generateUnmarshal(buf, cmd, structName)

	// Generate Len method
	g.generateLen(buf, cmd, structName)

	// Generate String method
	g.generateString(buf, cmd, structName)

	return nil
}

// getGoType returns the Go type for a field
func (g *Generator) getGoType(field *AVPField) string {
	baseType := g.getBaseGoTypeForField(field)

	if field.Repeated {
		// Only use pointer for Grouped types in repeated fields
		if field.AVP.TypeName == "Grouped" {
			return "[]*" + baseType
		}
		return "[]" + baseType
	}

	if !field.Required {
		return "*" + baseType
	}

	// For Grouped types, always use pointer even if required
	if field.AVP.TypeName == "Grouped" {
		return "*" + baseType
	}

	return baseType
}

// getBaseGoType returns the base Go type for an AVP type
func (g *Generator) getBaseGoType(typeName string) string {
	switch typeName {
	case "Unsigned32":
		return "models_base.Unsigned32"
	case "Unsigned64":
		return "models_base.Unsigned64"
	case "Integer32":
		return "models_base.Integer32"
	case "Integer64":
		return "models_base.Integer64"
	case "Float32":
		return "models_base.Float32"
	case "Float64":
		return "models_base.Float64"
	case "OctetString":
		return "models_base.OctetString"
	case "UTF8String":
		return "models_base.UTF8String"
	case "DiameterIdentity":
		return "models_base.DiameterIdentity"
	case "DiameterURI":
		return "models_base.DiameterURI"
	case "Enumerated":
		return "models_base.Enumerated"
	case "Address":
		return "models_base.Address"
	case "Time":
		return "models_base.Time"
	case "IPFilterRule":
		return "models_base.IPFilterRule"
	case "QoSFilterRule":
		return "models_base.QoSFilterRule"
	case "Grouped":
		return "models_base.Grouped"
	default:
		return "models_base.OctetString" // fallback
	}
}

// getBaseGoTypeForField returns the base Go type for an AVP field, considering Grouped types
func (g *Generator) getBaseGoTypeForField(field *AVPField) string {
	if field.AVP.TypeName == "Grouped" {
		// For Grouped types, use the AVP name to create a struct name
		return toCamelCase(strings.ReplaceAll(field.AVP.Name, "-", "_"))
	}
	return g.getBaseGoType(field.AVP.TypeName)
}

// generateConstructor generates a constructor function
func (g *Generator) generateConstructor(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// New%s creates a new %s message\n", structName, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("func New%s() *%s {\n", structName, structName))
	buf.WriteString(fmt.Sprintf("\treturn &%s{\n", structName))
	buf.WriteString("\t\tHeader: DiameterHeader{\n")
	buf.WriteString("\t\t\tVersion:       1,\n")
	buf.WriteString(fmt.Sprintf("\t\t\tCommandCode:   %d,\n", cmd.Code))
	buf.WriteString(fmt.Sprintf("\t\t\tApplicationID: %d,\n", cmd.ApplicationID))
	buf.WriteString("\t\t\tFlags: CommandFlags{\n")
	buf.WriteString(fmt.Sprintf("\t\t\t\tRequest:   %v,\n", cmd.Request))
	buf.WriteString(fmt.Sprintf("\t\t\t\tProxiable: %v,\n", cmd.Proxiable))
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")
}

// generateValidate generates the Validate method
func (g *Generator) generateValidate(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Validate checks if all required fields are set in %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Validate() error {\n", structName))

	hasRequiredFields := false
	for _, field := range cmd.Fields {
		if field.Required && !field.Repeated {
			hasRequiredFields = true
			break
		}
	}

	if !hasRequiredFields {
		buf.WriteString("\t// No required fields to validate\n")
		buf.WriteString("\treturn nil\n")
		buf.WriteString("}\n\n")
		return
	}

	buf.WriteString("\t// Validate required fields\n")

	for _, field := range cmd.Fields {
		if field.Required && !field.Repeated {
			fieldName := field.FieldName
			avpName := field.AVP.Name

			// Check based on type
			switch field.AVP.TypeName {
			case "UTF8String", "DiameterIdentity", "DiameterURI", "OctetString":
				buf.WriteString(fmt.Sprintf("\tif m.%s == \"\" {\n", fieldName))
				buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"required field %s is empty\")\n", avpName))
				buf.WriteString("\t}\n")
			case "Grouped":
				// Grouped types are always pointers
				buf.WriteString(fmt.Sprintf("\tif m.%s == nil {\n", fieldName))
				buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"required field %s is nil\")\n", avpName))
				buf.WriteString("\t}\n")
			case "Unsigned32", "Unsigned64", "Integer32", "Integer64", "Enumerated":
				// For numeric types, we can't really validate zero vs unset for required non-pointer fields
				// They're always initialized to zero, so we skip validation
				// This is a limitation of using non-pointer types for required fields
			default:
				// For other types, we can at least check they're not nil if they were pointers
				// But since required fields are not pointers, we skip
			}
		} else if field.Required && field.Repeated {
			fieldName := field.FieldName
			avpName := field.AVP.Name
			buf.WriteString(fmt.Sprintf("\tif len(m.%s) == 0 {\n", fieldName))
			buf.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"required repeated field %s is empty\")\n", avpName))
			buf.WriteString("\t}\n")
		}
	}

	buf.WriteString("\n\treturn nil\n")
	buf.WriteString("}\n\n")
}

// generateMarshal generates the Marshal method
func (g *Generator) generateMarshal(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Marshal serializes the %s to bytes using a buffer for optimal performance\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Marshal() ([]byte, error) {\n", structName))
	buf.WriteString("\t// Validate required fields before marshaling\n")
	buf.WriteString("\tif err := m.Validate(); err != nil {\n")
	buf.WriteString("\t\treturn nil, fmt.Errorf(\"validation failed: %w\", err)\n")
	buf.WriteString("\t}\n\n")
	buf.WriteString("\t// Use a buffer to avoid multiple allocations\n")
	buf.WriteString("\tvar buf bytes.Buffer\n")
	buf.WriteString("\tbuf.Grow(256) // Pre-allocate reasonable size\n\n")

	buf.WriteString("\t// Reserve space for header (we'll write it at the end)\n")
	buf.WriteString("\theaderPlaceholder := make([]byte, 20)\n")
	buf.WriteString("\tbuf.Write(headerPlaceholder)\n\n")

	buf.WriteString("\t// Marshal AVPs directly to buffer\n")

	for _, field := range cmd.Fields {
		g.generateFieldMarshalToBuffer(buf, field)
	}

	buf.WriteString("\n\t// Get the final message\n")
	buf.WriteString("\tresult := buf.Bytes()\n\n")

	buf.WriteString("\t// Update message length and write header\n")
	buf.WriteString("\tm.Header.Length = uint32(len(result))\n")
	buf.WriteString("\theader := marshalHeader(&m.Header)\n")
	buf.WriteString("\tcopy(result[:20], header)\n\n")

	buf.WriteString("\treturn result, nil\n")
	buf.WriteString("}\n\n")
}

// generateFieldMarshalToBuffer generates marshaling code that writes directly to buffer
func (g *Generator) generateFieldMarshalToBuffer(buf *bytes.Buffer, field *AVPField) {
	g.generateFieldMarshalToBufferWithReceiver(buf, field, "m")
}

// generateFieldMarshalToBufferWithReceiver generates marshaling code with custom receiver name
func (g *Generator) generateFieldMarshalToBufferWithReceiver(buf *bytes.Buffer, field *AVPField, receiver string) {
	fieldName := field.FieldName

	// Skip fields with undefined AVP code
	if field.AVP.Code == 0 {
		buf.WriteString(fmt.Sprintf("\t// Skipping %s - AVP code not defined\n\n", fieldName))
		return
	}

	// Get AVP code constant name
	avpCodeConst := g.getAVPCodeConstant(field.AVP.Name)

	// Handle Grouped types differently
	if field.AVP.TypeName == "Grouped" {
		if field.Repeated {
			buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated, grouped)\n", fieldName))
			buf.WriteString(fmt.Sprintf("\tfor _, v := range %s.%s {\n", receiver, fieldName))
			buf.WriteString("\t\tif v != nil {\n")
			buf.WriteString("\t\t\tif groupedData, err := v.Marshal(); err == nil {\n")
			// Check if this grouped AVP has a vendor ID
			if field.AVP.VendorID != 0 {
				buf.WriteString(fmt.Sprintf("\t\t\t\tbuf.Write(marshalAVPWithVendor(%s, models_base.Grouped(groupedData), %v, %v, %s))\n",
					avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
			} else {
				buf.WriteString(fmt.Sprintf("\t\t\t\tbuf.Write(marshalAVP(%s, models_base.Grouped(groupedData), %v, %v))\n",
					avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt))
			}
			buf.WriteString("\t\t\t}\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t// Marshal %s (grouped)\n", fieldName))
			buf.WriteString(fmt.Sprintf("\tif %s.%s != nil {\n", receiver, fieldName))
			buf.WriteString(fmt.Sprintf("\t\tif groupedData, err := %s.%s.Marshal(); err == nil {\n", receiver, fieldName))
			// Check if this grouped AVP has a vendor ID
			if field.AVP.VendorID != 0 {
				buf.WriteString(fmt.Sprintf("\t\t\tbuf.Write(marshalAVPWithVendor(%s, models_base.Grouped(groupedData), %v, %v, %s))\n",
					avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
			} else {
				buf.WriteString(fmt.Sprintf("\t\t\tbuf.Write(marshalAVP(%s, models_base.Grouped(groupedData), %v, %v))\n",
					avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt))
			}
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n\n")
		}
	} else {
		if field.Repeated {
			buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated)\n", fieldName))
			buf.WriteString(fmt.Sprintf("\tfor _, v := range %s.%s {\n", receiver, fieldName))
			// Check if this field has a vendor ID
			if field.AVP.VendorID != 0 {
				buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVPWithVendor(%s, v, %v, %v, %s))\n",
					avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
			} else {
				buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%s, v, %v, %v))\n",
					avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt))
			}
			buf.WriteString("\t}\n\n")
		} else if !field.Required {
			buf.WriteString(fmt.Sprintf("\t// Marshal %s (optional)\n", fieldName))
			buf.WriteString(fmt.Sprintf("\tif %s.%s != nil {\n", receiver, fieldName))
			// Check if this field has a vendor ID
			if field.AVP.VendorID != 0 {
				buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVPWithVendor(%s, *%s.%s, %v, %v, %s))\n",
					avpCodeConst, receiver, fieldName, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
			} else {
				buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%s, *%s.%s, %v, %v))\n",
					avpCodeConst, receiver, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
			}
			buf.WriteString("\t}\n\n")
		} else {
			buf.WriteString(fmt.Sprintf("\t// Marshal %s (required)\n", fieldName))
			// Check if this field has a vendor ID
			if field.AVP.VendorID != 0 {
				buf.WriteString(fmt.Sprintf("\tbuf.Write(marshalAVPWithVendor(%s, %s.%s, %v, %v, %s))\n\n",
					avpCodeConst, receiver, fieldName, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
			} else {
				buf.WriteString(fmt.Sprintf("\tbuf.Write(marshalAVP(%s, %s.%s, %v, %v))\n\n",
					avpCodeConst, receiver, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
			}
		}
	}
}

// generateFieldMarshal generates marshaling code for a field (legacy, kept for compatibility)
func (g *Generator) generateFieldMarshal(buf *bytes.Buffer, field *AVPField) {
	fieldName := field.FieldName

	if field.Repeated {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tfor _, v := range m.%s {\n", fieldName))
		// Check if this field has a vendor ID
		if field.AVP.VendorID != 0 {
			buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVPWithVendor(%d, v, %v, %v, %d))\n",
				field.AVP.Code, field.AVP.Must, field.AVP.MayEncrypt, field.AVP.VendorID))
		} else {
			buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVP(%d, v, %v, %v))\n",
				field.AVP.Code, field.AVP.Must, field.AVP.MayEncrypt))
		}
		buf.WriteString("\t}\n\n")
	} else if !field.Required {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (optional)\n", fieldName))
		buf.WriteString(fmt.Sprintf("\tif m.%s != nil {\n", fieldName))
		// Check if this field has a vendor ID
		if field.AVP.VendorID != 0 {
			buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVPWithVendor(%d, *m.%s, %v, %v, %d))\n",
				field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt, field.AVP.VendorID))
		} else {
			buf.WriteString(fmt.Sprintf("\t\tavps = append(avps, marshalAVP(%d, *m.%s, %v, %v))\n",
				field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
		}
		buf.WriteString("\t}\n\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t// Marshal %s (required)\n", fieldName))
		// Check if this field has a vendor ID
		if field.AVP.VendorID != 0 {
			buf.WriteString(fmt.Sprintf("\tavps = append(avps, marshalAVPWithVendor(%d, m.%s, %v, %v, %d))\n\n",
				field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt, field.AVP.VendorID))
		} else {
			buf.WriteString(fmt.Sprintf("\tavps = append(avps, marshalAVP(%d, m.%s, %v, %v))\n\n",
				field.AVP.Code, fieldName, field.AVP.Must, field.AVP.MayEncrypt))
		}
	}
}

// generateUnmarshal generates the Unmarshal method
func (g *Generator) generateUnmarshal(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Unmarshal deserializes bytes into %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Unmarshal(data []byte) error {\n", structName))
	buf.WriteString("\tif len(data) < 20 {\n")
	buf.WriteString("\t\treturn fmt.Errorf(\"data too short for Diameter header\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Unmarshal header\n")
	buf.WriteString("\theader, err := unmarshalHeader(data[:20])\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tm.Header = *header\n\n")

	buf.WriteString("\t// Unmarshal AVPs\n")
	buf.WriteString("\tavpData := data[20:]\n")
	buf.WriteString("\tfor len(avpData) > 0 {\n")
	buf.WriteString("\t\tif len(avpData) < 8 {\n")
	buf.WriteString("\t\t\tbreak // Not enough data for AVP header\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Parse AVP header\n")
	buf.WriteString("\t\tavpCode := binary.BigEndian.Uint32(avpData[0:4])\n")
	buf.WriteString("\t\tavpFlags := avpData[4]\n")
	buf.WriteString("\t\tavpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})\n\n")

	buf.WriteString("\t\tif int(avpLength) > len(avpData) {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"AVP length exceeds remaining data\")\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Extract AVP data\n")
	buf.WriteString("\t\theaderSize := 8\n")

	// Check if any field has a vendor ID that needs to be matched
	hasVendorSpecificFields := false
	for _, field := range cmd.Fields {
		if field.AVP.VendorID != 0 {
			hasVendorSpecificFields = true
			break
		}
	}

	if hasVendorSpecificFields {
		buf.WriteString("\t\tvar vendorID uint32\n")
	}
	buf.WriteString("\t\tif avpFlags&0x80 != 0 { // V-bit set\n")
	buf.WriteString("\t\t\tif len(avpData) < 12 {\n")
	buf.WriteString("\t\t\t\treturn fmt.Errorf(\"AVP data too short for vendor ID\")\n")
	buf.WriteString("\t\t\t}\n")
	if hasVendorSpecificFields {
		buf.WriteString("\t\t\tvendorID = binary.BigEndian.Uint32(avpData[8:12])\n")
	} else {
		buf.WriteString("\t\t\t_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used\n")
	}
	buf.WriteString("\t\t\theaderSize = 12\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpDataLen := int(avpLength) - headerSize\n")
	buf.WriteString("\t\tif avpDataLen < 0 {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"invalid AVP data length\")\n")
	buf.WriteString("\t\t}\n")

	// Check if there are any valid AVP fields to parse
	hasValidFields := false
	for _, field := range cmd.Fields {
		if field.AVP.Code != 0 {
			hasValidFields = true
			break
		}
	}

	if hasValidFields {
		buf.WriteString("\t\tavpValue := avpData[headerSize : headerSize+avpDataLen]\n\n")
	} else {
		buf.WriteString("\t\t_ = avpDataLen // avpValue not needed when no fields are defined\n\n")
	}

	buf.WriteString("\t\t// Parse AVP based on code and vendor ID\n")
	buf.WriteString("\t\tswitch avpCode {\n")

	for _, field := range cmd.Fields {
		// Skip fields with code 0 (undefined AVPs)
		if field.AVP.Code == 0 {
			buf.WriteString(fmt.Sprintf("\t\t// case 0: // %s (AVP code not defined)\n", field.AVP.Name))
			continue
		}

		// Use constant instead of hardcoded number
		avpCodeConst := g.getAVPCodeConstant(field.AVP.Name)
		buf.WriteString(fmt.Sprintf("\t\tcase %s: // %s\n", avpCodeConst, field.AVP.Name))

		// Check vendor ID if it's a vendor-specific AVP
		if field.AVP.VendorID != 0 {
			buf.WriteString(fmt.Sprintf("\t\t\tif vendorID != %s {\n", g.getVendorIDConstant(field.AVP.VendorID)))
			buf.WriteString("\t\t\t\tbreak // Vendor ID mismatch\n")
			buf.WriteString("\t\t\t}\n")
		}
		if field.AVP.TypeName == "Grouped" {
			structType := g.getBaseGoTypeForField(field)
			if field.Repeated {
				buf.WriteString(fmt.Sprintf("\t\t\tgrouped := &%s{}\n", structType))
				buf.WriteString("\t\t\tif err := grouped.Unmarshal(avpValue); err == nil {\n")
				buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = append(m.%s, grouped)\n", field.FieldName, field.FieldName))
				buf.WriteString("\t\t\t}\n")
			} else {
				buf.WriteString(fmt.Sprintf("\t\t\tgrouped := &%s{}\n", structType))
				buf.WriteString("\t\t\tif err := grouped.Unmarshal(avpValue); err == nil {\n")
				buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = grouped\n", field.FieldName))
				buf.WriteString("\t\t\t}\n")
			}
		} else {
			decoder := g.getDecoder(field.AVP.TypeName)
			if field.Repeated {
				buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
				buf.WriteString("\t\t\tif err == nil {\n")
				buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = append(m.%s, val.(%s))\n",
					field.FieldName, field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
				buf.WriteString("\t\t\t}\n")
			} else if !field.Required {
				buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
				buf.WriteString("\t\t\tif err == nil {\n")
				buf.WriteString(fmt.Sprintf("\t\t\t\tv := val.(%s)\n", g.getBaseGoType(field.AVP.TypeName)))
				buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = &v\n", field.FieldName))
				buf.WriteString("\t\t\t}\n")
			} else {
				buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
				buf.WriteString("\t\t\tif err == nil {\n")
				buf.WriteString(fmt.Sprintf("\t\t\t\tm.%s = val.(%s)\n",
					field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
				buf.WriteString("\t\t\t}\n")
			}
		}
	}

	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Move to next AVP (with padding)\n")
	buf.WriteString("\t\tpaddedLength := int(avpLength)\n")
	buf.WriteString("\t\tif paddedLength%4 != 0 {\n")
	buf.WriteString("\t\t\tpaddedLength += 4 - (paddedLength % 4)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tif paddedLength > len(avpData) {\n")
	buf.WriteString("\t\t\tbreak\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpData = avpData[paddedLength:]\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n\n")
}

// getDecoder returns the decoder function name for a type
func (g *Generator) getDecoder(typeName string) string {
	switch typeName {
	case "Unsigned32":
		return "models_base.DecodeUnsigned32"
	case "Unsigned64":
		return "models_base.DecodeUnsigned64"
	case "Integer32":
		return "models_base.DecodeInteger32"
	case "Integer64":
		return "models_base.DecodeInteger64"
	case "Float32":
		return "models_base.DecodeFloat32"
	case "Float64":
		return "models_base.DecodeFloat64"
	case "OctetString":
		return "models_base.DecodeOctetString"
	case "UTF8String":
		return "models_base.DecodeUTF8String"
	case "DiameterIdentity":
		return "models_base.DecodeDiameterIdentity"
	case "DiameterURI":
		return "models_base.DecodeDiameterURI"
	case "Enumerated":
		return "models_base.DecodeEnumerated"
	case "Address":
		return "models_base.DecodeAddress"
	case "Time":
		return "models_base.DecodeTime"
	case "IPFilterRule":
		return "models_base.DecodeIPFilterRule"
	case "QoSFilterRule":
		return "models_base.DecodeQoSFilterRule"
	case "Grouped":
		return "models_base.DecodeGrouped"
	default:
		return "models_base.DecodeOctetString"
	}
}

// generateLen generates the Len method
func (g *Generator) generateLen(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// Len returns the total length of the %s message\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) Len() int {\n", structName))
	buf.WriteString("\tdata, _ := m.Marshal()\n")
	buf.WriteString("\treturn len(data)\n")
	buf.WriteString("}\n\n")
}

// generateString generates the String method
func (g *Generator) generateString(buf *bytes.Buffer, cmd *CommandDefinition, structName string) {
	buf.WriteString(fmt.Sprintf("// String returns a string representation of %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (m *%s) String() string {\n", structName))
	buf.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(\"%s{", structName))

	for i, field := range cmd.Fields {
		if i > 0 {
			buf.WriteString(", ")
		}
		buf.WriteString(fmt.Sprintf("%s:%%v", field.FieldName))
	}
	buf.WriteString("}\"")

	for i, field := range cmd.Fields {
		if i == 0 {
			buf.WriteString(", m.")
		} else {
			buf.WriteString(", m.")
		}
		buf.WriteString(field.FieldName)
	}

	buf.WriteString(")\n")
	buf.WriteString("}\n\n")
}

// generateTypeDefinitions generates type definitions for DiameterHeader and CommandFlags
func (g *Generator) generateTypeDefinitions(buf *bytes.Buffer) {
	buf.WriteString(`// CommandFlags represents Diameter command header flags
type CommandFlags struct {
	Request       bool // R-bit
	Proxiable     bool // P-bit
	Error         bool // E-bit
	Retransmitted bool // T-bit
}

// DiameterHeader represents the Diameter message header (20 bytes)
type DiameterHeader struct {
	Version       uint8        // 1 byte - Must be 1
	Length        uint32       // 3 bytes - Total message length
	Flags         CommandFlags // 1 byte
	CommandCode   uint32       // 3 bytes
	ApplicationID uint32       // 4 bytes
	HopByHopID    uint32       // 4 bytes
	EndToEndID    uint32       // 4 bytes
}

`)
}

// generateHelperFunctions generates common helper functions
func (g *Generator) generateHelperFunctions(buf *bytes.Buffer) {
	helperTemplate := `
// Helper functions

// marshalHeader serializes a Diameter header
func marshalHeader(h *DiameterHeader) []byte {
	b := make([]byte, 20)

	b[0] = h.Version

	// Message Length (3 bytes)
	binary.BigEndian.PutUint32(b[0:4], h.Length)
	b[0] = h.Version // Restore version after length write

	// Command Flags
	var flags byte
	if h.Flags.Request {
		flags |= 0x80
	}
	if h.Flags.Proxiable {
		flags |= 0x40
	}
	if h.Flags.Error {
		flags |= 0x20
	}
	if h.Flags.Retransmitted {
		flags |= 0x10
	}
	b[4] = flags

	// Command Code (3 bytes)
	binary.BigEndian.PutUint32(b[4:8], h.CommandCode)
	b[4] = flags // Restore flags

	// Application ID
	binary.BigEndian.PutUint32(b[8:12], h.ApplicationID)

	// Hop-by-Hop Identifier
	binary.BigEndian.PutUint32(b[12:16], h.HopByHopID)

	// End-to-End Identifier
	binary.BigEndian.PutUint32(b[16:20], h.EndToEndID)

	return b
}

// unmarshalHeader deserializes a Diameter header
func unmarshalHeader(data []byte) (*DiameterHeader, error) {
	if len(data) < 20 {
		return nil, fmt.Errorf("data too short for Diameter header")
	}

	h := &DiameterHeader{}
	h.Version = data[0]

	// Message Length (3 bytes, big-endian)
	h.Length = binary.BigEndian.Uint32([]byte{0, data[1], data[2], data[3]})

	// Command Flags
	flags := data[4]
	h.Flags.Request = (flags & 0x80) != 0
	h.Flags.Proxiable = (flags & 0x40) != 0
	h.Flags.Error = (flags & 0x20) != 0
	h.Flags.Retransmitted = (flags & 0x10) != 0

	// Command Code (3 bytes, big-endian)
	h.CommandCode = binary.BigEndian.Uint32([]byte{0, data[5], data[6], data[7]})

	// Application ID
	h.ApplicationID = binary.BigEndian.Uint32(data[8:12])

	// Hop-by-Hop Identifier
	h.HopByHopID = binary.BigEndian.Uint32(data[12:16])

	// End-to-End Identifier
	h.EndToEndID = binary.BigEndian.Uint32(data[16:20])

	return h, nil
}

// marshalAVP serializes an AVP
func marshalAVP(code uint32, data models_base.Type, mandatory, protected bool) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Calculate header size
	headerSize := 8 // No vendor ID

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// marshalAVPWithVendor serializes an AVP with optional vendor ID
func marshalAVPWithVendor(code uint32, data models_base.Type, mandatory, protected bool, vendorID uint32) []byte {
	// Serialize data
	serialized := data.Serialize()

	// Determine if we need vendor ID in header
	hasVendor := vendorID != 0

	// Calculate header size
	headerSize := 8
	if hasVendor {
		headerSize = 12 // With vendor ID
	}

	// Calculate total length
	totalLen := headerSize + len(serialized)

	// Create buffer
	buf := make([]byte, headerSize)

	// AVP Code
	binary.BigEndian.PutUint32(buf[0:4], code)

	// AVP Flags
	var flags byte
	if hasVendor {
		flags |= 0x80 // V-bit
	}
	if mandatory {
		flags |= 0x40 // M-bit
	}
	if protected {
		flags |= 0x20 // P-bit
	}
	buf[4] = flags

	// AVP Length (3 bytes)
	binary.BigEndian.PutUint32(buf[4:8], uint32(totalLen))
	buf[4] = flags // Restore flags

	// Vendor ID (if needed)
	if hasVendor {
		binary.BigEndian.PutUint32(buf[8:12], vendorID)
	}

	// Append data
	buf = append(buf, serialized...)

	// Add padding to 32-bit boundary
	padding := (4 - (len(buf) % 4)) % 4
	for i := 0; i < padding; i++ {
		buf = append(buf, 0)
	}

	return buf
}

// Pointer helper functions for grouped AVP field assignments in tests
func ptrUTF8String(s string) *models_base.UTF8String {
	v := models_base.UTF8String(s)
	return &v
}

func ptrOctetString(b []byte) *models_base.OctetString {
	v := models_base.OctetString(b)
	return &v
}

func ptrUnsigned32(u uint32) *models_base.Unsigned32 {
	v := models_base.Unsigned32(u)
	return &v
}

func ptrUnsigned64(u uint64) *models_base.Unsigned64 {
	v := models_base.Unsigned64(u)
	return &v
}

func ptrEnumerated(e uint32) *models_base.Enumerated {
	v := models_base.Enumerated(e)
	return &v
}

func ptrDiameterIdentity(d string) *models_base.DiameterIdentity {
	v := models_base.DiameterIdentity(d)
	return &v
}

func ptrAddress(a models_base.Address) *models_base.Address {
	return &a
}

func ptrTime(t models_base.Time) *models_base.Time {
	return &t
}

func ptrFloat32(f float32) *models_base.Float32 {
	v := models_base.Float32(f)
	return &v
}

func ptrFloat64(f float64) *models_base.Float64 {
	v := models_base.Float64(f)
	return &v
}
`
	buf.WriteString(helperTemplate)
}

// toConstantCase converts a name to CONSTANT_CASE
func toConstantCase(s string) string {
	// Replace dashes with underscores
	s = strings.ReplaceAll(s, "-", "")

	// Insert underscores before uppercase letters
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, r)
		} else {
			result = append(result, r)
		}
	}

	return strings.ToUpper(string(result))
}

// getAVPCodeConstant returns the constant name for an AVP code
func (g *Generator) getAVPCodeConstant(avpName string) string {
	constName := toConstantCase(avpName)
	return fmt.Sprintf("AVPCode%s", constName)
}

// getVendorIDConstant returns the constant name for a vendor ID
func (g *Generator) getVendorIDConstant(vendorID uint32) string {
	if vendorID == 0 {
		return "0"
	}
	// For now, just return the numeric value
	// Could be enhanced to use named constants like VENDOR_ID_3GPP
	return fmt.Sprintf("%d", vendorID)
}

// GenerateTest generates comprehensive test code
func (g *Generator) GenerateTest() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"net\"\n")
	buf.WriteString("\t\"os\"\n")
	buf.WriteString("\t\"path/filepath\"\n")
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString("\t\"time\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/google/gopacket\"\n")
	buf.WriteString("\t\"github.com/google/gopacket/layers\"\n")
	buf.WriteString("\t\"github.com/google/gopacket/pcapgo\"\n")
	buf.WriteString("\t\"github.com/hsdfat/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")

	// Generate pcap helper functions
	g.generatePcapHelpers(&buf)

	// Generate test functions for each command
	for _, cmd := range g.Parser.Commands {
		// Generate comprehensive unit tests
		g.generateCommandUnitTest(&buf, cmd)
		// Generate validation test
		g.generateCommandValidationTest(&buf, cmd)
		// Generate validation test for missing required fields
		g.generateCommandValidationMissingFieldsTest(&buf, cmd)
		// Generate PCAP test
		g.generateCommandPcapTest(&buf, cmd)
		// Generate Marshal/Unmarshal roundtrip test
		g.generateCommandRoundtripTest(&buf, cmd)
		// Generate benchmark tests
		g.generateCommandBenchmarkTest(&buf, cmd)
	}

	// Generate paired request-response PCAP tests
	g.generatePairedPcapTests(&buf)

	return buf.String(), nil
}

// generatePcapHelpers generates helper functions for writing pcap files
func (g *Generator) generatePcapHelpers(buf *bytes.Buffer) {
	buf.WriteString(`// writeDiameterToPcap writes a Diameter message to a pcap file with proper network layers
func writeDiameterToPcap(filename string, diameterData []byte, srcIP, dstIP net.IP, port int) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	// Create packet layers
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(port),
		DstPort: layers.TCPPort(3868), // Diameter default port
		Seq:     1000,
		Ack:     0,
		SYN:     false,
		ACK:     true,
		PSH:     true,
		Window:  65535,
	}

	// Set TCP options for better compatibility
	tcp.Options = []layers.TCPOption{
		{
			OptionType:   layers.TCPOptionKindMSS,
			OptionLength: 4,
			OptionData:   []byte{0x05, 0xb4}, // MSS = 1460
		},
		{
			OptionType: layers.TCPOptionKindNop,
		},
		{
			OptionType:   layers.TCPOptionKindWindowScale,
			OptionLength: 3,
			OptionData:   []byte{0x07}, // Window scale = 7
		},
	}

	// Calculate TCP checksum
	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize the packet
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	// Create payload (Diameter data)
	payload := gopacket.Payload(diameterData)

	// Serialize all layers
	err = gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet to pcap file
	ci := gopacket.CaptureInfo{
		Timestamp:     time.Now(),
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	err = w.WritePacket(ci, packetBuf.Bytes())
	if err != nil {
		return err
	}

	return nil
}

// writePacketToPcap writes a single packet to an existing pcap writer
func writePacketToPcap(w *pcapgo.Writer, diameterData []byte, srcIP, dstIP net.IP, srcPort, dstPort int, seq, ack uint32, timestamp time.Time) error {
	// Ethernet layer
	ethernet := &layers.Ethernet{
		SrcMAC:       net.HardwareAddr{0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
		DstMAC:       net.HardwareAddr{0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e},
		EthernetType: layers.EthernetTypeIPv4,
	}

	// IP layer
	ip := &layers.IPv4{
		Version:  4,
		IHL:      5,
		TTL:      64,
		Protocol: layers.IPProtocolTCP,
		SrcIP:    srcIP,
		DstIP:    dstIP,
	}

	// TCP layer
	tcp := &layers.TCP{
		SrcPort: layers.TCPPort(srcPort),
		DstPort: layers.TCPPort(dstPort),
		Seq:     seq,
		Ack:     ack,
		SYN:     ack == 0 && seq == 1000, // Only for SYN packet
		ACK:     ack > 0,                 // ACK if we have acknowledgment number
		PSH:     true,                    // Push flag for data packets
		Window:  65535,
	}

	tcp.SetNetworkLayerForChecksum(ip)

	// Serialize
	packetBuf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: true,
	}

	payload := gopacket.Payload(diameterData)

	err := gopacket.SerializeLayers(packetBuf, opts,
		ethernet,
		ip,
		tcp,
		payload,
	)
	if err != nil {
		return err
	}

	// Write packet
	ci := gopacket.CaptureInfo{
		Timestamp:     timestamp,
		CaptureLength: len(packetBuf.Bytes()),
		Length:        len(packetBuf.Bytes()),
	}

	return w.WritePacket(ci, packetBuf.Bytes())
}

// writeDiameterPairToPcap writes a request-response pair to a single pcap file
func writeDiameterPairToPcap(filename string, requestData, responseData []byte, clientIP, serverIP net.IP) error {
	// Create directory if it doesn't exist
	dir := filepath.Dir(filename)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	// Create the pcap file
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Create pcap writer
	w := pcapgo.NewWriter(f)
	err = w.WriteFileHeader(65536, layers.LinkTypeEthernet)
	if err != nil {
		return err
	}

	baseTime := time.Now()
	clientPort := 54321
	serverPort := 3868

	// Write request packet (client -> server)
	err = writePacketToPcap(w, requestData, clientIP, serverIP, clientPort, serverPort, 1000, 1, baseTime)
	if err != nil {
		return err
	}

	// Write response packet (server -> client) with small delay
	responseTime := baseTime.Add(10 * time.Millisecond)
	err = writePacketToPcap(w, responseData, serverIP, clientIP, serverPort, clientPort, 1, 1000+uint32(len(requestData)), responseTime)
	if err != nil {
		return err
	}

	return nil
}

`)
}

// generateCommandTest generates a test function for a command that writes to pcap
func (g *Generator) generateCommandTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))
	testFuncName := fmt.Sprintf("Test%sToPcap", structName)
	pcapFileName := fmt.Sprintf("test_%s.pcap", strings.ToLower(strings.ReplaceAll(cmd.Abbreviation, "-", "_")))

	buf.WriteString(fmt.Sprintf("// %s tests writing a %s message to a pcap file\n", testFuncName, cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testFuncName))
	buf.WriteString("\t// Create testdata directory if it doesn't exist\n")
	buf.WriteString("\tif err := os.MkdirAll(\"testdata\", 0755); err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to create testdata directory: %v\", err)\n")
	buf.WriteString("\t}\n\n")
	buf.WriteString("\t// Create a pcap file in testdata folder\n")
	buf.WriteString(fmt.Sprintf("\tpcapFile := filepath.Join(\"testdata\", \"%s\")\n", pcapFileName))
	buf.WriteString("\tif !keepPcapFiles {\n")
	buf.WriteString("\t\tdefer os.Remove(pcapFile) // Clean up after test\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\t// Create and configure a %s message\n", cmd.Abbreviation))
	buf.WriteString(fmt.Sprintf("\tmsg := New%s()\n\n", structName))

	// Generate field assignments for required fields
	cmdName := cmd.Name
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignment(buf, field, &cmdName)
		}
	}

	buf.WriteString("\t// Set header identifiers\n")
	buf.WriteString("\tmsg.Header.HopByHopID = 0x12345678\n")
	buf.WriteString("\tmsg.Header.EndToEndID = 0x87654321\n\n")

	buf.WriteString("\t// Marshal the Diameter message\n")
	buf.WriteString("\tdiameterData, err := msg.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString(fmt.Sprintf("\t\tt.Fatalf(\"Failed to marshal %s: %%v\", err)\n", cmd.Abbreviation))
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Write to pcap file\n")
	buf.WriteString("\terr = writeDiameterToPcap(pcapFile, diameterData, net.ParseIP(\"192.168.1.100\"), net.ParseIP(\"192.168.1.1\"), 3868)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to write pcap file: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Verify file was created\n")
	buf.WriteString("\tfileInfo, err := os.Stat(pcapFile)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Pcap file was not created: %v\", err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif fileInfo.Size() == 0 {\n")
	buf.WriteString("\t\tt.Fatal(\"Pcap file is empty\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\tt.Logf(\"Successfully created pcap file: %%s (%%d bytes)\", pcapFile, fileInfo.Size())\n"))
	buf.WriteString("\tt.Logf(\"You can open this file in Wireshark to view the Diameter message\")\n")
	buf.WriteString("}\n\n")
}

// generateTestFieldAssignment generates code to assign test values to a field (uses "msg" variable)
func (g *Generator) generateTestFieldAssignment(buf *bytes.Buffer, field *AVPField, cmdName *string) {
	g.generateTestFieldAssignmentWithVar(buf, field, cmdName, "msg", "\t\t")
}

// generateTestFieldAssignmentWithAllChildren generates code to assign test values with ALL child fields populated
func (g *Generator) generateTestFieldAssignmentWithAllChildren(buf *bytes.Buffer, field *AVPField, cmdName *string, varName string, indent string) {
	fieldName := field.FieldName
	isRepeated := field.Repeated
	isOptional := !field.Required

	switch field.AVP.TypeName {
	case "Grouped":
		// Generate test code for grouped AVP with ALL nested fields populated
		if field.AVP.GroupedFields != nil && len(field.AVP.GroupedFields) > 0 {
			groupTypeName := toCamelCase(strings.ReplaceAll(field.AVP.Name, "-", "_"))
			if isRepeated {
				buf.WriteString(fmt.Sprintf("%s%s.%s = []*%s{\n", indent, varName, fieldName, groupTypeName))
				buf.WriteString(fmt.Sprintf("%s\t&%s{\n", indent, groupTypeName))
			} else {
				buf.WriteString(fmt.Sprintf("%s%s.%s = &%s{\n", indent, varName, fieldName, groupTypeName))
			}

			// Generate field assignments for ALL nested fields (not just first few)
			for _, nestedField := range field.AVP.GroupedFields {
				nestedFieldName := nestedField.FieldName
				nestedIsOptional := !nestedField.Required
				nestedIsRepeated := nestedField.Repeated

				switch nestedField.AVP.TypeName {
				case "UTF8String":
					value := "\"452040000000010\""
					if nestedField.AVP.Name == "IMEI" {
						value = "\"123456789012345\""
					} else if nestedField.AVP.Name == "Software-Version" {
						value = "\"01\""
					} else if strings.Contains(strings.ToLower(nestedField.AVP.Name), "session") {
						value = "\"client.example.com;1234567890;1\""
					} else if strings.Contains(strings.ToLower(nestedField.AVP.Name), "product") {
						value = "\"TestProduct/1.0\""
					}
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.UTF8String{models_base.UTF8String(%s)},\n", indent, nestedFieldName, value))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUTF8String(%s),\n", indent, nestedFieldName, value))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.UTF8String(%s),\n", indent, nestedFieldName, value))
					}
				case "OctetString":
					value := "[]byte{0x01, 0x02, 0x03}"
					if strings.Contains(strings.ToLower(nestedField.AVP.Name), "meid") {
						value = "[]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07}"
					} else if strings.Contains(strings.ToLower(nestedField.AVP.Name), "plmn") {
						value = "[]byte{0x00, 0xF1, 0x10}" // Example PLMN ID
					}
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.OctetString{models_base.OctetString(%s)},\n", indent, nestedFieldName, value))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrOctetString(%s),\n", indent, nestedFieldName, value))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.OctetString(%s),\n", indent, nestedFieldName, value))
					}
				case "DiameterIdentity":
					value := "\"client.example.com\""
					if strings.Contains(strings.ToLower(nestedField.AVP.Name), "destination") {
						value = "\"server.example.com\""
					}
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.DiameterIdentity{models_base.DiameterIdentity(%s)},\n", indent, nestedFieldName, value))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrDiameterIdentity(%s),\n", indent, nestedFieldName, value))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.DiameterIdentity(%s),\n", indent, nestedFieldName, value))
					}
				case "Unsigned32":
					value := "1"
					if strings.Contains(strings.ToLower(nestedField.AVP.Name), "vendor") {
						value = "10415" // 3GPP
					} else if strings.Contains(strings.ToLower(nestedField.AVP.Name), "auth") && strings.Contains(strings.ToLower(nestedField.AVP.Name), "application") {
						value = "16777252" // S13 application ID
					} else if strings.Contains(strings.ToLower(nestedField.AVP.Name), "acct") && strings.Contains(strings.ToLower(nestedField.AVP.Name), "application") {
						value = "1" // Accounting application ID
					}
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.Unsigned32{models_base.Unsigned32(%s)},\n", indent, nestedFieldName, value))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUnsigned32(%s),\n", indent, nestedFieldName, value))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.Unsigned32(%s),\n", indent, nestedFieldName, value))
					}
				case "Unsigned64":
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.Unsigned64{models_base.Unsigned64(1)},\n", indent, nestedFieldName))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUnsigned64(1),\n", indent, nestedFieldName))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.Unsigned64(1),\n", indent, nestedFieldName))
					}
				case "Enumerated":
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.Enumerated{models_base.Enumerated(1)},\n", indent, nestedFieldName))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrEnumerated(1),\n", indent, nestedFieldName))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.Enumerated(1),\n", indent, nestedFieldName))
					}
				case "Address":
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.Address{models_base.Address(net.ParseIP(\"192.168.1.100\"))},\n", indent, nestedFieldName))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrAddress(models_base.Address(net.ParseIP(\"192.168.1.100\"))),\n", indent, nestedFieldName))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.Address(net.ParseIP(\"192.168.1.100\")),\n", indent, nestedFieldName))
					}
				case "Time":
					if nestedIsRepeated {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: []models_base.Time{models_base.Time(time.Now())},\n", indent, nestedFieldName))
					} else if nestedIsOptional {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrTime(models_base.Time(time.Now())),\n", indent, nestedFieldName))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: models_base.Time(time.Now()),\n", indent, nestedFieldName))
					}
				case "Grouped":
					// Handle nested grouped types
					if nestedField.AVP.GroupedFields != nil && len(nestedField.AVP.GroupedFields) > 0 {
						nestedGroupTypeName := toCamelCase(strings.ReplaceAll(nestedField.AVP.Name, "-", "_"))
						if nestedIsRepeated {
							buf.WriteString(fmt.Sprintf("%s\t\t%s: []*%s{\n", indent, nestedFieldName, nestedGroupTypeName))
							buf.WriteString(fmt.Sprintf("%s\t\t\t&%s{\n", indent, nestedGroupTypeName))
						} else {
							buf.WriteString(fmt.Sprintf("%s\t\t%s: &%s{\n", indent, nestedFieldName, nestedGroupTypeName))
						}

						// Generate field assignments for nested grouped fields
						for _, deepNestedField := range nestedField.AVP.GroupedFields {
							deepNestedFieldName := deepNestedField.FieldName
							deepNestedIsOptional := !deepNestedField.Required
							deepNestedIsRepeated := deepNestedField.Repeated

							switch deepNestedField.AVP.TypeName {
							case "OctetString":
								value := "[]byte{0x01, 0x02, 0x03}"
								// Special cases for authentication vectors
								if strings.Contains(strings.ToLower(deepNestedField.AVP.Name), "rand") {
									value = "[]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10}"
								} else if strings.Contains(strings.ToLower(deepNestedField.AVP.Name), "xres") {
									value = "[]byte{0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18}"
								} else if strings.Contains(strings.ToLower(deepNestedField.AVP.Name), "autn") {
									value = "[]byte{0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30}"
								} else if strings.Contains(strings.ToLower(deepNestedField.AVP.Name), "kasme") {
									value = "[]byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50}"
								} else if strings.Contains(strings.ToLower(deepNestedField.AVP.Name), "sres") {
									value = "[]byte{0x11, 0x12, 0x13, 0x14}"
								} else if strings.ToLower(deepNestedField.AVP.Name) == "kc" {
									value = "[]byte{0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28}"
								} else if strings.Contains(strings.ToLower(deepNestedField.AVP.Name), "confidentiality") || strings.Contains(strings.ToLower(deepNestedField.AVP.Name), "integrity") {
									value = "[]byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40}"
								}
								if deepNestedIsRepeated {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: []models_base.OctetString{models_base.OctetString(%s)},\n", indent, deepNestedFieldName, value))
								} else if deepNestedIsOptional {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: ptrOctetString(%s),\n", indent, deepNestedFieldName, value))
								} else {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: models_base.OctetString(%s),\n", indent, deepNestedFieldName, value))
								}
							case "Unsigned32":
								value := "1"
								if deepNestedIsRepeated {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: []models_base.Unsigned32{models_base.Unsigned32(%s)},\n", indent, deepNestedFieldName, value))
								} else if deepNestedIsOptional {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: ptrUnsigned32(%s),\n", indent, deepNestedFieldName, value))
								} else {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: models_base.Unsigned32(%s),\n", indent, deepNestedFieldName, value))
								}
							case "UTF8String":
								value := "\"test\""
								if deepNestedIsRepeated {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: []models_base.UTF8String{models_base.UTF8String(%s)},\n", indent, deepNestedFieldName, value))
								} else if deepNestedIsOptional {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: ptrUTF8String(%s),\n", indent, deepNestedFieldName, value))
								} else {
									buf.WriteString(fmt.Sprintf("%s\t\t\t\t%s: models_base.UTF8String(%s),\n", indent, deepNestedFieldName, value))
								}
							default:
								// For unknown types, add a comment
								buf.WriteString(fmt.Sprintf("%s\t\t\t\t// %s: nil, // (type: %s) needs to be set\n", indent, deepNestedFieldName, deepNestedField.AVP.TypeName))
							}
						}

						if nestedIsRepeated {
							buf.WriteString(fmt.Sprintf("%s\t\t\t},\n", indent))
							buf.WriteString(fmt.Sprintf("%s\t\t},\n", indent))
						} else {
							buf.WriteString(fmt.Sprintf("%s\t\t},\n", indent))
						}
					} else {
						// For grouped without fields, add a comment
						buf.WriteString(fmt.Sprintf("%s\t\t// %s: nil, // (type: %s) needs to be set\n", indent, nestedFieldName, nestedField.AVP.TypeName))
					}
				default:
					// For unknown types, add a comment
					buf.WriteString(fmt.Sprintf("%s\t\t// %s: nil, // (type: %s) needs to be set\n", indent, nestedFieldName, nestedField.AVP.TypeName))
				}
			}

			if isRepeated {
				buf.WriteString(fmt.Sprintf("%s\t},\n", indent))
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			} else {
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			}
		}
	case "DiameterIdentity":
		value := "\"client.example.com\""
		if strings.Contains(strings.ToLower(*cmdName), "answer") {
			value = "\"server.example.com\""
		} else if strings.Contains(fieldName, "Destination") {
			value = "\"server.example.com\""
		}
		if isRepeated {
			// Repeated fields use slice literals
			buf.WriteString(fmt.Sprintf("%s%s.%s = []models_base.DiameterIdentity{models_base.DiameterIdentity(%s)}\n", indent, varName, fieldName, value))
		} else if isOptional {
			// Optional fields use pointer helpers
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrDiameterIdentity(%s)\n", indent, varName, fieldName, value))
		} else {
			// Required fields use direct values
			buf.WriteString(fmt.Sprintf("%s%s.%s = models_base.DiameterIdentity(%s)\n", indent, varName, fieldName, value))
		}
	case "UTF8String":
		value := "\"452040000000010\""
		if fieldName == "SessionId" || strings.Contains(fieldName, "Session") {
			value = "\"client.example.com;1234567890;1\""
		} else if strings.Contains(fieldName, "Product") {
			value = "\"TestProduct/1.0\""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("%s%s.%s = []models_base.UTF8String{models_base.UTF8String(%s)}\n", indent, varName, fieldName, value))
		} else if isOptional {
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrUTF8String(%s)\n", indent, varName, fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("%s%s.%s = models_base.UTF8String(%s)\n", indent, varName, fieldName, value))
		}
	case "OctetString":
		value := "[]byte{0x01, 0x02, 0x03}"
		if strings.Contains(strings.ToLower(fieldName), "plmn") {
			value = "[]byte{0x00, 0xF1, 0x10}" // Example PLMN ID
		} else if strings.Contains(strings.ToLower(fieldName), "imsi") {
			value = "[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}" // Example IMSI
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("%s%s.%s = []models_base.OctetString{models_base.OctetString(%s)}\n", indent, varName, fieldName, value))
		} else if isOptional {
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrOctetString(%s)\n", indent, varName, fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("%s%s.%s = models_base.OctetString(%s)\n", indent, varName, fieldName, value))
		}
	case "Unsigned32":
		var value string
		var comment string
		if fieldName == "ResultCode" || strings.Contains(fieldName, "Result") {
			value = "2001"
			comment = " // DIAMETER_SUCCESS"
		} else if fieldName == "VendorId" || strings.Contains(fieldName, "Vendor") {
			value = "10415"
			comment = " // 3GPP"
		} else {
			value = "1"
			comment = ""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("%s%s.%s = []models_base.Unsigned32{models_base.Unsigned32(%s)}%s\n", indent, varName, fieldName, value, comment))
		} else if isOptional {
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrUnsigned32(%s)%s\n", indent, varName, fieldName, value, comment))
		} else {
			buf.WriteString(fmt.Sprintf("%s%s.%s = models_base.Unsigned32(%s)%s\n", indent, varName, fieldName, value, comment))
		}
	case "Unsigned64":
		if isRepeated {
			buf.WriteString(fmt.Sprintf("%s%s.%s = []models_base.Unsigned64{models_base.Unsigned64(1)}\n", indent, varName, fieldName))
		} else if isOptional {
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrUnsigned64(1)\n", indent, varName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf("%s%s.%s = models_base.Unsigned64(1)\n", indent, varName, fieldName))
		}
	case "Enumerated":
		value := "1"
		if isRepeated {
			buf.WriteString(fmt.Sprintf("%s%s.%s = []models_base.Enumerated{models_base.Enumerated(%s)}\n", indent, varName, fieldName, value))
		} else if isOptional {
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrEnumerated(%s)\n", indent, varName, fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("%s%s.%s = models_base.Enumerated(%s)\n", indent, varName, fieldName, value))
		}
	case "Address":
		if isOptional {
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrAddress(models_base.Address(net.ParseIP(\"192.168.1.100\")))\n", indent, varName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf("%s%s.%s = []models_base.Address{\n", indent, varName, fieldName))
			buf.WriteString(fmt.Sprintf("%s\tmodels_base.Address(net.ParseIP(\"192.168.1.100\")),\n", indent))
			buf.WriteString(fmt.Sprintf("%s}\n", indent))
		}
	case "Time":
		if isOptional {
			buf.WriteString(fmt.Sprintf("%s%s.%s = ptrTime(models_base.Time(time.Now()))\n", indent, varName, fieldName))
		} else {
			buf.WriteString(fmt.Sprintf("%s%s.%s = models_base.Time(time.Now())\n", indent, varName, fieldName))
		}
	default:
		// For other types, add a comment
		buf.WriteString(fmt.Sprintf("%s// %s.%s needs to be set manually (type: %s)\n", indent, varName, fieldName, field.AVP.TypeName))
	}
}

// generateTestFieldAssignmentWithVar generates code to assign test values to a field with custom variable name and indentation
func (g *Generator) generateTestFieldAssignmentWithVar(buf *bytes.Buffer, field *AVPField, cmdName *string, varName string, indent string) {
	fieldName := field.FieldName
	isRepeated := field.Repeated

	switch field.AVP.TypeName {
	case "DiameterIdentity":
		value := "\"client.example.com\""
		if strings.Contains(strings.ToLower(*cmdName), "answer") {
			value = "\"server.example.com\""
		} else if strings.Contains(fieldName, "Destination") {
			value = "\"server.example.com\""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\t%s.%s = []models_base.DiameterIdentity{models_base.DiameterIdentity(%s)}\n", varName, fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s.%s = models_base.DiameterIdentity(%s)\n", varName, fieldName, value))
		}
	case "UTF8String":
		value := "\"452040000000010\""
		if fieldName == "SessionId" || strings.Contains(fieldName, "Session") {
			value = "\"client.example.com;1234567890;1\""
		} else if strings.Contains(fieldName, "Product") {
			value = "\"TestProduct/1.0\""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\t%s.%s = []models_base.UTF8String{models_base.UTF8String(%s)}\n", varName, fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s.%s = models_base.UTF8String(%s)\n", varName, fieldName, value))
		}
	case "Address":
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\t%s.%s = []models_base.Address{\n", varName, fieldName))
		} else {
			// Single address - this shouldn't happen for required fields, but handle it
			buf.WriteString(fmt.Sprintf("\t%s.%s = []models_base.Address{\n", varName, fieldName))
		}
		buf.WriteString("\t\tmodels_base.Address(net.ParseIP(\"192.168.1.100\")),\n")
		buf.WriteString("\t}\n")
	case "OctetString":
		// Generate appropriate test data for OctetString
		value := "[]byte{0x01, 0x02, 0x03}"
		if strings.Contains(strings.ToLower(fieldName), "plmn") {
			value = "[]byte{0x00, 0xF1, 0x10}" // Example PLMN ID (MCC=001, MNC=01)
		} else if strings.Contains(strings.ToLower(fieldName), "imsi") {
			value = "[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11}" // Example IMSI
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\t%s.%s = []models_base.OctetString{models_base.OctetString(%s)}\n", varName, fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s.%s = models_base.OctetString(%s)\n", varName, fieldName, value))
		}
	case "Unsigned32":
		var value string
		var comment string
		if fieldName == "ResultCode" || strings.Contains(fieldName, "Result") {
			value = "2001"
			comment = " // DIAMETER_SUCCESS"
		} else if fieldName == "VendorId" || strings.Contains(fieldName, "Vendor") {
			value = "10415"
			comment = " // 3GPP"
		} else {
			value = "1"
			comment = ""
		}
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\t%s.%s = []models_base.Unsigned32{models_base.Unsigned32(%s)}%s\n", varName, fieldName, value, comment))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s.%s = models_base.Unsigned32(%s)%s\n", varName, fieldName, value, comment))
		}
	case "Enumerated":
		value := "1"
		if isRepeated {
			buf.WriteString(fmt.Sprintf("\t%s.%s = []models_base.Enumerated{models_base.Enumerated(%s)}\n", varName, fieldName, value))
		} else {
			buf.WriteString(fmt.Sprintf("\t%s.%s = models_base.Enumerated(%s)\n", varName, fieldName, value))
		}
	case "Grouped":
		// Generate test code for grouped AVP with nested fields
		if field.AVP.GroupedFields != nil && len(field.AVP.GroupedFields) > 0 {
			groupTypeName := toCamelCase(strings.ReplaceAll(field.AVP.Name, "-", "_"))
			if isRepeated {
				buf.WriteString(fmt.Sprintf("\t%s.%s = []*%s{\n", varName, fieldName, groupTypeName))
				buf.WriteString(fmt.Sprintf("\t\t&%s{\n", groupTypeName))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s.%s = &%s{\n", varName, fieldName, groupTypeName))
			}

			// Generate field assignments for nested fields
			for i, nestedField := range field.AVP.GroupedFields {
				// Use the FieldName which is already properly converted from snake_case to CamelCase
				nestedFieldName := nestedField.FieldName
				switch nestedField.AVP.TypeName {
				case "UTF8String":
					if nestedField.AVP.Name == "IMEI" {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUTF8String(\"123456789012345\"),\n", indent, nestedFieldName))
					} else if nestedField.AVP.Name == "Software-Version" {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUTF8String(\"01\"),\n", indent, nestedFieldName))
					} else {
						buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUTF8String(\"test\"),\n", indent, nestedFieldName))
					}
				case "OctetString":
					buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrOctetString([]byte{0x01, 0x02, 0x03}),\n", indent, nestedFieldName))
				case "Unsigned32":
					buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUnsigned32(1),\n", indent, nestedFieldName))
				case "Unsigned64":
					buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrUnsigned64(1),\n", indent, nestedFieldName))
				case "Enumerated":
					buf.WriteString(fmt.Sprintf("%s\t\t%s: ptrEnumerated(1),\n", indent, nestedFieldName))
				default:
					// For unknown types, add a comment
					buf.WriteString(fmt.Sprintf("%s\t\t// %s (type: %s) needs to be set\n", indent, nestedFieldName, nestedField.AVP.TypeName))
				}

				// Only show first few fields in test to keep it readable
				if i >= 2 && len(field.AVP.GroupedFields) > 3 {
					buf.WriteString(fmt.Sprintf("%s\t\t// ... and %d more fields\n", indent, len(field.AVP.GroupedFields)-i-1))
					break
				}
			}

			if isRepeated {
				buf.WriteString(fmt.Sprintf("%s\t},\n", indent))
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			} else {
				buf.WriteString(fmt.Sprintf("%s}\n", indent))
			}
		} else {
			// Fallback for grouped AVPs without nested field definitions
			if isRepeated {
				buf.WriteString(fmt.Sprintf("\t// %s.%s (Grouped) needs to be set manually\n", varName, fieldName))
			} else {
				buf.WriteString(fmt.Sprintf("\t// %s.%s (Grouped) needs to be set manually\n", varName, fieldName))
			}
		}
	default:
		// For other types, add a comment
		buf.WriteString(fmt.Sprintf("\t// %s.%s needs to be set manually (type: %s)\n", varName, fieldName, field.AVP.TypeName))
	}
}

// generateCommandUnitTest generates basic unit tests for a command
func (g *Generator) generateCommandUnitTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))
	testFuncName := fmt.Sprintf("Test%s_Creation", structName)

	buf.WriteString(fmt.Sprintf("// %s tests basic creation and initialization\n", testFuncName))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testFuncName))
	buf.WriteString(fmt.Sprintf("\tmsg := New%s()\n\n", structName))

	buf.WriteString("\t// Verify header initialization\n")
	buf.WriteString("\tif msg.Header.Version != 1 {\n")
	buf.WriteString("\t\tt.Errorf(\"Expected version 1, got %d\", msg.Header.Version)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\tif msg.Header.CommandCode != %d {\n", cmd.Code))
	buf.WriteString(fmt.Sprintf("\t\tt.Errorf(\"Expected command code %d, got %%d\", msg.Header.CommandCode)\n", cmd.Code))
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\tif msg.Header.ApplicationID != %d {\n", cmd.ApplicationID))
	buf.WriteString(fmt.Sprintf("\t\tt.Errorf(\"Expected application ID %d, got %%d\", msg.Header.ApplicationID)\n", cmd.ApplicationID))
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\tif msg.Header.Flags.Request != %v {\n", cmd.Request))
	buf.WriteString(fmt.Sprintf("\t\tt.Errorf(\"Expected Request flag %v, got %%v\", msg.Header.Flags.Request)\n", cmd.Request))
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\tif msg.Header.Flags.Proxiable != %v {\n", cmd.Proxiable))
	buf.WriteString(fmt.Sprintf("\t\tt.Errorf(\"Expected Proxiable flag %v, got %%v\", msg.Header.Flags.Proxiable)\n", cmd.Proxiable))
	buf.WriteString("\t}\n")

	buf.WriteString("}\n\n")
}

// generateCommandValidationTest generates validation tests
func (g *Generator) generateCommandValidationTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))
	testFuncName := fmt.Sprintf("Test%s_Validation", structName)

	buf.WriteString(fmt.Sprintf("// %s tests field validation\n", testFuncName))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testFuncName))

	// Test 1: Empty message should fail validation
	buf.WriteString("\tt.Run(\"EmptyMessage\", func(t *testing.T) {\n")
	buf.WriteString(fmt.Sprintf("\t\tmsg := &%s{}\n", structName))
	buf.WriteString("\t\terr := msg.Validate()\n")

	// Check if there are any required fields that can be validated
	hasValidatableRequired := false
	for _, field := range cmd.Fields {
		if field.Required && !field.Repeated {
			switch field.AVP.TypeName {
			case "UTF8String", "DiameterIdentity", "DiameterURI", "OctetString":
				hasValidatableRequired = true
				break
			}
		} else if field.Required && field.Repeated {
			hasValidatableRequired = true
			break
		}
	}

	if hasValidatableRequired {
		buf.WriteString("\t\tif err == nil {\n")
		buf.WriteString("\t\t\tt.Error(\"Expected validation error for empty message, got nil\")\n")
		buf.WriteString("\t\t}\n")
	} else {
		buf.WriteString("\t\t// No validatable required fields\n")
		buf.WriteString("\t\t_ = err\n")
	}
	buf.WriteString("\t})\n\n")

	// Test 2: Valid message should pass validation
	buf.WriteString("\tt.Run(\"ValidMessage\", func(t *testing.T) {\n")
	buf.WriteString(fmt.Sprintf("\t\tmsg := New%s()\n", structName))

	// Set required fields
	cmdName := cmd.Name
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignment(buf, field, &cmdName)
		}
	}

	buf.WriteString("\n\t\terr := msg.Validate()\n")
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString("\t\t\tt.Errorf(\"Expected no validation error, got: %v\", err)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t})\n")

	buf.WriteString("}\n\n")
}

// generateCommandPcapTest generates PCAP file tests for both request and answer
func (g *Generator) generateCommandPcapTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))
	testFuncName := fmt.Sprintf("Test%s_PCAP", structName)
	pcapFileName := fmt.Sprintf("test_%s.pcap", strings.ToLower(strings.ReplaceAll(cmd.Abbreviation, "-", "_")))

	isRequest := cmd.Request
	msgType := "Request"
	if !isRequest {
		msgType = "Answer"
	}

	buf.WriteString(fmt.Sprintf("// %s tests PCAP file generation for %s message\n", testFuncName, msgType))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testFuncName))
	buf.WriteString("\t// Create testdata directory\n")
	buf.WriteString("\tif err := os.MkdirAll(\"testdata\", 0755); err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to create testdata directory: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create pcap file path\n")
	buf.WriteString(fmt.Sprintf("\tpcapFile := filepath.Join(\"testdata\", \"%s\")\n", pcapFileName))
	buf.WriteString("\t// PCAP files are kept for Wireshark analysis\n\n")

	buf.WriteString(fmt.Sprintf("\t// Create %s message with ALL fields populated\n", msgType))
	buf.WriteString(fmt.Sprintf("\tmsg := New%s()\n\n", structName))

	// Set ALL fields (required and optional) for complete PCAP examples
	cmdName := cmd.Name

	// Group fields by required/optional for better organization
	buf.WriteString("\t// Required fields\n")
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignmentWithAllChildren(buf, field, &cmdName, "msg", "\t")
		}
	}

	buf.WriteString("\n\t// Optional fields (for complete PCAP examples)\n")
	for _, field := range cmd.Fields {
		if !field.Required {
			g.generateTestFieldAssignmentWithAllChildren(buf, field, &cmdName, "msg", "\t")
		}
	}

	buf.WriteString("\n\t// Set header identifiers\n")
	buf.WriteString("\tmsg.Header.HopByHopID = 0x12345678\n")
	buf.WriteString("\tmsg.Header.EndToEndID = 0x87654321\n\n")

	buf.WriteString("\t// Marshal message\n")
	buf.WriteString("\tdata, err := msg.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to marshal message: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Write to PCAP\n")
	if isRequest {
		buf.WriteString("\terr = writeDiameterToPcap(pcapFile, data, net.ParseIP(\"192.168.1.100\"), net.ParseIP(\"192.168.1.1\"), 3868)\n")
	} else {
		buf.WriteString("\terr = writeDiameterToPcap(pcapFile, data, net.ParseIP(\"192.168.1.1\"), net.ParseIP(\"192.168.1.100\"), 3868)\n")
	}
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to write PCAP: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Verify PCAP file\n")
	buf.WriteString("\tinfo, err := os.Stat(pcapFile)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"PCAP file not created: %v\", err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif info.Size() == 0 {\n")
	buf.WriteString("\t\tt.Fatal(\"PCAP file is empty\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tt.Logf(\"PCAP file created: %s (%d bytes)\", pcapFile, info.Size())\n")
	buf.WriteString(fmt.Sprintf("\tt.Logf(\"Open in Wireshark to view the %s message\")\n", msgType))
	buf.WriteString("}\n\n")
}

// generateCommandPairPcapTest generates PCAP file tests for request-response pairs
func (g *Generator) generateCommandPairPcapTest(buf *bytes.Buffer, requestCmd, answerCmd *CommandDefinition) {
	requestStructName := toCamelCase(strings.ReplaceAll(requestCmd.Name, "-", "_"))
	answerStructName := toCamelCase(strings.ReplaceAll(answerCmd.Name, "-", "_"))
	// Generate a clean test name based on command abbreviation
	baseName := strings.TrimSuffix(requestCmd.Abbreviation, "R")
	if baseName == requestCmd.Abbreviation {
		// Try other patterns
		baseName = strings.TrimSuffix(requestCmd.Abbreviation, "Req")
	}
	pcapFileName := fmt.Sprintf("test_%sr_%sa.pcap", strings.ToLower(baseName), strings.ToLower(baseName))

	buf.WriteString(fmt.Sprintf("// Test%s_Pair_PCAP tests PCAP file generation for %s request-response pair\n", baseName, baseName))
	buf.WriteString(fmt.Sprintf("func Test%s_Pair_PCAP(t *testing.T) {\n", baseName))
	buf.WriteString("\t// Create testdata directory\n")
	buf.WriteString("\tif err := os.MkdirAll(\"testdata\", 0755); err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to create testdata directory: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create pcap file path\n")
	buf.WriteString(fmt.Sprintf("\tpcapFile := filepath.Join(\"testdata\", \"%s\")\n", pcapFileName))
	buf.WriteString("\t// PCAP files are kept for Wireshark analysis\n\n")

	buf.WriteString("\t// Create Request message\n")
	buf.WriteString(fmt.Sprintf("\trequest := New%s()\n", requestStructName))

	// Set required fields for request
	cmdName := requestCmd.Name
	for _, field := range requestCmd.Fields {
		if field.Required {
			g.generateTestFieldAssignmentWithAllChildren(buf, field, &cmdName, "request", "\t")
		}
	}

	for _, field := range requestCmd.Fields {
		if !field.Required {
			g.generateTestFieldAssignmentWithAllChildren(buf, field, &cmdName, "request", "\t")
		}
	}

	buf.WriteString("\n\t// Set header identifiers for request\n")
	buf.WriteString("\trequest.Header.HopByHopID = 0x12345678\n")
	buf.WriteString("\trequest.Header.EndToEndID = 0x87654321\n\n")

	buf.WriteString("\t// Create Answer message\n")
	buf.WriteString(fmt.Sprintf("\tanswer := New%s()\n", answerStructName))

	// Set required fields for answer
	cmdName = answerCmd.Name
	for _, field := range answerCmd.Fields {
		if field.Required {
			g.generateTestFieldAssignmentWithAllChildren(buf, field, &cmdName, "answer", "\t")
		}
	}

	for _, field := range answerCmd.Fields {
		if !field.Required {
			g.generateTestFieldAssignmentWithAllChildren(buf, field, &cmdName, "answer", "\t")
		}
	}

	buf.WriteString("\n\t// Set header identifiers for answer (must match request)\n")
	buf.WriteString("\tanswer.Header.HopByHopID = 0x12345678\n")
	buf.WriteString("\tanswer.Header.EndToEndID = 0x87654321\n\n")

	buf.WriteString("\t// Marshal request\n")
	buf.WriteString("\trequestData, err := request.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to marshal request: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Marshal answer\n")
	buf.WriteString("\tanswerData, err := answer.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to marshal answer: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Write request-response pair to PCAP\n")
	buf.WriteString("\terr = writeDiameterPairToPcap(pcapFile, requestData, answerData, net.ParseIP(\"192.168.1.100\"), net.ParseIP(\"192.168.1.1\"))\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to write PCAP: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Verify PCAP file\n")
	buf.WriteString("\tinfo, err := os.Stat(pcapFile)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"PCAP file not created: %v\", err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif info.Size() == 0 {\n")
	buf.WriteString("\t\tt.Fatal(\"PCAP file is empty\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tt.Logf(\"PCAP file created: %s (%d bytes)\", pcapFile, info.Size())\n")
	buf.WriteString("\tt.Logf(\"Open in Wireshark to view the request-response pair\")\n")
	buf.WriteString("}\n\n")
}

// generatePairedPcapTests generates PCAP tests for all request-response pairs
func (g *Generator) generatePairedPcapTests(buf *bytes.Buffer) {
	// Build a map of command codes to their request and answer commands
	commandPairs := make(map[uint32]struct {
		request *CommandDefinition
		answer  *CommandDefinition
	})

	// First pass: collect all commands by code
	for _, cmd := range g.Parser.Commands {
		pair := commandPairs[cmd.Code]
		if cmd.Request {
			pair.request = cmd
		} else {
			pair.answer = cmd
		}
		commandPairs[cmd.Code] = pair
	}

	// Second pass: generate tests for complete pairs
	// Sort by command name for consistent output
	sortedPairs := make([]struct {
		request *CommandDefinition
		answer  *CommandDefinition
	}, 0, len(commandPairs))
	for _, pair := range commandPairs {
		if pair.request != nil && pair.answer != nil {
			sortedPairs = append(sortedPairs, pair)
		}
	}
	sort.Slice(sortedPairs, func(i, j int) bool {
		return sortedPairs[i].request.Name < sortedPairs[j].request.Name
	})
	for _, pair := range sortedPairs {
		g.generateCommandPairPcapTest(buf, pair.request, pair.answer)
	}
}

// generateCommandRoundtripTest generates Marshal/Unmarshal roundtrip tests
func (g *Generator) generateCommandRoundtripTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))
	testFuncName := fmt.Sprintf("Test%s_MarshalUnmarshal", structName)

	buf.WriteString(fmt.Sprintf("// %s tests Marshal and Unmarshal roundtrip\n", testFuncName))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testFuncName))

	buf.WriteString("\t// Create original message\n")
	buf.WriteString(fmt.Sprintf("\toriginal := New%s()\n", structName))

	// Set required fields using original variable
	cmdName := cmd.Name
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignmentWithVar(buf, field, &cmdName, "original", "\t")
		}
	}

	buf.WriteString("\n\t// Set header identifiers for comparison\n")
	buf.WriteString("\toriginal.Header.HopByHopID = 0xAABBCCDD\n")
	buf.WriteString("\toriginal.Header.EndToEndID = 0x11223344\n\n")

	buf.WriteString("\t// Marshal original\n")
	buf.WriteString("\tdata, err := original.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to marshal: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Unmarshal into new message\n")
	buf.WriteString(fmt.Sprintf("\tdecoded := &%s{}\n", structName))
	buf.WriteString("\terr = decoded.Unmarshal(data)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to unmarshal: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Verify header fields\n")
	buf.WriteString("\tif decoded.Header.Version != original.Header.Version {\n")
	buf.WriteString("\t\tt.Errorf(\"Version mismatch: got %d, want %d\", decoded.Header.Version, original.Header.Version)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif decoded.Header.CommandCode != original.Header.CommandCode {\n")
	buf.WriteString("\t\tt.Errorf(\"CommandCode mismatch: got %d, want %d\", decoded.Header.CommandCode, original.Header.CommandCode)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif decoded.Header.ApplicationID != original.Header.ApplicationID {\n")
	buf.WriteString("\t\tt.Errorf(\"ApplicationID mismatch: got %d, want %d\", decoded.Header.ApplicationID, original.Header.ApplicationID)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif decoded.Header.HopByHopID != original.Header.HopByHopID {\n")
	buf.WriteString("\t\tt.Errorf(\"HopByHopID mismatch: got 0x%X, want 0x%X\", decoded.Header.HopByHopID, original.Header.HopByHopID)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tif decoded.Header.EndToEndID != original.Header.EndToEndID {\n")
	buf.WriteString("\t\tt.Errorf(\"EndToEndID mismatch: got 0x%X, want 0x%X\", decoded.Header.EndToEndID, original.Header.EndToEndID)\n")
	buf.WriteString("\t}\n\n")

	// Verify required string fields
	for _, field := range cmd.Fields {
		if field.Required && !field.Repeated {
			switch field.AVP.TypeName {
			case "UTF8String", "DiameterIdentity":
				buf.WriteString(fmt.Sprintf("\tif decoded.%s != original.%s {\n", field.FieldName, field.FieldName))
				buf.WriteString(fmt.Sprintf("\t\tt.Errorf(\"%s mismatch: got %%v, want %%v\", decoded.%s, original.%s)\n", field.FieldName, field.FieldName, field.FieldName))
				buf.WriteString("\t}\n")
			case "Unsigned32", "Enumerated":
				buf.WriteString(fmt.Sprintf("\tif decoded.%s != original.%s {\n", field.FieldName, field.FieldName))
				buf.WriteString(fmt.Sprintf("\t\tt.Errorf(\"%s mismatch: got %%d, want %%d\", decoded.%s, original.%s)\n", field.FieldName, field.FieldName, field.FieldName))
				buf.WriteString("\t}\n")
			}
		} else if field.Required && field.Repeated {
			switch field.AVP.TypeName {
			case "Address":
				buf.WriteString(fmt.Sprintf("\tif len(decoded.%s) != len(original.%s) {\n", field.FieldName, field.FieldName))
				buf.WriteString(fmt.Sprintf("\t\tt.Errorf(\"%s length mismatch: got %%d, want %%d\", len(decoded.%s), len(original.%s))\n", field.FieldName, field.FieldName, field.FieldName))
				buf.WriteString("\t}\n")
			}
		}
	}

	buf.WriteString("\n\t// Marshal again and compare bytes\n")
	buf.WriteString("\tdata2, err := decoded.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"Failed to marshal decoded message: %v\", err)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tif !bytes.Equal(data, data2) {\n")
	buf.WriteString("\t\tt.Errorf(\"Marshaled data differs after roundtrip (len: %d vs %d)\", len(data), len(data2))\n")
	buf.WriteString("\t}\n")

	buf.WriteString("}\n\n")
}

// generateCommandValidationMissingFieldsTest generates validation tests for missing required fields
func (g *Generator) generateCommandValidationMissingFieldsTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	// Get all required fields
	requiredFields := make([]*AVPField, 0)
	for _, field := range cmd.Fields {
		if field.Required && !field.Fixed {
			requiredFields = append(requiredFields, field)
		}
	}

	// Skip if no required fields
	if len(requiredFields) == 0 {
		return
	}

	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))
	funcName := fmt.Sprintf("TestValidateMissingFields_%s", cmd.Abbreviation)
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", funcName))
	buf.WriteString("\t// Test validation with each required field missing\n")
	buf.WriteString("\ttests := []struct {\n")
	buf.WriteString("\t\tname         string\n")
	buf.WriteString("\t\tmissingField string\n")
	buf.WriteString(fmt.Sprintf("\t\tsetupFunc    func(*%s)\n", structName))
	buf.WriteString("\t}{\n")

	// Generate test cases for each required field
	for _, field := range requiredFields {
		buf.WriteString(fmt.Sprintf("\t\t{\n"))
		buf.WriteString(fmt.Sprintf("\t\t\tname:         \"missing_%s\",\n", field.FieldName))
		buf.WriteString(fmt.Sprintf("\t\t\tmissingField: \"%s\",\n", field.AVP.Name))
		buf.WriteString(fmt.Sprintf("\t\t\tsetupFunc: func(msg *%s) {\n", structName))
		buf.WriteString("\t\t\t\t// Set all fields except the one being tested\n")

		// Set all required fields except the current one
		for _, f := range requiredFields {
			if f.FieldName != field.FieldName {
				g.generateTestFieldAssignment(buf, f, &cmd.Name)
			}
		}

		buf.WriteString("\t\t\t},\n")
		buf.WriteString("\t\t},\n")
	}

	buf.WriteString("\t}\n\n")

	buf.WriteString("\tfor _, tt := range tests {\n")
	buf.WriteString("\t\tt.Run(tt.name, func(t *testing.T) {\n")
	buf.WriteString(fmt.Sprintf("\t\t\tmsg := New%s()\n", structName))
	buf.WriteString("\t\t\ttt.setupFunc(msg)\n\n")
	buf.WriteString("\t\t\terr := msg.Validate()\n")
	buf.WriteString("\t\t\tif err == nil {\n")
	buf.WriteString("\t\t\t\tt.Errorf(\"Expected validation error for missing %s, but got nil\", tt.missingField)\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t})\n")
	buf.WriteString("\t}\n")

	buf.WriteString("}\n\n")
}

// generateCommandBenchmarkTest generates benchmark tests for the command
func (g *Generator) generateCommandBenchmarkTest(buf *bytes.Buffer, cmd *CommandDefinition) {
	structName := toCamelCase(strings.ReplaceAll(cmd.Name, "-", "_"))

	// Benchmark for message creation
	buf.WriteString(fmt.Sprintf("func BenchmarkNew%s(b *testing.B) {\n", structName))
	buf.WriteString("\tb.ReportAllocs()\n")
	buf.WriteString("\tfor i := 0; i < b.N; i++ {\n")
	buf.WriteString(fmt.Sprintf("\t\t_ = New%s()\n", structName))
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Benchmark for Marshal operation
	buf.WriteString(fmt.Sprintf("func Benchmark%s_Marshal(b *testing.B) {\n", structName))
	buf.WriteString(fmt.Sprintf("\tmsg := New%s()\n", structName))
	buf.WriteString("\n\t// Set required fields\n")
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignment(buf, field, &cmd.Name)
		}
	}
	buf.WriteString("\n\tb.ResetTimer()\n")
	buf.WriteString("\tb.ReportAllocs()\n")
	buf.WriteString("\tfor i := 0; i < b.N; i++ {\n")
	buf.WriteString("\t\t_, err := msg.Marshal()\n")
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString("\t\t\tb.Fatal(err)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Benchmark for Unmarshal operation
	buf.WriteString(fmt.Sprintf("func Benchmark%s_Unmarshal(b *testing.B) {\n", structName))
	buf.WriteString(fmt.Sprintf("\tmsg := New%s()\n", structName))
	buf.WriteString("\n\t// Set required fields\n")
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignment(buf, field, &cmd.Name)
		}
	}
	buf.WriteString("\n\tdata, err := msg.Marshal()\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tb.Fatal(err)\n")
	buf.WriteString("\t}\n\n")
	buf.WriteString("\tb.ResetTimer()\n")
	buf.WriteString("\tb.ReportAllocs()\n")
	buf.WriteString("\tfor i := 0; i < b.N; i++ {\n")
	buf.WriteString(fmt.Sprintf("\t\tresult := &%s{}\n", structName))
	buf.WriteString("\t\terr := result.Unmarshal(data)\n")
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString("\t\t\tb.Fatal(err)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	// Benchmark for full roundtrip
	buf.WriteString(fmt.Sprintf("func Benchmark%s_Roundtrip(b *testing.B) {\n", structName))
	buf.WriteString(fmt.Sprintf("\tmsg := New%s()\n", structName))
	buf.WriteString("\n\t// Set required fields\n")
	for _, field := range cmd.Fields {
		if field.Required {
			g.generateTestFieldAssignment(buf, field, &cmd.Name)
		}
	}
	buf.WriteString("\n\tb.ResetTimer()\n")
	buf.WriteString("\tb.ReportAllocs()\n")
	buf.WriteString("\tfor i := 0; i < b.N; i++ {\n")
	buf.WriteString("\t\tdata, err := msg.Marshal()\n")
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString("\t\t\tb.Fatal(err)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString(fmt.Sprintf("\t\tresult := &%s{}\n", structName))
	buf.WriteString("\t\terr = result.Unmarshal(data)\n")
	buf.WriteString("\t\tif err != nil {\n")
	buf.WriteString("\t\t\tb.Fatal(err)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")
}

// hasAddressFields checks if any command uses Address type fields
func (g *Generator) hasAddressFields() bool {
	for _, cmd := range g.Parser.Commands {
		for _, field := range cmd.Fields {
			if field.AVP != nil && field.AVP.TypeName == "Address" {
				return true
			}
		}
	}
	return false
}

// GenerateUnitTests generates only unit tests (creation, validation, roundtrip)
func (g *Generator) GenerateUnitTests() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	if g.hasAddressFields() {
		buf.WriteString("\t\"net\"\n")
	}
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/hsdfat/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")

	// Generate test functions for each command
	for _, cmd := range g.Parser.Commands {
		// Generate comprehensive unit tests
		g.generateCommandUnitTest(&buf, cmd)
		// Generate validation test
		g.generateCommandValidationTest(&buf, cmd)
		// Generate validation test for missing required fields
		g.generateCommandValidationMissingFieldsTest(&buf, cmd)
		// Generate Marshal/Unmarshal roundtrip test
		g.generateCommandRoundtripTest(&buf, cmd)
	}

	return buf.String(), nil
}

// GeneratePcapTests generates only PCAP generation tests
func (g *Generator) GeneratePcapTests() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"net\"\n")
	buf.WriteString("\t\"os\"\n")
	buf.WriteString("\t\"path/filepath\"\n")
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString("\t\"time\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/google/gopacket\"\n")
	buf.WriteString("\t\"github.com/google/gopacket/layers\"\n")
	buf.WriteString("\t\"github.com/google/gopacket/pcapgo\"\n")
	buf.WriteString("\t\"github.com/hsdfat/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")

	// Generate pcap helper functions
	g.generatePcapHelpers(&buf)

	// Generate PCAP test functions for each command
	// for _, cmd := range g.Parser.Commands {
	// 	g.generateCommandPcapTest(&buf, cmd)
	// }

	// Generate paired request-response PCAP tests
	g.generatePairedPcapTests(&buf)

	return buf.String(), nil
}

// GenerateBenchmarkTests generates only benchmark tests
func (g *Generator) GenerateBenchmarkTests() (string, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by diameter-codegen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	// Write imports
	buf.WriteString("import (\n")
	if g.hasAddressFields() {
		buf.WriteString("\t\"net\"\n")
	}
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/hsdfat/diam-gw/models_base\"\n")
	buf.WriteString(")\n\n")

	// Generate benchmark tests for each command
	for _, cmd := range g.Parser.Commands {
		g.generateCommandBenchmarkTest(&buf, cmd)
	}

	return buf.String(), nil
}

// generateGroupedMarshal generates the Marshal method for a Grouped AVP
func (g *Generator) generateGroupedMarshal(buf *bytes.Buffer, structName string, avp *AVPDefinition) {
	buf.WriteString(fmt.Sprintf("// Marshal serializes %s to bytes\n", structName))
	buf.WriteString(fmt.Sprintf("func (g *%s) Marshal() ([]byte, error) {\n", structName))

	if len(avp.GroupedFields) == 0 {
		// No fields, return raw data
		buf.WriteString("\treturn g.Data, nil\n")
		buf.WriteString("}\n\n")
		return
	}

	buf.WriteString("\tvar buf bytes.Buffer\n\n")

	// Marshal each field
	for _, field := range avp.GroupedFields {
		// Skip fields with undefined AVP code
		if field.AVP.Code == 0 {
			buf.WriteString(fmt.Sprintf("\t// Skipping %s - AVP code not defined\n\n", field.FieldName))
			continue
		}

		// Get AVP code constant name
		avpCodeConst := g.getAVPCodeConstant(field.AVP.Name)

		// Handle Grouped types differently
		if field.AVP.TypeName == "Grouped" {
			if field.Repeated {
				buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated, grouped)\n", field.FieldName))
				buf.WriteString(fmt.Sprintf("\tfor _, v := range g.%s {\n", field.FieldName))
				buf.WriteString("\t\tif v != nil {\n")
				buf.WriteString("\t\t\tif groupedData, err := v.Marshal(); err == nil {\n")
				// Check if this nested grouped AVP has a vendor ID
				if field.AVP.VendorID != 0 {
					buf.WriteString(fmt.Sprintf("\t\t\t\tbuf.Write(marshalAVPWithVendor(%s, models_base.Grouped(groupedData), %v, %v, %s))\n",
						avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
				} else {
					buf.WriteString(fmt.Sprintf("\t\t\t\tbuf.Write(marshalAVP(%s, models_base.Grouped(groupedData), %v, %v))\n",
						avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt))
				}
				buf.WriteString("\t\t\t}\n")
				buf.WriteString("\t\t}\n")
				buf.WriteString("\t}\n\n")
			} else {
				buf.WriteString(fmt.Sprintf("\t// Marshal %s (grouped)\n", field.FieldName))
				buf.WriteString(fmt.Sprintf("\tif g.%s != nil {\n", field.FieldName))
				buf.WriteString(fmt.Sprintf("\t\tif groupedData, err := g.%s.Marshal(); err == nil {\n", field.FieldName))
				// Check if this nested grouped AVP has a vendor ID
				if field.AVP.VendorID != 0 {
					buf.WriteString(fmt.Sprintf("\t\t\tbuf.Write(marshalAVPWithVendor(%s, models_base.Grouped(groupedData), %v, %v, %s))\n",
						avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
				} else {
					buf.WriteString(fmt.Sprintf("\t\t\tbuf.Write(marshalAVP(%s, models_base.Grouped(groupedData), %v, %v))\n",
						avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt))
				}
				buf.WriteString("\t\t}\n")
				buf.WriteString("\t}\n\n")
			}
		} else {
			// Non-grouped fields
			if field.Repeated {
				buf.WriteString(fmt.Sprintf("\t// Marshal %s (repeated)\n", field.FieldName))
				buf.WriteString(fmt.Sprintf("\tfor _, v := range g.%s {\n", field.FieldName))
				// Check if this field has a vendor ID
				if field.AVP.VendorID != 0 {
					buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVPWithVendor(%s, v, %v, %v, %s))\n",
						avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
				} else {
					buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%s, v, %v, %v))\n",
						avpCodeConst, field.AVP.Must, field.AVP.MayEncrypt))
				}
				buf.WriteString("\t}\n\n")
			} else if !field.Required {
				buf.WriteString(fmt.Sprintf("\t// Marshal %s (optional)\n", field.FieldName))
				buf.WriteString(fmt.Sprintf("\tif g.%s != nil {\n", field.FieldName))
				// Check if this field has a vendor ID
				if field.AVP.VendorID != 0 {
					buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVPWithVendor(%s, *g.%s, %v, %v, %s))\n",
						avpCodeConst, field.FieldName, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
				} else {
					buf.WriteString(fmt.Sprintf("\t\tbuf.Write(marshalAVP(%s, *g.%s, %v, %v))\n",
						avpCodeConst, field.FieldName, field.AVP.Must, field.AVP.MayEncrypt))
				}
				buf.WriteString("\t}\n\n")
			} else {
				buf.WriteString(fmt.Sprintf("\t// Marshal %s (required)\n", field.FieldName))
				// Check if this field has a vendor ID
				if field.AVP.VendorID != 0 {
					buf.WriteString(fmt.Sprintf("\tbuf.Write(marshalAVPWithVendor(%s, g.%s, %v, %v, %s))\n\n",
						avpCodeConst, field.FieldName, field.AVP.Must, field.AVP.MayEncrypt, g.getVendorIDConstant(field.AVP.VendorID)))
				} else {
					buf.WriteString(fmt.Sprintf("\tbuf.Write(marshalAVP(%s, g.%s, %v, %v))\n\n",
						avpCodeConst, field.FieldName, field.AVP.Must, field.AVP.MayEncrypt))
				}
			}
		}
	}

	buf.WriteString("\n\treturn buf.Bytes(), nil\n")
	buf.WriteString("}\n\n")
}

// generateGroupedUnmarshal generates the Unmarshal method for a Grouped AVP
func (g *Generator) generateGroupedUnmarshal(buf *bytes.Buffer, structName string, avp *AVPDefinition) {
	buf.WriteString(fmt.Sprintf("// Unmarshal deserializes bytes into %s\n", structName))
	buf.WriteString(fmt.Sprintf("func (g *%s) Unmarshal(data []byte) error {\n", structName))

	if len(avp.GroupedFields) == 0 {
		// No fields, store raw data
		buf.WriteString("\tg.Data = make([]byte, len(data))\n")
		buf.WriteString("\tcopy(g.Data, data)\n")
		buf.WriteString("\treturn nil\n")
		buf.WriteString("}\n\n")
		return
	}

	buf.WriteString("\t// Parse AVPs in the grouped data\n")
	buf.WriteString("\tavpData := data\n")
	buf.WriteString("\tfor len(avpData) > 0 {\n")
	buf.WriteString("\t\tif len(avpData) < 8 {\n")
	buf.WriteString("\t\t\tbreak // Not enough data for AVP header\n")
	buf.WriteString("\t\t}\n\n")

	// Count how many fields have valid codes
	hasValidCodes := false
	for _, field := range avp.GroupedFields {
		if field.AVP.Code != 0 {
			hasValidCodes = true
			break
		}
	}

	buf.WriteString("\t\t// Parse AVP header\n")
	if hasValidCodes {
		buf.WriteString("\t\tavpCode := binary.BigEndian.Uint32(avpData[0:4])\n")
	} else {
		buf.WriteString("\t\t_ = binary.BigEndian.Uint32(avpData[0:4]) // avpCode\n")
	}
	buf.WriteString("\t\tavpFlags := avpData[4]\n")
	buf.WriteString("\t\tavpLength := binary.BigEndian.Uint32([]byte{0, avpData[5], avpData[6], avpData[7]})\n\n")

	buf.WriteString("\t\tif int(avpLength) > len(avpData) {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"AVP length exceeds remaining data\")\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Extract AVP data\n")
	buf.WriteString("\t\theaderSize := 8\n")

	// Check if any grouped field has a vendor ID that needs to be matched
	hasVendorSpecificFields := false
	for _, field := range avp.GroupedFields {
		if field.AVP.VendorID != 0 {
			hasVendorSpecificFields = true
			break
		}
	}

	if hasVendorSpecificFields {
		buf.WriteString("\t\tvar vendorID uint32\n")
	}
	buf.WriteString("\t\tif avpFlags&0x80 != 0 { // V-bit set\n")
	buf.WriteString("\t\t\tif len(avpData) < 12 {\n")
	buf.WriteString("\t\t\t\treturn fmt.Errorf(\"AVP data too short for vendor ID\")\n")
	buf.WriteString("\t\t\t}\n")
	if hasVendorSpecificFields {
		buf.WriteString("\t\t\tvendorID = binary.BigEndian.Uint32(avpData[8:12])\n")
	} else {
		buf.WriteString("\t\t\t_ = binary.BigEndian.Uint32(avpData[8:12]) // vendorID not used\n")
	}
	buf.WriteString("\t\t\theaderSize = 12\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpDataLen := int(avpLength) - headerSize\n")
	buf.WriteString("\t\tif avpDataLen < 0 {\n")
	buf.WriteString("\t\t\treturn fmt.Errorf(\"invalid AVP data length\")\n")
	buf.WriteString("\t\t}\n")

	if hasValidCodes {
		buf.WriteString("\t\tavpValue := avpData[headerSize : headerSize+avpDataLen]\n\n")
		buf.WriteString("\t\t// Parse AVP based on code and vendor ID\n")
		buf.WriteString("\t\tswitch avpCode {\n")

		// Generate case for each field
		for _, field := range avp.GroupedFields {
			// Skip AVPs with code 0 (undefined/generic AVPs) - add comment instead
			if field.AVP.Code == 0 {
				buf.WriteString(fmt.Sprintf("\t\t// case 0: // %s (AVP code not defined)\n", field.AVP.Name))
				continue
			}
			// Use constant instead of hardcoded number
			avpCodeConst := g.getAVPCodeConstant(field.AVP.Name)
			buf.WriteString(fmt.Sprintf("\t\tcase %s: // %s\n", avpCodeConst, field.AVP.Name))

			// Check vendor ID if it's a vendor-specific AVP
			if field.AVP.VendorID != 0 {
				buf.WriteString(fmt.Sprintf("\t\t\tif vendorID != %s {\n", g.getVendorIDConstant(field.AVP.VendorID)))
				buf.WriteString("\t\t\t\tbreak // Vendor ID mismatch\n")
				buf.WriteString("\t\t\t}\n")
			}

			// Handle Grouped types differently
			if field.AVP.TypeName == "Grouped" {
				structType := g.getBaseGoTypeForField(field)
				if field.Repeated {
					buf.WriteString(fmt.Sprintf("\t\t\tgrouped := &%s{}\n", structType))
					buf.WriteString("\t\t\tif err := grouped.Unmarshal(avpValue); err == nil {\n")
					buf.WriteString(fmt.Sprintf("\t\t\t\tg.%s = append(g.%s, grouped)\n", field.FieldName, field.FieldName))
					buf.WriteString("\t\t\t}\n")
				} else {
					buf.WriteString(fmt.Sprintf("\t\t\tgrouped := &%s{}\n", structType))
					buf.WriteString("\t\t\tif err := grouped.Unmarshal(avpValue); err == nil {\n")
					buf.WriteString(fmt.Sprintf("\t\t\t\tg.%s = grouped\n", field.FieldName))
					buf.WriteString("\t\t\t}\n")
				}
			} else {
				decoder := g.getDecoder(field.AVP.TypeName)
				if field.Repeated {
					buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
					buf.WriteString("\t\t\tif err == nil {\n")
					buf.WriteString(fmt.Sprintf("\t\t\t\tg.%s = append(g.%s, val.(%s))\n",
						field.FieldName, field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
					buf.WriteString("\t\t\t}\n")
				} else if !field.Required {
					buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
					buf.WriteString("\t\t\tif err == nil {\n")
					buf.WriteString(fmt.Sprintf("\t\t\t\tv := val.(%s)\n", g.getBaseGoType(field.AVP.TypeName)))
					buf.WriteString(fmt.Sprintf("\t\t\t\tg.%s = &v\n", field.FieldName))
					buf.WriteString("\t\t\t}\n")
				} else {
					buf.WriteString(fmt.Sprintf("\t\t\tval, err := %s(avpValue)\n", decoder))
					buf.WriteString("\t\t\tif err == nil {\n")
					buf.WriteString(fmt.Sprintf("\t\t\t\tg.%s = val.(%s)\n",
						field.FieldName, g.getBaseGoType(field.AVP.TypeName)))
					buf.WriteString("\t\t\t}\n")
				}
			}
		}

		buf.WriteString("\t\t}\n\n")
	} else {
		buf.WriteString("\t\t_ = avpDataLen // avpValue not needed when no fields are defined\n\n")
	}

	buf.WriteString("\t\t// Move to next AVP (with padding)\n")
	buf.WriteString("\t\tpaddedLength := int(avpLength)\n")
	buf.WriteString("\t\tif paddedLength%4 != 0 {\n")
	buf.WriteString("\t\t\tpaddedLength += 4 - (paddedLength % 4)\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tif paddedLength > len(avpData) {\n")
	buf.WriteString("\t\t\tbreak\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\tavpData = avpData[paddedLength:]\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n\n")
}
